<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="tWqzAeLYHxufjgoQXpm3qh6YTje2bah03cY7dTfBvWw">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝色步行者">
<meta property="og:url" content="http://www.jianzzz.com/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓝色步行者">
<meta name="twitter:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/">





  <title>蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2019/06/16/探讨下kubernetes的证书体系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/探讨下kubernetes的证书体系/" itemprop="url">探讨下kubernetes的证书体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T16:08:08+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>一直以来，对kubernetes的身份验证、授权、准入控制似懂非懂。抄起键盘胡乱打，似懂非懂最可怕。所以，利用起周末时间，好好地学习一下。</p>
<h1 id="pem证书和相关命令"><a href="#pem证书和相关命令" class="headerlink" title="pem证书和相关命令"></a>pem证书和相关命令</h1><h2 id="pem是什么"><a href="#pem是什么" class="headerlink" title="pem是什么"></a>pem是什么</h2><p>PEM: Privacy Enhanced Mail的缩写，以文本的方式进行存储。</p>
<ul>
<li>以pem格式存储的证书结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">Base64编码过的证书数据</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>kubernetes使用的是.crt和.key后缀类型的证书和密钥。在生成证书的过程中，可以用cfssl生成.pem证书，然后直接命名为.crt。</p>
<h2 id="证书查看命令"><a href="#证书查看命令" class="headerlink" title="证书查看命令"></a>证书查看命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in xxx.crt -text -noout</span><br><span class="line">cfssl certinfo -cert xxx.crt</span><br></pre></td></tr></table></figure>
<h1 id="证书标准"><a href="#证书标准" class="headerlink" title="证书标准"></a>证书标准</h1><p>kubernetes使用X.509数字证书标准。使用kubeadm部署集群的话，可以自动生成证书，但证书有效期只有一到两年。推荐使用kubeadm生成证书用于参考，然后按照kubernetes的证书标准自制证书。</p>
<h2 id="kubeadm和证书类型"><a href="#kubeadm和证书类型" class="headerlink" title="kubeadm和证书类型"></a>kubeadm和证书类型</h2><p>生成证书命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init phase certs all --cert-dir=绝对路径</span><br></pre></td></tr></table></figure></p>
<p>查看生成的证书：<br><img src="/2019/06/16/探讨下kubernetes的证书体系/1.PNG" title="kubernetes证书"><br>kubeadm主要是生成了etcd和kubernetes本身的证书。使用kubeadm安装集群的过程中，如果我们按照kubernetes标准自制证书，且跳过<code>kubeadm init phase certs</code>步骤，是不是所有场景都会使用到自制证书了呢？<br>答案是否定的，至少/etc/kubernetes/admin.conf、kubelet.conf、controller-manager.conf、scheduler.conf里面仍会默认生成认证证书和密钥。这些配置主要与user accounts有关，因此我们还要针对这些场景，自制证书，同时对上述文件进行扩展，这是后话。<br>完整的证书：<br><img src="/2019/06/16/探讨下kubernetes的证书体系/2.PNG" title="kubernetes证书"></p>
<p>可以看出，主要是根证书、证书、密钥。<br>下面对根证书和证书的内容进行抽象说明，主要参考<a href="https://kangzubin.com/certificate-format/" target="_blank" rel="noopener">SSL 数字证书的标准、编码以及文件扩展名</a>。</p>
<h2 id="根证书主要内容"><a href="#根证书主要内容" class="headerlink" title="根证书主要内容"></a>根证书主要内容</h2><p>使用<code>openssl x509 -in xxx.crt -text -noout</code>查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 0 (0x0)	说明：CA机构给该证书的唯一序列号，根证书为0</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption	说明：签名算法为SHA-256</span><br><span class="line">        Issuer: CN=xxx	说明：证书颁发者的相关信息</span><br><span class="line">        Validity	说明：证书生效日期和失效日期</span><br><span class="line">            Not Before: xxx</span><br><span class="line">            Not After : xxx</span><br><span class="line">        Subject: CN=xxx	说明：证书持有者的相关信息</span><br><span class="line">        Subject Public Key Info:	说明：服务端公开的密钥</span><br><span class="line">            Public Key Algorithm: rsaEncryption	说明：RSA公钥</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                xxx, xxx, xxx</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:TRUE</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption	说明：数字签名</span><br><span class="line">         xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:</span><br></pre></td></tr></table></figure></p>
<h2 id="证书主要内容"><a href="#证书主要内容" class="headerlink" title="证书主要内容"></a>证书主要内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 12345678901234567890 (0x1234567890abcdef)	说明：CA机构给该证书的唯一序列号</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption	说明：签名算法为SHA-256</span><br><span class="line">        Issuer: CN=xxx	说明：证书颁发者的相关信息</span><br><span class="line">        Validity	说明：证书生效日期和失效日期</span><br><span class="line">            Not Before: xxx</span><br><span class="line">            Not After : xxx</span><br><span class="line">        Subject: CN=xxx	说明：证书持有者的相关信息</span><br><span class="line">        Subject Public Key Info:	说明：服务端公开的密钥</span><br><span class="line">            Public Key Algorithm: rsaEncryption	说明：RSA公钥</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                xxx</span><br><span class="line">            X509v3 Extended Key Usage: </span><br><span class="line">                xxx</span><br><span class="line">            X509v3 Subject Alternative Name: </span><br><span class="line">                DNS:xxx, IP Address:xxx	说明：支持的DNS和IP</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption	说明：数字签名</span><br><span class="line">         xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:</span><br></pre></td></tr></table></figure>
<h2 id="各个证书的区别"><a href="#各个证书的区别" class="headerlink" title="各个证书的区别"></a>各个证书的区别</h2><p>注：<strong>证书的O、CN字段用于提供RBAC所需的用户组和用户。</strong><br>kubernetest证书制作标准参考<a href="https://kubernetes.io/docs/setup/best-practices/certificates/" target="_blank" rel="noopener">PKI certificates and requirements</a>。<br>另外，参考<a href="https://www.ibm.com/support/knowledgecenter/SSKTMJ_10.0.1/admin/conf_keyusageextensionsandextendedkeyusage_r.html" target="_blank" rel="noopener">Key usage extensions and extended key usage</a>，简单说明一下证书中用到的Key Usage和Extended Key Usage。</p>
<table>
<thead>
<tr>
<th>Key Usage</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Digital Signature</td>
<td>当公钥与数字签名机制一起使用时使用，以支持除不可否认、证书签名或CRL签名之外的其他安全服务。数字签名通常用于具有完整性的实体身份验证和数据源身份验证。</td>
</tr>
<tr>
<td>Key Encipherment</td>
<td>当证书与用于加密密钥的协议一起使用时使用。一个例子是S/MIME信封，其中使用证书中的公钥加密快速(对称)密钥。SSL协议还执行密钥加密。</td>
</tr>
<tr>
<td>Certificate Sign</td>
<td>当subject公钥用于验证证书上的签名时使用。此扩展只能在CA证书中使用。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Extended Key Usage</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>TLS Web Client Authentication</td>
<td>数字签名和/或密钥协议</td>
</tr>
<tr>
<td>TLS Web Server Authentication</td>
<td>数字签名、密钥加密或密钥协议</td>
</tr>
</tbody>
</table>
<ul>
<li>etcd<br>注：kubeadm默认生成的证书包含的信息</li>
</ul>
<table>
<thead>
<tr>
<th>证书</th>
<th>颁发者信息</th>
<th>持有者信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt</td>
<td>CN=etcd-ca</td>
<td>CN=etcd-ca</td>
</tr>
<tr>
<td>healthcheck-client.crt</td>
<td>CN=etcd-ca</td>
<td>O=system:masters, CN=kube-etcd-healthcheck-client</td>
</tr>
<tr>
<td>peer.crt</td>
<td>CN=etcd-ca</td>
<td>CN=<code>&lt;hostname&gt;</code></td>
</tr>
<tr>
<td>server.crt</td>
<td>CN=etcd-ca</td>
<td>CN=<code>&lt;hostname&gt;</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>证书</th>
<th>Key Usage</th>
<th>Basic Constraints</th>
<th>Extended Key Usage</th>
<th>Subject Alternative Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt</td>
<td>Digital Signature, Key Encipherment, Certificate Sign</td>
<td>CA:TRUE</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>healthcheck-client.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
</tr>
<tr>
<td>peer.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Server Authentication, TLS Web Client Authentication</td>
<td>DNS:<code>&lt;hostname&gt;</code>, DNS:localhost, IP Address:<code>&lt;Host_IP&gt;</code>, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1</td>
</tr>
<tr>
<td>server.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Server Authentication, TLS Web Client Authentication</td>
<td>DNS:<code>&lt;hostname&gt;</code>, DNS:localhost, IP Address:<code>&lt;Host_IP&gt;</code>, IP Address:127.0.0.1, IP Address:0:0:0:0:0:0:0:1</td>
</tr>
</tbody>
</table>
<ul>
<li>kubernetes<br>注：kubeadm默认生成的证书包含的信息</li>
</ul>
<table>
<thead>
<tr>
<th>证书</th>
<th>颁发者信息</th>
<th>持有者信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt</td>
<td>CN=kubernetes</td>
<td>CN=kubernetes</td>
</tr>
<tr>
<td>apiserver.crt</td>
<td>CN=kubernetes</td>
<td>CN=kube-apiserver</td>
</tr>
<tr>
<td>apiserver-kubelet-client.crt</td>
<td>CN=kubernetes</td>
<td>O=system:masters, CN=kube-apiserver-kubelet-client</td>
</tr>
<tr>
<td>apiserver-etcd-client.crt</td>
<td>CN=etcd-ca</td>
<td>O=system:masters, CN=kube-apiserver-etcd-client</td>
</tr>
<tr>
<td>front-proxy-ca.crt</td>
<td>CN=front-proxy-ca</td>
<td>CN=front-proxy-ca</td>
</tr>
<tr>
<td>front-proxy-client.crt</td>
<td>CN=front-proxy-ca</td>
<td>CN=front-proxy-client</td>
</tr>
<tr>
<td>sa.pub</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>证书</th>
<th>Key Usage</th>
<th>Basic Constraints</th>
<th>Extended Key Usage</th>
<th>Subject Alternative Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt</td>
<td>Digital Signature, Key Encipherment, Certificate Sign</td>
<td>CA:TRUE</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>apiserver.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Server Authentication</td>
<td>DNS:<code>&lt;hostname&gt;</code>, DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP Address:集群serviveIP, IP Address:<code>&lt;Host_IP&gt;</code></td>
</tr>
<tr>
<td>apiserver-kubelet-client.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
</tr>
<tr>
<td>apiserver-etcd-client.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
</tr>
<tr>
<td>front-proxy-ca.crt</td>
<td>Digital Signature, Key Encipherment, Certificate Sign</td>
<td>CA:TRUE</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>front-proxy-client.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>-</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
</tr>
<tr>
<td>sa.pub</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<ul>
<li>user accounts<br>注：自制证书包含的信息</li>
</ul>
<table>
<thead>
<tr>
<th>证书</th>
<th>颁发者信息</th>
<th>持有者信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.crt</td>
<td>CN=kubernetes</td>
<td>O=system:masters, CN=kubernetes-admin</td>
</tr>
<tr>
<td>kubelet.crt</td>
<td>CN=kubernetes</td>
<td>O=system:nodes, CN=system:node:<code>&lt;nodeName&gt;</code></td>
</tr>
<tr>
<td>scheduler.crt</td>
<td>CN=kubernetes</td>
<td>CN=system:kube-scheduler</td>
</tr>
<tr>
<td>controller-manager.crt</td>
<td>CN=kubernetes</td>
<td>CN=system:kube-controller-manager</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>证书</th>
<th>Key Usage</th>
<th>Basic Constraints</th>
<th>Extended Key Usage</th>
<th>Subject Alternative Name</th>
<th>Subject Key Identifier</th>
<th>Authority Key Identifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>CA:FALSE</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
<td>xx:xx</td>
<td>xx:xx</td>
</tr>
<tr>
<td>kubelet.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>CA:FALSE</td>
<td>TLS Web Server Authentication</td>
<td>-</td>
<td>xx:xx</td>
<td>xx:xx</td>
</tr>
<tr>
<td>scheduler.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>CA:FALSE</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
<td>xx:xx</td>
<td>xx:xx</td>
</tr>
<tr>
<td>controller-manager.crt</td>
<td>Digital Signature, Key Encipherment</td>
<td>CA:FALSE</td>
<td>TLS Web Client Authentication</td>
<td>-</td>
<td>xx:xx</td>
<td>xx:xx</td>
</tr>
</tbody>
</table>
<h1 id="自制证书"><a href="#自制证书" class="headerlink" title="自制证书"></a>自制证书</h1><p>参考<a href="https://kubernetes.io/docs/setup/best-practices/certificates/" target="_blank" rel="noopener">PKI certificates and requirements</a>、<a href="https://gist.github.com/detiber/81b515df272f5911959e81e39137a8bb" target="_blank" rel="noopener">CFSSL as an external CA for non-ha kubeadm intialized clusters</a>。</p>
<h2 id="ectd"><a href="#ectd" class="headerlink" title="ectd"></a>ectd</h2><ul>
<li>ca-config.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;signing&quot;: &#123;</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;server&quot;: &#123;</span><br><span class="line">                &quot;expiry&quot;: &quot;876000h&quot;,</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">		    &quot;digital signature&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;server auth&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;client&quot;: &#123;</span><br><span class="line">                &quot;expiry&quot;: &quot;876000h&quot;,</span><br><span class="line">                &quot;usages&quot;: [</span><br><span class="line">		    &quot;digital signature&quot;,</span><br><span class="line">                    &quot;key encipherment&quot;,</span><br><span class="line">                    &quot;client auth&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ca"><a href="#ca" class="headerlink" title="ca"></a>ca</h3><ul>
<li><p>ca-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;etcd-ca&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="healthcheck-client"><a href="#healthcheck-client" class="headerlink" title="healthcheck-client"></a>healthcheck-client</h3><ul>
<li><p>healthcheck-client-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-etcd-healthcheck-client&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client healthcheck-client-csr.json | cfssljson -bare healthcheck-client</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="peer"><a href="#peer" class="headerlink" title="peer"></a>peer</h3><ul>
<li><p>peer-csr.json.sed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-etcd-peer&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;localhost&quot;,&quot;127.0.0.1&quot;,&lt;ETCD_NODE_IPS&gt;],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server peer-csr.json | cfssljson -bare peer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><ul>
<li><p>server-csr.json.sed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-etcd&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;localhost&quot;,&quot;127.0.0.1&quot;,&lt;ETCD_NODE_IPS&gt;],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><ul>
<li>ca-config.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;server&quot;: &#123;</span><br><span class="line">        &quot;usages&quot;: [</span><br><span class="line">	    &quot;digital signature&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;client&quot;: &#123;</span><br><span class="line">        &quot;usages&quot;: [</span><br><span class="line">	    &quot;digital signature&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ca-1"><a href="#ca-1" class="headerlink" title="ca"></a>ca</h3><ul>
<li><p>ca-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes-ca&quot;,</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ca&quot;: &#123; </span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="apiserver"><a href="#apiserver" class="headerlink" title="apiserver"></a>apiserver</h3><ul>
<li><p>apiserver-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-apiserver&quot;,</span><br><span class="line">  &quot;hosts&quot;: [</span><br><span class="line">	&quot;localhost&quot;,</span><br><span class="line">	&quot;127.0.0.1&quot;,</span><br><span class="line">	&lt;MASTER_HOST_IPS&gt;,</span><br><span class="line">	&lt;MASTER_HOST_NAMES&gt;,</span><br><span class="line">	&quot;&lt;CLUSTER_SVC_IP&gt;&quot;,</span><br><span class="line">	&quot;&lt;VIP&gt;&quot;,</span><br><span class="line">	&quot;kubernetes&quot;,</span><br><span class="line">	&quot;kubernetes.default&quot;,</span><br><span class="line">	&quot;kubernetes.default.svc&quot;,</span><br><span class="line">	&quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">	&quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server apiserver-csr.json | cfssljson -bare apiserver</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="apiserver-kubelet-client"><a href="#apiserver-kubelet-client" class="headerlink" title="apiserver-kubelet-client"></a>apiserver-kubelet-client</h3><ul>
<li><p>apiserver-kubelet-client-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-apiserver-kubelet-client&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client apiserver-kubelet-client-csr.json | cfssljson -bare apiserver-kubelet-client</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="apiserver-etcd-client"><a href="#apiserver-etcd-client" class="headerlink" title="apiserver-etcd-client"></a>apiserver-etcd-client</h3><ul>
<li><p>apiserver-etcd-client-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-apiserver-etcd-client&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=etcd/ca.pem -ca-key=etcd/ca-key.pem -config=etcd/ca-config.json -profile=client apiserver-etcd-client-csr.json | cfssljson -bare apiserver-etcd-client</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="front-proxy"><a href="#front-proxy" class="headerlink" title="front-proxy"></a>front-proxy</h2><ul>
<li>front-proxy-ca-config.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;client&quot;: &#123;</span><br><span class="line">        &quot;expiry&quot;: &quot;876000h&quot;,</span><br><span class="line">        &quot;usages&quot;: [</span><br><span class="line">           &quot;digital signature&quot;,</span><br><span class="line">           &quot;key encipherment&quot;,</span><br><span class="line">           &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="front-proxy-ca"><a href="#front-proxy-ca" class="headerlink" title="front-proxy-ca"></a>front-proxy-ca</h3><ul>
<li><p>front-proxy-ca-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes-front-proxy-ca&quot;,</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ca&quot;: &#123; </span><br><span class="line">      &quot;expiry&quot;: &quot;876000h&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca front-proxy-ca-csr.json | cfssljson -bare front-proxy-ca</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="front-proxy-client"><a href="#front-proxy-client" class="headerlink" title="front-proxy-client"></a>front-proxy-client</h3><ul>
<li><p>front-proxy-client-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kube-front-client&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=front-proxy-ca.pem -ca-key=front-proxy-ca-key.pem -config=front-proxy-ca-config.json -profile=client front-proxy-client-csr.json | cfssljson -bare front-proxy-client</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="service-account"><a href="#service-account" class="headerlink" title="service account"></a>service account</h2><ul>
<li>命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out sa.key 2048</span><br><span class="line">openssl rsa -in sa.key -pubout -out sa.pub</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="user-accounts"><a href="#user-accounts" class="headerlink" title="user accounts"></a>user accounts</h2><h3 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h3><ul>
<li><p>admin-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;kubernetes-admin&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;system:masters&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client admin-csr.json | cfssljson -bare admin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><ul>
<li>kubelet-csr.json.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:node:&lt;nodeName&gt;&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;O&quot;: &quot;system:nodes&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>&lt;nodeName&gt;</code>必须精确匹配由kubelet向apiserver注册时提供的节点名的值。</p>
<ul>
<li>命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server kubelet-csr.json | cfssljson -bare kubelet</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><ul>
<li><p>scheduler-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:kube-scheduler&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client scheduler-csr.json | cfssljson -bare scheduler</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller-manager"></a>controller-manager</h3><ul>
<li><p>controller-manager-csr.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client controller-manager-csr.json | cfssljson -bare controller-manager</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>.pem和-key.pem直接转为.crt和.key文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for f in *-key.pem; do mv -v &quot;$f&quot; &quot;$&#123;f%-key.pem&#125;.key&quot;; done</span><br><span class="line">for f in *.pem; do mv -v &quot;$f&quot; &quot;$&#123;f%.pem&#125;.crt&quot;; done</span><br><span class="line">cd etcd </span><br><span class="line">for f in *-key.pem; do mv -v &quot;$f&quot; &quot;$&#123;f%-key.pem&#125;.key&quot;; done</span><br><span class="line">for f in *.pem; do mv -v &quot;$f&quot; &quot;$&#123;f%.pem&#125;.crt&quot;; done</span><br></pre></td></tr></table></figure></p>
<h1 id="kubernetes认证场景"><a href="#kubernetes认证场景" class="headerlink" title="kubernetes认证场景"></a>kubernetes认证场景</h1><p>通过上述证书内容和csr.json，可知kubernetes内部常用的加解密算法为非对称加密算法RSA。接下来具体分析一些场景下的认证过程。首先介绍一下https双向认证过程。</p>
<h2 id="https双向认证"><a href="#https双向认证" class="headerlink" title="https双向认证"></a>https双向认证</h2><p>参考<a href="https://blog.csdn.net/u012175637/article/details/84138925" target="_blank" rel="noopener">图解SSL/TLS认证流程</a>。<br><img src="/2019/06/16/探讨下kubernetes的证书体系/3.PNG" title="SSL/TLS认证流程"></p>
<h2 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h2><p>kubectl与apiserver通信，以控制和获取集群资源。这是一个双向认证过程。kubectl要验证apiserver的证书有效性，apiserver也要验证kubectl证书有效性。</p>
<h3 id="默认证书"><a href="#默认证书" class="headerlink" title="默认证书"></a>默认证书</h3><p>kubectl使用~/.kube/config配置文件，该文件拷贝自/etc/kubernetes/admin.conf。<br>需要关注的字段主要是：</p>
<ul>
<li>certificate-authority-data<br>用于验证apiserver发过来的证书。</li>
<li>client-certificate-data<br>kubectl发送的证书，apiserver会对其进行验证。</li>
<li>client-key-data<br>kubectl使用的密钥。</li>
</ul>
<p>将内容进行<code>base64 -d</code>和<code>openssl x509 -in xxx.crt -text -noout</code>即可查看证书内容。可以发现，默认情况下的证书和密钥是kubeadm生成的，有效期只有一年。后面对其进行自定义。</p>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>抓包研究下kubectl和apiserver的通信握手过程。apiserver监听端口为6443。((tcp[12] &amp; 0xf0) &gt;&gt; 2)表示TCP头的大小。TLS包的第一个字节定义内容类型，值22(十六进制中的0x16)被定义为“握手”内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -ni any &quot;tcp port 6443 and (tcp[((tcp[12] &amp; 0xf0) &gt;&gt; 2)] = 0x16)&quot; -w test.sap</span><br></pre></td></tr></table></figure></p>
<p>执行<code>kubectl get svc</code>，从而捕抓到kubectl和apiserver之间的握手包。<br>用wireshark查看test.sap。<br><img src="/2019/06/16/探讨下kubernetes的证书体系/4.PNG" title="kubectl和apiserver的握手包"><br>可以发现，kubectl首先向apiserver发送了client hello报文，apiserver响应hello报文之后，发送自己的证书，并发送客户端证书请求。kubectl收到证书请求后，发送自己的证书，并验证apiserver证书的有效性。<br>具体的证书内容可以通过wireshark查看。</p>
<p>apiserver使用了<code>--client-ca-file</code>字段指定了用于认证客户端证书的根证书。kubectl则是通过<code>--certificate-authority-data</code>验证apiserver的证书。简单修改下certificate-authority-data的内容，测试一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pods</span><br><span class="line">Unable to connect to the server: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure></p>
<p>查看抓包情况：<br><img src="/2019/06/16/探讨下kubernetes的证书体系/5.PNG" title="kubectl和apiserver的握手包/失败场景"><br>可以发现，apiserver的证书并没有通过kubectl的验证。</p>
<h3 id="自定义证书"><a href="#自定义证书" class="headerlink" title="自定义证书"></a>自定义证书</h3><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2019/06/12/借助git去除敏感信息助力代码开源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/借助git去除敏感信息助力代码开源/" itemprop="url">借助git去除敏感信息助力代码开源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T20:20:04+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fork私有项目"><a href="#fork私有项目" class="headerlink" title="fork私有项目"></a>fork私有项目</h1><h2 id="删除敏感配置"><a href="#删除敏感配置" class="headerlink" title="删除敏感配置"></a>删除敏感配置</h2><p>创建全新分支，不保留任何历史，但是包含当前分支所有文件<br>git checkout –orphan new</p>
<p>git add -A</p>
<p>删除不必要的文件：<br>git rm xxx -f</p>
<p>git commit -m “init”</p>
<p>git branch -a</p>
<p>git branch -D master</p>
<p>git branch -a</p>
<p>git branch -m master</p>
<p>git push -f origin master</p>
<h2 id="删除多余分支"><a href="#删除多余分支" class="headerlink" title="删除多余分支"></a>删除多余分支</h2><p>git branch -D -r origin/mr</p>
<p>git push origin :mr</p>
<p>至此，项目可以开源了</p>
<h1 id="私有项目更新合并"><a href="#私有项目更新合并" class="headerlink" title="私有项目更新合并"></a>私有项目更新合并</h1><h2 id="创建新mr分支"><a href="#创建新mr分支" class="headerlink" title="创建新mr分支"></a>创建新mr分支</h2><p>git branch -D -r origin/mr</p>
<p>git push origin :mr</p>
<p>git checkout –orphan mr</p>
<p>git add -A</p>
<p>删除不必要的文件：<br>git rm xxx -f</p>
<p>git commit -m “你的注释”</p>
<p>git push origin mr</p>
<h1 id="提交合并"><a href="#提交合并" class="headerlink" title="提交合并"></a>提交合并</h1><p>开源项目使用合并请求，合并私有项目mr分支</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2019/06/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T20:04:32+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2018/03/02/dm-writeboost读写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/dm-writeboost读写/" itemprop="url">dm-writeboost读写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T11:06:58+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ceph/" itemprop="url" rel="index">
                    <span itemprop="name">Ceph</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>近期抽空了解了一下ceph客户端缓存的问题，以期获取断电容灾的解决方案。ceph使用rbd的方式如下(参考<a href="http://www.zphj1987.com/2016/05/19/ceph%E7%9A%84jewel%E6%96%B0%E6%94%AF%E6%8C%81%E7%9A%84rbd-nbd/" target="_blank" rel="noopener">ceph的jewel新支持的rbd-nbd</a>)：<br><img src="/2018/03/02/dm-writeboost读写/1.png" title="ceph使用rbd的方式"><br>再结合ceph用户邮件相关讨论，如<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2016-March/008316.html" target="_blank" rel="noopener">Local ssd cache for ceph on each compute node</a>和<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2015-June/002546.html" target="_blank" rel="noopener">Ceph and EnhanceIO cache</a>，可知可以从三个维度了解：<br>1、krbd<br>2、librbd<br>3、缓存插件</p>
<p>krbd：<br>krbd的内核代码阅读入口为<a href="http://elixir.free-electrons.com/linux/v4.14.12/source/drivers/block/rbd.c" target="_blank" rel="noopener">以4.14.12版本为例</a>，ceph相关代码逻辑在<a href="https://elixir.bootlin.com/linux/v4.14.12/source/include/linux/ceph" target="_blank" rel="noopener">include/linux/ceph</a>，Sage Weil在内核中扩展的rbd模块是以驱动模式实现的，具体的I/O数据由内核负责，rbd模块获取读写请求之后再与ceph集群通信。krbd模块重点在于与集群通信功能，因此，想要在krbd维度上考虑缓存的问题，相当于要修改内核关于bio的实现，目前来说是不可能的。</p>
<p>librbd：<br>librbd+nbd的模式似乎可以替代krbd，同时librbd也是虚拟机在使用的，因此从librbd上考虑缓存实现方式比较实际。这里还有一篇推荐文章<a href="http://blog.csdn.net/lzw06061139/article/details/51203461" target="_blank" rel="noopener">Ceph 性能优化 之 带掉电保护的Rbd Cache</a>。这篇文章里的主要逻辑是用读写文件的方式来取代内存缓存，我对这篇文章的疑虑在以下地方：<br>1)、没有讲明断电重启后的数据恢复逻辑，因此也没有讲明应当保存数据结构中具体的哪些字段。<br>2)、没有结合ssd的特性来读写。<br>3)、文章通过默认设定I/O大小和周期性统计应用I/O平均大小来避免性能问题，这种做法是否可以规避掉。</p>
<p>缓存插件：<br>基于目前的了解，缓存插件应该是通过使用ssd缓存数据来加快块设备落盘的，也就是说，使用缓存插件的目的是“加速”而不是“断电保护”。其次，是否所有缓存插件都具备数据一致性检查，也是需要读取相关源码才能真切了解到。</p>
<p>推荐的块设备文章<a href="http://www.ningoo.net/html/2011/all_things_about_flashcache_1.html" target="_blank" rel="noopener">深入浅出Flashcache（一）</a>、<a href="http://www.ningoo.net/html/2011/all_things_about_flashcache_2.html" target="_blank" rel="noopener">深入浅出Flashcache（二）</a>、<a href="http://www.ningoo.net/html/2011/all_things_about_flashcache_3.html" target="_blank" rel="noopener">深入浅出Flashcache（三）</a>、<a href="http://blog.yufeng.info/archives/751" target="_blank" rel="noopener">blktrace 深度了解linux系统的IO运作</a>、<a href="http://blog.yufeng.info/archives/1786" target="_blank" rel="noopener">IO模式调查利器blkiomon介绍</a>、<a href="http://blog.yufeng.info/archives/1112" target="_blank" rel="noopener">Linux下Fio和Blktrace模拟块设备的访问模式</a></p>
<p>基于上述背景，我首先阅读了rbd-nbd的相关代码<a href="https://github.com/ceph/ceph/blob/v12.2.2/src/tools/rbd_nbd/rbd-nbd.cc" target="_blank" rel="noopener">rbd-nbd.cc</a>，找到librbd的读写入口，了解了ceph客户端缓存数据的代码逻辑。接着，我阅读了缓存插件dm-writeboost的相关代码<a href="https://github.com/akiradeveloper/dm-writeboost" target="_blank" rel="noopener">dm-writeboost</a>，以期了解以下问题：<br>1)、如何读写ssd<br>2)、如何控制IO<br>3)、如何将随机写转换为顺序写</p>
<h1 id="dm-writeboost"><a href="#dm-writeboost" class="headerlink" title="dm-writeboost"></a>dm-writeboost</h1><p>dm-writeboost采用驱动开发模式，通过定义IO处理规则来过滤IO请求。dm-writeboost使用了Device Mapper的相关知识，这有一篇推荐文章<a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html#resources" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a>。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>1、dm-writeboost.h中定义的Overall-Superblock-Segment即为落盘ssd的最终数据，segment_header、metablock等等是在内存中组织的逻辑数据，这些逻辑数据的索引信息将填充在segment_header_device中，而具体缓存在rambuffer中的数据则将写入到Segment的data中，最后落盘。其中，Segment中的segment_header_device (512B) + metablock_device * nr_caches_inseg占据4K大小，一个Segment为512K。<br>2、Segment数据代表了ssd的数据，下刷到ssd是以Segment为单位的，Segment会记录ssd的扇区位置。Segment中包含多个metablock，metablock记录了hdd的扇区位置。Segment的metablock是无序的、随机的。<br>3、读缓存单元数据缓存了hdd的数据，使用了红黑树组织，根据bio指向的hdd扇区位置寻位。读缓存单元存在的意义是将只存在hdd而未存在ssd的数据缓存到ssd，以便加速后续读写。<br>4、所有Segment的所有metablock都关联到哈希表中，哈希表的大小等于nr_caches等于metablock总数，哈希表存在的意义是组织存储在ssd上的数据，并使用了hdd的扇区数进行索引，根据hdd扇区数查找哈希表上的metablock，存在则代表数据存在于ssd上（或即将写入），由metablock又可以定位到对应的Segment。根据bio来寻位哈希表的规则是：bio扇区对应第几个4K/哈希表大小的余数，找到对应的head，并从head的list中根据扇区位置找到对应的metablock。<br>5、I/O大小为4K范围内，通过dm接口设定。<br>6、如何将随机写转变成顺序写？<br>在dm-writeboost里，I/O大小为4K，随机写单元为一个metablock。dm-writeboost采取的策略是将随机写包含在大块里，然后对大块进行顺序写。具体的实现是：dm-writeboost在内存中按顺序维护Segment数组，然后从其中获取下一个空闲Segment，将metablock包含在其中，当Segment满了以后，下刷到ssd中，然后获取下一个空闲的Segment。因此，需要一定的机制来检验Segment是否下刷成功以及有无I/O请求情况，dm-writeboost采用了计数加减来完成这个目标。<br>7、由内存写入ssd时，称为flush，写入时受到缓存区rambuf_pool控制，共8个rambuf，每一个对应缓存一个Segment的数据，因此分配新的rambuf时，需要先等待[当前id - 8]之前的rabbuf下刷到ssd。由ssd写入hdd时，称为writeback，写入时受到Segment数组控制，共nr_segments个。writeback批处理上限默认为32个Segment，受nr_max_batched_writeback参数控制，因此分配新Segment时，需要先等待[当前id - nr_segments]之前的段都writeback完；实际的writeback实现是将每个段的metablock作为一个io处理，若metablock数据不满4K，还将分成扇区处理。writeback写入磁盘的数据将使用红黑树进行组织。<br>8、断电重启由ssd恢复内存组织数据时最多只需要恢复nr_segments段，由最老的段开始恢复，在nr_segments个段范围内，最老的段为已记录max段的下一个（若该段没有数据，则表明之前数据未写满nr_segments个）。恢复过程中一旦出现检验码验证失败，直接丢弃后面数据。恢复过程中，若出现metablock已被hash表索引，则将数据写入到hdd（若新数据不满4k或旧数据不满4k，且旧数据为脏数据未下刷hdd，则需要合并，这种情况下prepare_overwrite的实现是先wait_for_flushing等待旧数据所在段被flush；容易得知，该段断电前一定是被成功下刷过此时我们才能成功读取，因此wait_for_flushing不会出现问题。况且此时还没启动flush进程呢）。<br>9、系统启动的后台进程有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writeback_daemon：用于将segment_header_array的数据下刷到hdd</span><br><span class="line">flush_daemon：用于将rambuf_pool的数据下刷到ssd</span><br><span class="line">writeback_modulator：用于监控io情况，设置allow_writeback</span><br><span class="line">sb_record_updater：用于更新超级块，记录last_writeback_segment_id</span><br><span class="line">data_synchronizer：用于定期唤醒flush进程，并等待当前段flush完成（可能是为了防止长时间未有io的情况）</span><br></pre></td></tr></table></figure></p>
<p>10、为了防止数据破坏，使用了两种锁metux和spin-lock。<br>其中，metux用于：唤醒flush进程和分配新段(flush_current_buffer)、读缓存单元写入到内存以下刷到ssd的过程(inject_read_cache)、重新设置读缓存单元(reinit_read_cache_cells)、写入数据(do_process_write)、读取数据时查找cache和读缓存单元(process_read)。spin-lock用于：读取和设置metablock的dirtiness信息。</p>
<h2 id="读请求"><a href="#读请求" class="headerlink" title="读请求"></a>读请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">根据扇区位置查找cache(即对应ssd的哈希表数据，但索引项是hdd的扇区数)</span><br><span class="line">判断是否保留读缓存单元(若原本无读缓存单元，则新增且状态为保留)</span><br><span class="line"></span><br><span class="line">无缓存cache</span><br><span class="line">    保留读缓存单元</span><br><span class="line">        读取hdd到bio中</span><br><span class="line">        状态改为PBD_WILL_CACHE</span><br><span class="line">        将bio数据复制到读缓存单元中</span><br><span class="line">        读缓存工作排队</span><br><span class="line">            超过阈值则取消连续读缓存单元</span><br><span class="line">            将读缓存单元注入为写请求，将所有读缓存单元的数据复制到当前缓存段中，下刷到ssd</span><br><span class="line">    不保留读缓存单元(已有读缓存单元/bio请求数据不满4k)</span><br><span class="line">        请求重映射到hdd(修改bio指向的设备和扇区)</span><br><span class="line"></span><br><span class="line">有缓存cache(数据在SSD中或当前内存缓存段中)</span><br><span class="line">    对应数据在内存中</span><br><span class="line">        根据bio指示的位置和扇区数读取hdd数据到buf中，将buf复制到bio中</span><br><span class="line">        若cache数据指明为脏数据(未下刷到hdd)，在内存中缓存段上获取对应数据，复写到bio中</span><br><span class="line">    对应数据不在内存中(在ssd中)</span><br><span class="line">        等待found_seg下刷到ssd，保证后续ssd数据读取正确</span><br><span class="line">        若cache metablock块数据不满4k(此时已下刷到ssd)</span><br><span class="line">            读取hdd到buf中，并复制到bio中</span><br><span class="line">            若cache数据指明为脏数据(未下刷到hdd)，按扇区读取ssd脏数据，复写到bio中</span><br><span class="line">        若cache metablock块数据满4k(此时已下刷到ssd)</span><br><span class="line">            状态改为PBD_READ_SEG</span><br><span class="line">            将读请求重新映射到ssd</span><br></pre></td></tr></table></figure>
<p>其中，判断是否保留读缓存单元的逻辑是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bio请求不满4k，返回不保留</span><br><span class="line">根据bio扇区在红黑树中查找读缓存单元，若找到，返回不保留</span><br><span class="line">读缓存单元游标减一，从读缓存单元数组中获取一个新单元</span><br><span class="line">设置新单元指向的扇区</span><br><span class="line">新单元加入到红黑树中</span><br><span class="line">bio状态改为PBD_WILL_CACHE</span><br><span class="line">根据需要取消新单元</span><br><span class="line">    若当前读取扇区为上次读取扇区last_sector的下一扇区，seqcount++</span><br><span class="line">    否则，seqcount=1</span><br><span class="line">    顺序读次数seqcount大于阈值</span><br><span class="line">        当前已经超过阈值</span><br><span class="line">            取消新单元</span><br><span class="line">        当前未超过阈值</span><br><span class="line">            设置当前已超过阈值</span><br><span class="line">            将当前读缓存单元游标之后的seqcount个单元取消</span><br><span class="line">    设置当前读取扇区last_sector</span><br></pre></td></tr></table></figure></p>
<h2 id="写请求"><a href="#写请求" class="headerlink" title="写请求"></a>写请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">初始化写I/O数据结构，将bio数据复制到写I/O</span><br><span class="line">根据扇区位置查找cache(即对应ssd的哈希表数据，但索引项是hdd的扇区数)</span><br><span class="line"></span><br><span class="line">有缓存cache(数据在SSD中或当前内存缓存段中)</span><br><span class="line">    对应数据在内存中</span><br><span class="line">        写入位置指向找到的metablock，跳到do_write</span><br><span class="line">    对应数据不在内存中</span><br><span class="line">        若bio所带数据不满4k或cache数据不满4k，且cache为脏数据</span><br><span class="line">            读ssd数据，合并到写I/O中</span><br><span class="line">        若cache数据不脏或bio所带数据满4k</span><br><span class="line">            忽略ssd数据</span><br><span class="line">        将找到的metablock标记为干净</span><br><span class="line">无缓存cache</span><br><span class="line">    取消读缓存单元</span><br><span class="line">若当前缓存段已满</span><br><span class="line">    下刷到ssd，获取新缓存段</span><br><span class="line">从当前缓存段中获取空metablock作为写入位置</span><br><span class="line"></span><br><span class="line">do_write:</span><br><span class="line">将写I/O数据复制到rambuffer中(rambuffer缓存了当前应下刷到ssd的段实际数据，是缓存池中的一个单元)</span><br><span class="line">将新的metablock标记为脏</span><br><span class="line">将新的metablock加入到哈希表中(所以哈希表找到记录时，数据可能正在内存中，也可能已经下刷到ssd中)</span><br><span class="line">(等待下次读写触发段刷新)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/09/20/docker-v0-1-0源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/docker-v0-1-0源码分析/" itemprop="url">docker-v0.1.0源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T21:02:43+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="sbin-init"><a href="#sbin-init" class="headerlink" title="/sbin/init"></a>/sbin/init</h1><p>检查docker可执行文件的绝对路径是否在/sbin/init目录下已经存在<br>如果在，则设置docker容器启动之前的环境：</p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><h2 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h2><p>根据参数中的网关IP添加网关路由</p>
<h2 id="设置uid-gid"><a href="#设置uid-gid" class="headerlink" title="设置uid/gid"></a>设置uid/gid</h2><p>根据参数中的username或者uid，调用系统调用设置uid和gid，切换用户</p>
<h2 id="exec执行docker程序"><a href="#exec执行docker程序" class="headerlink" title="exec执行docker程序"></a>exec执行docker程序</h2><p>如果不存在则根据参入的命令行参数选择启动docker deamon还是执行docker cli的命令调用</p>
<h1 id="d-daemon"><a href="#d-daemon" class="headerlink" title="-d daemon"></a>-d daemon</h1><p>主要是创建一个server对象， 然后通过这个server创建tcp服务端，创建server实质就是创建runtime对象，runtime对象中封装了所有docker daemon运行时所需要的所有的信息，在创建runtime时，首先会在 /var/lib/docker目录下创建对应的文件：containers，graph文件夹，然后创建对应的镜像tag存储对象，通过名为lxcbr0的卡的网络创建网络管理，最后创建dockerhub的认证对象AuthConfig。</p>
<h2 id="创建runtime"><a href="#创建runtime" class="headerlink" title="创建runtime"></a>创建runtime</h2><p>只支持amd64，在/var/lib/docker创建runtime</p>
<h3 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h3><p>创建目录，权限0700</p>
<h3 id="graph"><a href="#graph" class="headerlink" title="graph"></a>graph</h3><p>创建目录，权限0700</p>
<h3 id="repositories"><a href="#repositories" class="headerlink" title="repositories"></a>repositories</h3><p>创建或读入文件<br>关键数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type TagStore struct &#123;</span><br><span class="line">    path         string</span><br><span class="line">    graph        *Graph</span><br><span class="line">    Repositories map[string]Repository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Repository map[string]string</span><br></pre></td></tr></table></figure></p>
<p>如果存在/var/lib/docker/repositories文件(json格式)，则读入文件内容到TagStore中，否则将TagStore内容写入到/var/lib/docker/repositories文件，权限为0600。</p>
<h3 id="从lxcbr0网桥接口创建网络管理器"><a href="#从lxcbr0网桥接口创建网络管理器" class="headerlink" title="从lxcbr0网桥接口创建网络管理器"></a>从lxcbr0网桥接口创建网络管理器</h3><p>通过指定名为lxcbr0的网络接口来实现网络管理，一个网络管理的实例包括：网桥名字，ip网络，ip分配器，端口分配器，端口映射器。实例化一个网络管理时，要将这些属性全部赋值，ip分配器是一个ip地址的channel，里面的ip地址是通过lxcbr0接口的ip 和对应的网关mask计算得到的子网ip。端口分配器是一个存放了指定范围49153~65535个int的channel，端口映射器是设置和清除iptable的方法集合。</p>
<p>根据网络接口获取IPv4地址(net.IPNet)<br>根据IPv4地址创建IP分配器(利用了net.IPNet),通过网卡lxcbr0的第一个ip和网关mask得到这个网卡下的所有子网ip,并且封装成一个ip分配器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据IPv4计算网络地址范围(首IP-末IP)，取首IP</span><br><span class="line">根据掩码计算可用hosts个数</span><br><span class="line">阻塞写入所有可用IP到分配器IP队列(排除network IP、broadcast IP、gateway IP)</span><br></pre></td></tr></table></figure></p>
<p>创建port分配器，端口范围地址为[49153,65535]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阻塞写入所有port到分配器port队列</span><br></pre></td></tr></table></figure></p>
<p>创建PortMapper，端口映射器通过设置iptables规则来处理将外部端口映射到容器。它跟踪所有映射，并能够随意取消映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">删除docker规则链</span><br><span class="line">    清空nat表docker规则链的PREROUTING规则</span><br><span class="line">    清空nat表docker规则链的OUTPUT规则</span><br><span class="line">    清空nat表docker规则链</span><br><span class="line">    删除nat表docker规则链</span><br><span class="line">创建docker规则链</span><br><span class="line">    创建nat表docker规则链</span><br><span class="line">    创建nat表docker规则链的PREROUTING规则</span><br><span class="line">    创建nat表docker规则链的OUTPUT规则</span><br></pre></td></tr></table></figure></p>
<h3 id="读取认证文件"><a href="#读取认证文件" class="headerlink" title="读取认证文件"></a>读取认证文件</h3><p>仓库地址为 <a href="https://registry.docker.io" target="_blank" rel="noopener">https://registry.docker.io</a> ，文件路径为/var/lib/docker/.dockercfg，包括两个字段：auth = basic auth值、email = email值</p>
<h3 id="创建runtime数据结构"><a href="#创建runtime数据结构" class="headerlink" title="创建runtime数据结构"></a>创建runtime数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root:           /var/lib/docker</span><br><span class="line">repository:     /var/lib/docker/containers</span><br><span class="line">containers:     container/list(list.New())双向链表</span><br><span class="line">networkManager: NetworkManager结构</span><br><span class="line">graph:          Graph结构</span><br><span class="line">repositories:   TagStore结构</span><br><span class="line">authConfig:     AuthConfig结构</span><br></pre></td></tr></table></figure>
<h3 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h3><p>读取/var/lib/docker/containers目录，实际就是所有之前运行过的容器的目录，目录名为对应容器的id，对于每一个文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">每个文件夹都有一个config.json文件，将其读入到Container数据结构中，实例化一个container对象，包括容器id</span><br><span class="line">检查config.json的id和所加载的容器id是否一样，以此判断容器信息是否被更改过</span><br><span class="line">将加载的容器注册到runtime中的容器list链表中</span><br><span class="line">    检查runtime的容器链表是否已包含当前容器id，存在则提示错误</span><br><span class="line">    检查容器id是否为空 如果为空则说明容器是错误的，则退出返回错误</span><br><span class="line">    指定container的runtime为当前runtime</span><br><span class="line">    创建container的互斥锁和条件变量</span><br><span class="line">    创建container的stdout和stderr结构，均为container/list双向链表</span><br><span class="line">    创建container的stdin和stdinPipe结构，分别为io.ReadCloser和io.WriteCloser类型，对应为io.Pipe的管道文件描述符</span><br><span class="line">    在容器目录下创建stdout日志文件，权限为0600，格式为&quot;&#123;id&#125;-stdout.log&quot;，将其write接口添加到stdout双向链表中</span><br><span class="line">    在容器目录下创建stderr日志文件，权限为0600，格式为&quot;&#123;id&#125;-stderr.log&quot;，将其write接口添加到stderr双向链表中</span><br><span class="line">    将容器数据结构添加到runtime的容器链表的最后</span><br></pre></td></tr></table></figure></p>
<h2 id="创建tcp服务端"><a href="#创建tcp服务端" class="headerlink" title="创建tcp服务端"></a>创建tcp服务端</h2><p>在127.0.0.1:4242上启动tcp监听，接受tcp的请求，为每个请求开启一个单独的协程处理请求，如果有请求到来则进行处理。处理过程为：获取请求中的参数然后调用call，call根据参数是否有值来执行不同方法，如果没有参数，则执行runtime的help方法；如果有参数，进行参数的处理，处理逻辑：获取第二个参数，作为docker后的命令，然后获取命令之后的所有参数，整条命令进行日志打印输出，之后再通过cmd命令和反射技术找到对应的cmd所对应的方法，最后将参数传入方法，执行cmd对应的方法，结果返回connect中。<br>connect在此作为io.Writer类型参数，命令结果将写入到其中。</p>
<h2 id="关于lxcbr0"><a href="#关于lxcbr0" class="headerlink" title="关于lxcbr0"></a>关于lxcbr0</h2><p>安装lxc之后，就会有lxcbr0网络接口。<br>几个参考链接：<br><a href="https://github.com/lxc/lxc" target="_blank" rel="noopener">github lxc</a><br><a href="https://linuxcontainers.org/" target="_blank" rel="noopener">lxc官网</a><br><a href="http://www.cnblogs.com/cherishui/p/4147240.html" target="_blank" rel="noopener">LXC-Linux Containers介绍</a><br><a href="https://www.ibm.com/developerworks/cn/linux/1312_caojh_linuxlxc/index.html" target="_blank" rel="noopener">Linux 容器的建立和简单管理</a><br><a href="https://www.flockport.com/enable-lxc-networking-in-debian-jessie-fedora-and-others/" target="_blank" rel="noopener">Enable LXC neworking in Debian Jessie, Fedora 21 and others</a></p>
<h3 id="lxc安装"><a href="#lxc安装" class="headerlink" title="lxc安装"></a>lxc安装</h3><p>Centos7在Base repo上没有可用的lxc，因此需要先安装epel仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install lxc lxc-templates lxc-extras dnsmasq bridge-utils iptables-services</span><br></pre></td></tr></table></figure></p>
<p>利用brctl工具来创建网桥lxcbr0，利用dnsmasq工具提供dhcp服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/lxc-net.service</span><br></pre></td></tr></table></figure></p>
<p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Bridge interface for LXC Containers</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line"></span><br><span class="line"># Bring up bridge interface</span><br><span class="line">ExecStart=/sbin/brctl addbr lxcbr0</span><br><span class="line">ExecStart=/sbin/ip address add 10.0.3.1/24 dev lxcbr0</span><br><span class="line">ExecStart=/sbin/ip link set lxcbr0 up</span><br><span class="line"></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line"># Bring bridge interface down</span><br><span class="line">ExecStop=/sbin/ip link set lxcbr0 down</span><br><span class="line">ExecStop=/sbin/brctl delbr lxcbr0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/lxc-dhcp.service</span><br></pre></td></tr></table></figure>
<p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Requires=lxc-net.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/sbin/dnsmasq \</span><br><span class="line">            --dhcp-leasefile=/var/run/lxc-dnsmasq.leases \</span><br><span class="line">            --user=nobody \</span><br><span class="line">            --group=nobody \</span><br><span class="line">            --keep-in-foreground \</span><br><span class="line">            --listen-address=10.0.3.1 \</span><br><span class="line">            --except-interface=lo \</span><br><span class="line">            --bind-interfaces \</span><br><span class="line">            --dhcp-range=10.0.3.2,10.0.3.254</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable lxc-net.service</span><br><span class="line">systemctl enable lxc-dhcp.service</span><br><span class="line">systemctl start lxc-net.service</span><br><span class="line">systemctl start lxc-dhcp service</span><br></pre></td></tr></table></figure>
<p>查看是否存在逻辑(虚拟)网桥接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br></pre></td></tr></table></figure></p>
<p>如果已经存在可以用以下命令删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brctl delbr +网桥名</span><br></pre></td></tr></table></figure></p>
<h1 id="command"><a href="#command" class="headerlink" title="command"></a>command</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TODO...</span><br><span class="line"></span><br><span class="line">tcp call</span><br><span class="line">conn</span><br><span class="line">stdout</span><br><span class="line">stdin</span><br><span class="line"></span><br><span class="line">local call</span><br><span class="line">new docker server</span><br><span class="line">解析参数</span><br><span class="line">方法名命名格式</span><br><span class="line">通过反射查找方法</span><br><span class="line">调用方法</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/27/github-page博客-hexo-next主题-gitment评论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/github-page博客-hexo-next主题-gitment评论/" itemprop="url">github page博客+hexo next主题+gitment评论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T17:33:32+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="github-page安装"><a href="#github-page安装" class="headerlink" title="github page安装"></a>github page安装</h1><p>github创建仓库，git项目格式<br><a href="https://github.com/jianzzz/jianzzz.github.com.git" target="_blank" rel="noopener">https://github.com/jianzzz/jianzzz.github.com.git</a></p>
<p>安装hexo（内网有自行开发的npm工具的话则使用这些npm工具）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir your_blog_dir</span><br><span class="line">cd your_blog_dir</span><br><span class="line">hexo init</span><br><span class="line">(内网环境到npm install时网络出错的话，改用这些npm工具)</span><br><span class="line">(your-npm install)</span><br></pre></td></tr></table></figure></p>
<p>修改_config.yml</p>
<ul>
<li><p>网站设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 蓝色步行者</span><br><span class="line">subtitle: 每个人都有自己的梦想</span><br><span class="line">description: 如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</span><br><span class="line">author: zoro</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本库设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jianzzz/jianzzz.github.com.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>本地发布<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>内网环境git添加代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://your-proxy-domain:port</span><br><span class="line">git config --global https.proxy http://your-proxy-domain:port</span><br></pre></td></tr></table></figure></p>
<p>下载部署器，部署到网上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>访问<br>jianzzz.github.io</p>
<h1 id="hexo-next主题"><a href="#hexo-next主题" class="headerlink" title="hexo next主题"></a>hexo next主题</h1><p>更换主题<br>参考 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a> ，<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders.html</a><br>theme: hexo-theme-next-5.1.2<br>主题配置文件：next-5.1.2/_config.yml<br>站点配置文件：_config.yml</p>
<h1 id="hexo-next配置分离"><a href="#hexo-next配置分离" class="headerlink" title="hexo next配置分离"></a>hexo next配置分离</h1><p>参考<a href="https://github.com/iissnan/hexo-theme-next/issues/328" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/328</a><br>建立source/_data/next.yml，将主题配置文件所有修改都填写到source/_data/next.yml<br>缺陷：在主题的 _config.yml 里面打开的选项，无法在 source/_data/next.yml 中关闭。每次修改 _next.yml 需要重启 hexo server 才能生效。</p>
<h1 id="gitment评论"><a href="#gitment评论" class="headerlink" title="gitment评论"></a>gitment评论</h1><h2 id="获得github的授权"><a href="#获得github的授权" class="headerlink" title="获得github的授权"></a>获得github的授权</h2><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth application注册接入</a><br><img src="/2017/08/27/github-page博客-hexo-next主题-gitment评论/1.PNG" title="OAuth application"><br>上图中圈画出来的是回调地址，填写博客的域名。</p>
<h2 id="next主题下添加Gitment"><a href="#next主题下添加Gitment" class="headerlink" title="next主题下添加Gitment"></a>next主题下添加Gitment</h2><ul>
<li><p>github创建评论用的仓库<br><a href="https://github.com/jianzzz/blog-comment" target="_blank" rel="noopener">https://github.com/jianzzz/blog-comment</a></p>
</li>
<li><p>主题配置文件themes/next/_config.yml或source/_data/next.yml添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: jianzzz</span><br><span class="line">  repo: blog-comment</span><br><span class="line">  client_id: xxx</span><br><span class="line">  client_secret: xxxxxx</span><br><span class="line">  browser_js_path: /js/gitment.browser.js</span><br><span class="line">  lazy: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>browser_js_path字段后面讲<br>lazy为true，文章底部评论是收起状态</p>
<ul>
<li><p>懒加载按钮显示的文字设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主题languages/en.yml添加</span><br><span class="line">gitmentbutton: Show comments from Gitment</span><br><span class="line">主题languages/zh-Hans.yml添加</span><br><span class="line">gitmentbutton: 显示 Gitment 评论</span><br><span class="line">主题languages/zh-hk.yml添加</span><br><span class="line">gitmentbutton: 顯示 Gitment 評論</span><br><span class="line">主题languages/zh-tw.yml添加</span><br><span class="line">gitmentbutton: 顯示 Gitment 評論</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒加载按钮div及事件配置<br>主题layout/_partials/comments.swig文件添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">  &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">    &lt;div onclick=&quot;ShowGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面评论框生成代码配置<br>主题layout/_third-party/comments/目录添加文件gitment.swig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">  &#123;% set owner = theme.gitment.github_id %&#125;</span><br><span class="line">  &#123;% set repo = theme.gitment.repo %&#125;</span><br><span class="line">  &#123;% set cid = theme.gitment.client_id %&#125;</span><br><span class="line">  &#123;% set cs = theme.gitment.client_secret %&#125;</span><br><span class="line">  &#123;% set browserJsPath = theme.gitment.browser_js_path %&#125;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;&#123;&#123;browserJsPath&#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      var gitment = new Gitment(&#123;</span><br><span class="line">        id: document.location.href,</span><br><span class="line">        owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</span><br><span class="line">        repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</span><br><span class="line">        oauth: &#123;</span><br><span class="line">          client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</span><br><span class="line">          client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">      gitment.render(&apos;gitment-container&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      function ShowGitment()&#123;</span><br><span class="line">        document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;;</span><br><span class="line">        document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;;</span><br><span class="line">        var gitment = new Gitment(&#123;</span><br><span class="line">          id: document.location.href,</span><br><span class="line">          owner: &apos;&#123;&#123;owner&#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123;repo&#125;&#125;&apos;,</span><br><span class="line">          oauth: &#123;</span><br><span class="line">            client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;,</span><br><span class="line">            client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;,</span><br><span class="line">          &#125;&#125;);</span><br><span class="line">        gitment.render(&apos;gitment-container&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意最上面的变量读取需要和配置文件定义的gitment变量名保持一致。</p>
<ul>
<li><p>引入gitment.swig<br>主题layout/_third-party/comments/index.swig文件引入gitment.swig文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;gitment.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置CSS样式<br>主题source/css/_common/components/third-party/目录添加gitment.styl文件，设置button的样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#gitment-display-button&#123;</span><br><span class="line">     display: inline-block;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     color: #0a9caf;</span><br><span class="line">     cursor: pointer;</span><br><span class="line">     font-size: 14px;</span><br><span class="line">     border: 1px solid #0a9caf;</span><br><span class="line">     border-radius: 4px;</span><br><span class="line"> &#125;</span><br><span class="line"> #gitment-display-button:hover&#123;</span><br><span class="line">     color: #fff;</span><br><span class="line">     background: #0a9caf;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入css样式<br>主题source/css/_common/components/third-party/third-party.styl文件引入CSS样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ul>
<li>配置文件_config.yml或next.yml格式错误，上述所添加文件的一些缩进问题</li>
<li><p>API rate limit exceeded for xxxxxx ……<br>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>评论时多次login后会重复出现Initialize Comments<br>参考<a href="https://github.com/imsun/gitment/issues/12" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/12</a></p>
</li>
</ul>
<p>原因：<br>首先，页面会根据issue label值去获取issue，如果为空则会出现Initialize Comments。点击Initialize Comments时会创建一个issue，并且将issue label设为gitment和文章地址。反复login后，文章地址可能会携带上code查询字段，其值也不唯一。因此导致获取issue时指定的label值并不一定存在，最终导致重复出现Initialize Comments，issue也因此混乱。</p>
<p>解决方法：<br>参考上面所添加的主题layout/_third-party/comments/gitment.swig文件，可知评论所依赖的js文件是<a href="https://imsun.github.io/gitment/dist/gitment.browser.js" target="_blank" rel="noopener">https://imsun.github.io/gitment/dist/gitment.browser.js</a> ，我们需要修改issue创建和获取这两个过程的label值，将其修改为<code>window.document.title</code>即可；然后将主题layout/_third-party/comments/gitment.swig文件中对gitment.browser.js的引用改为本地引用<code>/js/gitment.browser.js</code>，配置到next.yml的<code>browser_js_path</code>字段中，并将gitment.browser.js文件放置于根目录<code>public/js</code>下。<br><img src="/2017/08/27/github-page博客-hexo-next主题-gitment评论/2.PNG" title="issue创建"><br><img src="/2017/08/27/github-page博客-hexo-next主题-gitment评论/3.PNG" title="issue获取"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/聊聊Harbor请求registry组件API的处理过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/聊聊Harbor请求registry组件API的处理过程/" itemprop="url">聊聊Harbor请求registry组件API的处理过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:48:10+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Harbor是什么"><a href="#Harbor是什么" class="headerlink" title="Harbor是什么"></a>Harbor是什么</h1><p>Harbor是由VMware中国研发团队负责开发的开源企业级Registry，可帮助用户迅速搭建企业级的Registry服务。Harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。一些关于Harbor的介绍：<br><a href="http://dockone.io/article/1640" target="_blank" rel="noopener">用Harbor实现容器镜像仓库的管理和运维</a><br><a href="https://t.goodrain.com/t/harbor-registry/142" target="_blank" rel="noopener">Harbor：开源企业级容器Registry架构简介</a><br><a href="http://dockone.io/article/1236" target="_blank" rel="noopener">用Swagger调用Harbor Registry的REST API</a><br><a href="http://tonybai.com/2017/06/09/setup-a-high-availability-private-registry-based-on-harbor-and-cephfs/" target="_blank" rel="noopener">基于Harbor和CephFS搭建高可用Private Registry</a><br><a href="http://tonybai.com/2017/06/15/fix-auth-fail-when-login-harbor-registry/" target="_blank" rel="noopener">解决登录Harbor Registry时鉴权失败的问题</a><br>Harbor和reigstry组件之间的验证采用了docker registry v2的token方式，token的service服务集成在Harbor中。相关token验证出现于docker login、请求registry api等情况下。以下的讨论中，我们主要是通过请求Harbor API，触发Harbor请求registry API，以此来研究Harbor请求registry组件API的处理过程。因此，我们需要先解决调用Harbor API的身份验证问题，再进一步研究token验证原理。<br>注意：<strong>以下的讨论均以Harbor tags v1.1.2为准，查看源代码的时候请注意切换tags</strong>。</p>
<h1 id="调用Harbor-API的身份验证"><a href="#调用Harbor-API的身份验证" class="headerlink" title="调用Harbor API的身份验证"></a>调用Harbor API的身份验证</h1><p>Harbor的API可以使用Swagger查看，具体请查看Harbor的github文档。当我们调用Harbor的API时，Harbor会从request中获取用户信息。以下以<code>https://your-harbor-domain/api/repositories/repo_name/tags</code>为例进行说明，该API是获取名为<code>repo_name</code>的镜像的所有tag。镜像的tag信息是没有存放在数据库中的，我们向Harbor服务发起该请求，Harbor需要向registry组件发送API请求。<br>该API会被<code>src/ui/api/repository.go</code>的<code>GetTags()</code>函数所处理，当名为<code>repo_name</code>的镜像所属的项目为私有项目时，会检查用户的身份：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if project.Public == 0 &#123;</span><br><span class="line">	userID := ra.ValidateUser()</span><br><span class="line">	if !checkProjectPermission(userID, project.ProjectID) &#123;</span><br><span class="line">		ra.CustomAbort(http.StatusForbidden, &quot;&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ValidateUser()</code>函数定义于<code>src/common/api/base.go</code>，其调用<code>GetUserIDForRequest()</code>函数，最终从request中读取basic auth信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (b *BaseAPI) GetUserIDForRequest() (int, bool, bool) &#123;</span><br><span class="line">	username, password, ok := b.Ctx.Request.BasicAuth()</span><br></pre></td></tr></table></figure></p>
<p>查看go源码，<code>go/src/net/http/request.go</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (r *Request) BasicAuth() (username, password string, ok bool) &#123;</span><br><span class="line">	auth := r.Header.Get(&quot;Authorization&quot;)</span><br><span class="line">	if auth == &quot;&quot; &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	return parseBasicAuth(auth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，可以得知Harbor支持http的basic auth方式。要在发送请求的时候添加HTTP Basic Authentication认证信息到请求中，有两种方法：<br>一是在请求头中添加Authorization：<br><code>Authorization: &quot;Basic 用户名和密码的base64加密字符串&quot;</code><br>二是在url中添加用户名和密码：<br><code>http://userName:password@your-api-url</code><br>从上面的代码片段可以看到，第二种方式并不适用Harbor，这也是postman使用第二种方式访问API不成功的原因。</p>
<h1 id="token验证原理"><a href="#token验证原理" class="headerlink" title="token验证原理"></a>token验证原理</h1><p>为了更好地研究Harbor在token验证做了哪些工作，我们先看一下docker login的过程，以下内容参考自<a href="http://www.skycloudsoftware.com/index.php/2016/06/13/docker-registry-v2-token.html" target="_blank" rel="noopener">从源码看Docker Registry v2中的Token认证实现机制</a></p>
<h2 id="docker-login的过程"><a href="#docker-login的过程" class="headerlink" title="docker login的过程"></a>docker login的过程</h2><img src="/2017/08/26/聊聊Harbor请求registry组件API的处理过程/1.png" title="docker login的过程">
<p>1、docker client接受用户的输入命令，将命令转化为调用engine-api的RegistryLogin方法；<br>2、在api的RegistryLogin方法中通过http调用registry中的auth方法；<br>3、在auth方法中由于是v2版本的，所以会调用loginV2方法；<br>4、在loginV2方法中会进行调用/v2/接口，该接口会对请求进行认证。此时的请求中并没有包含token信息，认证失败，会返回401错误，同时会在header中返回去哪里认证的服务器的地址；<br>5、registry client收到该返回结果后，便会去返回的认证服务器那里进去认证，向认证服务器发送的request的header中包含有加密的用户名和密码；<br>6、认证服务器从header中获取到加密的用户名和密码，这个时候就可以结合实际的认证系统进行认证；<br>7、认证成功后，需要生成一个token，并返回；<br>8、registry client会拿着返回的token再次尝试向registry server发生请求，这次由于带有token，请求验证成功，返回状态码为200；<br>9、docker client端接受到返回的状态码为200，说明操作成功，控制台会出现“Login Succeeded”。</p>
<p>Harbor所使用的是原生的docker registry v2，当我们通过Harbor的api来间接访问registry v2 API时，需要先通过Harbor的basic auth验证，之后Harbor会构造一个新请求来访问registry v2 API。Harbor构造新请求访问registry v2 API过程中涉及到的验证类似于docker login，但又有所不同，下面我们将通过追踪源码实现来阐述这一过程。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>url：<code>https://your-harbor-domain/api/repositories/repo_name/tags</code><br>说明：获取名为repo_name的镜像的所有tag。镜像的tag信息是没有存放在数据库中的，我们向Harbor服务发起该请求，Harbor需要向registry组件发送API请求：<code>your-registry-host:port/v2/library/alpine/tags/list</code>。</p>
<h2 id="Harbor实现概述"><a href="#Harbor实现概述" class="headerlink" title="Harbor实现概述"></a>Harbor实现概述</h2><p>Harbor的实现流程大概是：向registry组件发送<code>your-registry-host:port/v2/</code>请求，registry组件配置了token验证，因此会返回401错误，并将token service相关信息附带在header中返回。Harbor解析出token service相关信息之后，将其与token验证的相关Authorizer数据结构一起封装到AuthorizerStore中，AuthorizerStore会被封装到Transport中，Transport最终作为http.Client的transport成员实例。transport是golang http请求的承载者，可参考<a href="https://segmentfault.com/a/1190000003735562" target="_blank" rel="noopener">Go 标准库剖析 1（transport http 请求的承载者）</a>。自定义实现的transport需要实现RoundTrip方法，Harbor封装的Transport实现了该接口，因此向registry组件发送http请求时，会调用到自定义的RoundTrip方法，进而先调用Authorizer来生成满足条件的token，追加到request header中，然后才是真正地向registry组件发送请求。<br>接下来我们将分为几部分进行讲述：Harbor对数据结构的封装、Harbor向registry发送ping请求、Harbor生成token。</p>
<h2 id="Harbor对数据结构的封装"><a href="#Harbor对数据结构的封装" class="headerlink" title="Harbor对数据结构的封装"></a>Harbor对数据结构的封装</h2><p>以下是请求<code>https://your-harbor-domain/api/repositories/repo_name/tags</code>的函数调用过程：<br>先创建repository client，然后通过repository client访问registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//src/ui/api/repository.go</span><br><span class="line">func (ra *RepositoryAPI) GetTags() &#123;</span><br><span class="line">        client, err := ra.initRepositoryClient(repoName)</span><br><span class="line">        tags, err := listTag(client)</span><br><span class="line"></span><br><span class="line">//src/ui/api/repository.go</span><br><span class="line">func (ra *RepositoryAPI) initRepositoryClient(repoName string) (r *registry.Repository, err error) &#123;</span><br><span class="line">        username, password, ok := ra.Ctx.Request.BasicAuth()</span><br><span class="line">        if ok &#123;</span><br><span class="line">                return newRepositoryClient(endpoint, !verify, username, password,</span><br><span class="line">                        repoName, &quot;repository&quot;, repoName, &quot;pull&quot;, &quot;push&quot;, &quot;*&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//src/ui/api/repository.go</span><br><span class="line">func listTag(client *registry.Repository) ([]string, error) &#123;</span><br><span class="line">        ts, err := client.ListTag()</span><br></pre></td></tr></table></figure></p>
<p>创建repository client的过程包括创建TokenAuthorizer、AuthorizerStore、RepositoryClient：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//src/ui/api/repository.go</span><br><span class="line">func newRepositoryClient(endpoint string, insecure bool, username, password, repository, scopeType, scopeName string, scopeActions ...string) (*registry.Repository, error) &#123;</span><br><span class="line">        credential := auth.NewBasicAuthCredential(username, password)</span><br><span class="line">        authorizer := auth.NewStandardTokenAuthorizer(credential, insecure, config.InternalTokenServiceEndpoint(), scopeType, scopeName, scopeActions...)</span><br><span class="line">        store, err := auth.NewAuthorizerStore(endpoint, insecure, authorizer)</span><br><span class="line">        client, err := registry.NewRepositoryWithModifiers(repository, endpoint, insecure, store)</span><br></pre></td></tr></table></figure></p>
<p>创建的TokenAuthorizer数据结构包括：标准go http transport、basic auth数据结构、token service服务url、scope、token生成包装函数。其中，scope是生成token所需要的数据结构之一，scope的type为”repository”，name为url的镜像名，actions为pull/push/*。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/tokenauthorizer.go</span><br><span class="line">func NewStandardTokenAuthorizer(credential Credential, insecure bool, tokenServiceEndpoint string, scopeType, scopeName string, scopeActions ...string) Authorizer &#123;</span><br><span class="line">	authorizer := &amp;standardTokenAuthorizer&#123;</span><br><span class="line">		client: &amp;http.Client&#123;</span><br><span class="line">			Transport: registry.GetHTTPTransport(insecure),</span><br><span class="line">			Timeout:   30 * time.Second,</span><br><span class="line">		&#125;,</span><br><span class="line">		credential:           credential,</span><br><span class="line">		tokenServiceEndpoint: tokenServiceEndpoint,</span><br><span class="line">	&#125;</span><br><span class="line">	authorizer.scope = &amp;scope&#123;</span><br><span class="line">		Type:    scopeType,</span><br><span class="line">		Name:    scopeName,</span><br><span class="line">		Actions: scopeActions,</span><br><span class="line">	&#125;</span><br><span class="line">	authorizer.tg = authorizer.generateToken</span><br></pre></td></tr></table></figure></p>
<p>TokenAuthorizer将被封装到AuthorizerStore中，此外，AuthorizerStore数据结构还包括：ping registry组件的url结构（由<code>your-registry-host:port/v2/</code>构建）、ping<code>your-registry-host:port/v2/</code>之后解析出来的challenges参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/authorizer.go</span><br><span class="line">func NewAuthorizerStore(endpoint string, insecure bool, authorizers ...Authorizer) (*AuthorizerStore, error) &#123;</span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Transport: registry.GetHTTPTransport(insecure),</span><br><span class="line">		Timeout:   30 * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pingURL := buildPingURL(endpoint)</span><br><span class="line">	resp, err := client.Get(pingURL)</span><br><span class="line"></span><br><span class="line">	challenges := ParseChallengeFromResponse(resp)</span><br><span class="line">	ping, err := url.Parse(pingURL)</span><br><span class="line">	return &amp;AuthorizerStore&#123;</span><br><span class="line">		authorizers: authorizers,</span><br><span class="line">		ping:        ping,</span><br><span class="line">		challenges:  challenges,</span><br><span class="line">	&#125;, nil</span><br></pre></td></tr></table></figure></p>
<p>AuthorizerStore将被封装到自定义的transport中，该transport实现了标准go http transport定义的接口，并将作为http.Client的transport成员实例。http.Client又被封装到Repository数据结构中，Repository实例被当成RepositoryClient返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/repository.go</span><br><span class="line">func NewRepositoryWithModifiers(name, endpoint string, insecure bool, modifiers ...Modifier) (*Repository, error) &#123;</span><br><span class="line">	transport := NewTransport(GetHTTPTransport(insecure), modifiers...)</span><br><span class="line">	return NewRepository(name, endpoint, &amp;http.Client&#123;</span><br><span class="line">		Transport: transport,</span><br><span class="line">		//  for transferring large image, OS will handle i/o timeout</span><br><span class="line">		//	Timeout:   30 * time.Second,</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure></p>
<p>以上就是Harbor封装数据结构以实现访问registry前先构造token的过程，当调用client.ListTag()时，将会调用到自定义的transport，从而调用TokenAuthorizer的相关方法。</p>
<h2 id="Harbor向registry发送ping请求"><a href="#Harbor向registry发送ping请求" class="headerlink" title="Harbor向registry发送ping请求"></a>Harbor向registry发送ping请求</h2><p>上述NewAuthorizerStore函数的过程会向registry组件发送<code>your-registry-host:port/v2/</code>请求，该接口会对请求进行认证，此时的请求中并没有包含token信息，认证失败，会返回401错误。<br>NewAuthorizerStore函数调用ParseChallengeFromResponse函数对response header进行解析，其中，challenge是docker registry v2定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/challenge.go</span><br><span class="line">func ParseChallengeFromResponse(resp *http.Response) []challenge.Challenge &#123;</span><br><span class="line">	challenges := challenge.ResponseChallenges(resp)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//https://github.com/docker/distribution/blob/master/registry/client/auth/challenge/authchallenge.go</span><br><span class="line">func ResponseChallenges(resp *http.Response) []Challenge &#123;</span><br><span class="line">	if resp.StatusCode == http.StatusUnauthorized &#123;</span><br><span class="line">		// Parse the WWW-Authenticate Header and store the challenges</span><br><span class="line">		// on this endpoint object.</span><br><span class="line">		return parseAuthHeader(resp.Header)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">func parseAuthHeader(header http.Header) []Challenge &#123;</span><br><span class="line">	challenges := []Challenge&#123;&#125;</span><br><span class="line">	for _, h := range header[http.CanonicalHeaderKey(&quot;WWW-Authenticate&quot;)] &#123;</span><br><span class="line">		v, p := parseValueAndParams(h)</span><br><span class="line">		if v != &quot;&quot; &#123;</span><br><span class="line">			challenges = append(challenges, Challenge&#123;Scheme: v, Parameters: p&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return challenges</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用postman请求<code>your-registry-host:port/v2/</code>，查看response header：<br><img src="/2017/08/26/聊聊Harbor请求registry组件API的处理过程/2.PNG" title="response header"><br>可知，registry会告知客户端token service的url地址，以及对应的service名。</p>
<h2 id="Harbor生成token"><a href="#Harbor生成token" class="headerlink" title="Harbor生成token"></a>Harbor生成token</h2><p>Harbor通过封装数据结构，自定义transport，实现了在请求registry API前构造token的过程。下面将详细阐述其实现过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (r *Repository) ListTag() ([]string, error) &#123;</span><br><span class="line">	req, err := http.NewRequest(&quot;GET&quot;, buildTagListURL(r.Endpoint.String(), r.Name), nil)</span><br><span class="line">	resp, err := r.client.Do(req)</span><br></pre></td></tr></table></figure></p>
<p>client就是http.Client实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//https://github.com/golang/go/blob/release-branch.go1.7/src/net/http/client.go</span><br><span class="line">func (c *Client) Do(req *Request) (*Response, error) &#123;</span><br><span class="line">	method := valueOrDefault(req.Method, &quot;GET&quot;)</span><br><span class="line">	if method == &quot;GET&quot; || method == &quot;HEAD&quot; &#123;</span><br><span class="line">		return c.doFollowingRedirects(req, shouldRedirectGet)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">func (c *Client) doFollowingRedirects(req *Request, shouldRedirect func(int) bool) (*Response, error) &#123;</span><br><span class="line">	if resp, err = c.send(req, deadline); err != nil &#123;</span><br><span class="line"></span><br><span class="line">func (c *Client) send(req *Request, deadline time.Time) (*Response, error) &#123;</span><br><span class="line">	resp, err := send(req, c.transport(), deadline)</span><br><span class="line"></span><br><span class="line">func send(ireq *Request, rt RoundTripper, deadline time.Time) (*Response, error) &#123;</span><br><span class="line">	resp, err := rt.RoundTrip(req)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，http.Client.transport()方法获取的实例是RoundTripper接口类型，该接口定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//https://github.com/golang/go/blob/release-branch.go1.7/src/net/http/client.go</span><br><span class="line">type RoundTripper interface &#123;</span><br><span class="line">	RoundTrip(*Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Harbor自定义的transport正因为实现了该接口，所以在执行上述Do方法时可以执行自定义的RoundTrip函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/transport.go</span><br><span class="line">func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) &#123;</span><br><span class="line">	for _, modifier := range t.modifiers &#123;</span><br><span class="line">		if err := modifier.Modify(req); err != nil &#123;</span><br><span class="line">			return nil, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	resp, err := t.transport.RoundTrip(req)</span><br></pre></td></tr></table></figure></p>
<p>modifier即上面提到的AuthorizerStore，Harbor调用了Modify方法之后才会调用标准go http transport的RoundTrip方法来发送请求。我们看一下Modify方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/authorizer.go</span><br><span class="line">func (a *AuthorizerStore) Modify(req *http.Request) error &#123;</span><br><span class="line">	//only handle the requests sent to registry</span><br><span class="line">	v2Index := strings.Index(req.URL.Path, &quot;/v2/&quot;)</span><br><span class="line">	if v2Index == -1 &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for _, challenge := range a.challenges &#123;</span><br><span class="line">		for _, authorizer := range a.authorizers &#123;</span><br><span class="line">			if authorizer.Scheme() == challenge.Scheme &#123;</span><br><span class="line">				if err := authorizer.Authorize(req, challenge.Parameters); err != nil &#123;</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，封装到AuthorizerStore的TokenAuthorizer将被调用，我们看一下Authorize方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/tokenauthorizer.go</span><br><span class="line">func (t *tokenAuthorizer) Authorize(req *http.Request, params map[string]string) error &#123;</span><br><span class="line">	var scopes []*scope</span><br><span class="line">	var token string</span><br><span class="line"></span><br><span class="line">	if t.scope != nil &#123;</span><br><span class="line">		scopes = append(scopes, t.scope)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scopeStrs := []string&#123;&#125;</span><br><span class="line">	for _, scope := range scopes &#123;</span><br><span class="line">		scopeStrs = append(scopeStrs, scope.string())</span><br><span class="line">	&#125;</span><br><span class="line">	to, expiresIn, _, err := t.tg(params[&quot;realm&quot;], params[&quot;service&quot;], scopeStrs)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	token = to</span><br><span class="line"></span><br><span class="line">	req.Header.Add(http.CanonicalHeaderKey(&quot;Authorization&quot;), fmt.Sprintf(&quot;Bearer %s&quot;, token))</span><br></pre></td></tr></table></figure></p>
<p>Authorize方法所做的工作就是处理一下scope，然后调用tg函数（其实是个函数指针）生成token，并将生成的token写入到request header中。还记得上面提到的scope吗，它将被转换为字符串后作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/tokenauthorizer.go</span><br><span class="line">func (s *scope) string() string &#123;</span><br><span class="line">	return fmt.Sprintf(&quot;%s:%s:%s&quot;, s.Type, s.Name, strings.Join(s.Actions, &quot;,&quot;))</span><br></pre></td></tr></table></figure></p>
<p>上面的方法中，tg是一个函数指针，其指向在封装TokenAuthorizer的时候就被指定了，指向了tokenAuthorizer.generateToken函数，很明显，该函数就是token生成的具体实现，我们查看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//src/common/utils/registry/auth/tokenauthorizer.go</span><br><span class="line">func (u *usernameTokenAuthorizer) generateToken(realm, service string, scopes []string) (token string, expiresIn int, issuedAt *time.Time, err error) &#123;</span><br><span class="line">	token, expiresIn, issuedAt, err = token_util.RegistryTokenForUI(u.username, service, scopes)</span><br><span class="line"></span><br><span class="line">//src/ui/service/token/authutils.go</span><br><span class="line">func RegistryTokenForUI(username string, service string, scopes []string) (string, int, *time.Time, error) &#123;</span><br><span class="line">	return genTokenForUI(username, service, scopes, registryFilterMap)</span><br><span class="line"></span><br><span class="line">//src/ui/service/token/authutils.go</span><br><span class="line">func genTokenForUI(username string, service string, scopes []string, filters map[string]accessFilter) (string, int, *time.Time, error) &#123;</span><br><span class="line">	isAdmin, err := dao.IsAdminRole(username)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, 0, nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	access := GetResourceActions(scopes)</span><br><span class="line">	err = filterAccess(access, u, filters)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return &quot;&quot;, 0, nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return MakeRawToken(username, service, access)</span><br><span class="line"></span><br><span class="line">//src/ui/service/token/authutils.go</span><br><span class="line">func MakeRawToken(username, service string, access []*token.ResourceActions) (token string, expiresIn int, issuedAt *time.Time, err error) &#123;</span><br><span class="line">	pk, err := libtrust.LoadKeyFile(privateKey)</span><br><span class="line">	expiration, err := config.TokenExpiration()</span><br><span class="line">	tk, expiresIn, issuedAt, err := makeTokenCore(issuer, username, service, expiration, access, pk)</span><br><span class="line">	rs := fmt.Sprintf(&quot;%s.%s&quot;, tk.Raw, base64UrlEncode(tk.Signature))</span><br><span class="line">	return rs, expiresIn, issuedAt, nil</span><br></pre></td></tr></table></figure></p>
<p>上述genTokenForUI会对用户身份进行检查，只有是管理员角色才能生成token，此外还有其他的请求过滤检查，这里没有贴出代码。makeTokenCore函数是生成token的关键函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//src/ui/service/token/authutils.go</span><br><span class="line">func makeTokenCore(issuer, subject, audience string, expiration int,</span><br><span class="line">	access []*token.ResourceActions, signingKey libtrust.PrivateKey) (t *token.Token, expiresIn int, issuedAt *time.Time, err error) &#123;</span><br><span class="line"></span><br><span class="line">	joseHeader := &amp;token.Header&#123;</span><br><span class="line">		Type:       &quot;JWT&quot;,</span><br><span class="line">		SigningAlg: &quot;RS256&quot;,</span><br><span class="line">		KeyID:      signingKey.KeyID(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jwtID, err := randString(16)</span><br><span class="line"></span><br><span class="line">	now := time.Now().UTC()</span><br><span class="line">	issuedAt = &amp;now</span><br><span class="line">	expiresIn = expiration * 60</span><br><span class="line"></span><br><span class="line">	claimSet := &amp;token.ClaimSet&#123;</span><br><span class="line">		Issuer:     issuer,</span><br><span class="line">		Subject:    subject,</span><br><span class="line">		Audience:   audience,</span><br><span class="line">		Expiration: now.Add(time.Duration(expiration) * time.Minute).Unix(),</span><br><span class="line">		NotBefore:  now.Unix(),</span><br><span class="line">		IssuedAt:   now.Unix(),</span><br><span class="line">		JWTID:      jwtID,</span><br><span class="line">		Access:     access,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var joseHeaderBytes, claimSetBytes []byte</span><br><span class="line"></span><br><span class="line">	if joseHeaderBytes, err = json.Marshal(joseHeader); err != nil &#123;</span><br><span class="line">		return nil, 0, nil, fmt.Errorf(&quot;unable to marshal jose header: %s&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if claimSetBytes, err = json.Marshal(claimSet); err != nil &#123;</span><br><span class="line">		return nil, 0, nil, fmt.Errorf(&quot;unable to marshal claim set: %s&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	encodedJoseHeader := base64UrlEncode(joseHeaderBytes)</span><br><span class="line">	encodedClaimSet := base64UrlEncode(claimSetBytes)</span><br><span class="line">	payload := fmt.Sprintf(&quot;%s.%s&quot;, encodedJoseHeader, encodedClaimSet)</span><br><span class="line"></span><br><span class="line">	var signatureBytes []byte</span><br><span class="line">	if signatureBytes, _, err = signingKey.Sign(strings.NewReader(payload), crypto.SHA256); err != nil &#123;</span><br><span class="line">		return nil, 0, nil, fmt.Errorf(&quot;unable to sign jwt payload: %s&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	signature := base64UrlEncode(signatureBytes)</span><br><span class="line">	tokenString := fmt.Sprintf(&quot;%s.%s&quot;, payload, signature)</span><br><span class="line">	t, err = token.NewToken(tokenString)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>嗯，是的，其实Harbor也没有生成token的算法过程，docker registry定义了token的格式，并提供了配置认证服务器的地址。因此只要按照定义的格式来准备数据，就可以调用registry的相关函数来生成token：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//https://github.com/docker/distribution/blob/master/registry/auth/token/token.go</span><br><span class="line">func NewToken(rawToken string) (*Token, error) &#123;</span><br><span class="line">	parts := strings.Split(rawToken, TokenSeparator)</span><br><span class="line">	if len(parts) != 3 &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var (</span><br><span class="line">		rawHeader, rawClaims   = parts[0], parts[1]</span><br><span class="line">		headerJSON, claimsJSON []byte</span><br><span class="line">		err                    error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	if headerJSON, err = joseBase64UrlDecode(rawHeader); err != nil &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if claimsJSON, err = joseBase64UrlDecode(rawClaims); err != nil &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	token := new(Token)</span><br><span class="line">	token.Header = new(Header)</span><br><span class="line">	token.Claims = new(ClaimSet)</span><br><span class="line"></span><br><span class="line">	token.Raw = strings.Join(parts[:2], TokenSeparator)</span><br><span class="line">	if token.Signature, err = joseBase64UrlDecode(parts[2]); err != nil &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err = json.Unmarshal(headerJSON, token.Header); err != nil &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err = json.Unmarshal(claimsJSON, token.Claims); err != nil &#123;</span><br><span class="line">		return nil, ErrMalformedToken</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return token, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中，我们可以发现，token是通过JWT（JSON Web Token）来实现的，主要部分是joseHeader和claimSet。joseHeader和claimSet结构体数据转换成字符串之后，进行连合，构成payload字符串，payload再由私钥进行加密签名，得到签名字符串。最后，payload和签名字符串进行连合，传递给token.NewToken函数来生成token。<br>在Harbor中，joseHeader描述了token的类型以及使用的hash算法，除此之外还加入了KeyID这一认证相关的信息，KeyID是采用<code>github.com/docker/libtrust</code>根据公钥生成。<br>ClaimSet包含了进行认证的必要信息，具体包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Issuer：代表了发起请求的实体，是一个大小写敏感的字符串。Harbor中该值为&quot;harbor-token-issuer&quot;。</span><br><span class="line">Subject：代表的是JWT的主题，该字段要求在上下文中或者是全局唯一，可以放入用户帐号；Harbor中该值为用户帐号。</span><br><span class="line">Audience：代表的是JWT希望的接受者；Harbor中该值为registry配置的service名，即&quot;harbor-registry&quot;。</span><br><span class="line">Expiration Time：代表的是token的过期时间；Harbor中该值默认为30分钟。</span><br><span class="line">NotBefore：代表的是JWT不能早于该时间来处理；</span><br><span class="line">IssuedAt：代表的是JWT的签发时间。</span><br></pre></td></tr></table></figure></p>
<p>docker registry在此基础上还增加2个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">– JWTID: 这是一个基于base64加密的随机长度的字符串；</span><br><span class="line">– Access:代表了访问和操作权限，Harbor中该值根据scope字符串转换为对应数据结构得到。</span><br></pre></td></tr></table></figure></p>
<p>有了这些信息，就可以生成满足要求的token，进而附加到request header中，成功请求registey v2 API。token service会使用私钥进行签名，registry则会使用公钥进行验证，因此，Harbor的ui和registry需要使用配对的公私钥。<br>注：token认证实现可以参考<a href="http://www.skycloudsoftware.com/index.php/2016/06/13/docker-registry-v2-token.html" target="_blank" rel="noopener">从源码看Docker Registry v2中的Token认证实现机制</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是Harbor请求registry组件API大概的处理过程。由此可以看出，在Harbor请求registry API的过程中，ping请求<code>your-registry-host:port/v2/</code>所得到的service url其实在这个过程中并没有起到作用，但这个service url在docker login的时候则会起到作用。因此，我们最好是对比docker login的过程来理解API请求的过程，方能理解得更深刻。<br>最后的一点提醒，以上源代码皆是代码片段，详情请查看github Harbor和registry V2源码。以Harbor tags v1.1.2为准，查看源代码的时候请注意切换tags，谨记。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/实验室项目环境迁移/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/实验室项目环境迁移/" itemprop="url">实验室项目环境迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:43:32+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="docker服务"><a href="#docker服务" class="headerlink" title="docker服务"></a>docker服务</h1><h2 id="部署docker环境"><a href="#部署docker环境" class="headerlink" title="部署docker环境"></a>部署docker环境</h2><p>1、安装docker服务<br>2、拉取相关镜像(push/pull/save/load)</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>1、centos7安装mariadb<br>2、导出和导入数据库文件</p>
<h2 id="部署beego环境"><a href="#部署beego环境" class="headerlink" title="部署beego环境"></a>部署beego环境</h2><h3 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h3><p>（<strong>注意先查看安装的版本，ubuntu下直接命令安装可能会安装低版本</strong>）<br>centos下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install golang</span><br></pre></td></tr></table></figure></p>
<p>ubuntu推荐源码安装<br>查看下载页面：<br><code>https://golang.org/dl/</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xzf go1.7.4.linux-amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></p>
<p>添加<code>/usr/local/go/bin</code>到PATH<br>在/etc/profile (for a system-wide installation)或$HOME/.profile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></p>
<p>设置当前用户环境变量：$HOME/.profile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/golang</span><br><span class="line">export GOBIN=$HOME/golang/bin</span><br><span class="line">export PATH=$PATH:$GOBIN</span><br></pre></td></tr></table></figure></p>
<p>执行<code>source $HOME/.profile</code><br>测试：<code>go env</code></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure></p>
<p>配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Keith&quot;</span><br><span class="line">git config --global user.email &quot;Keith_me_please@163.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>生成密钥(~/.ssh/)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “Keith_me_please@163.com”</span><br></pre></td></tr></table></figure></p>
<h3 id="安装beego和bee"><a href="#安装beego和bee" class="headerlink" title="安装beego和bee"></a>安装beego和bee</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/astaxie/beego</span><br><span class="line">go get github.com/beego/bee</span><br></pre></td></tr></table></figure>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>beego项目godep管理，推送<br>拉取项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.coding.net/codingJian/docker.git</span><br></pre></td></tr></table></figure></p>
<h1 id="saas项目"><a href="#saas项目" class="headerlink" title="saas项目"></a>saas项目</h1><p>saas项目所在主机需要安装expect、memcached。</p>
<h2 id="安装memcached-server"><a href="#安装memcached-server" class="headerlink" title="安装memcached server"></a>安装memcached server</h2><p>ubuntu源安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install memcached</span><br></pre></td></tr></table></figure></p>
<p>使用memcached：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached -d -m 128 -p 11211 -u root -c 1024</span><br></pre></td></tr></table></figure></p>
<p>-d表示后台运行，-m指定内存大小，-p指定监听端口，-u指定假设运行用户身份，-c指定最大并发连接。</p>
<h2 id="使用golang-memcache-client"><a href="#使用golang-memcache-client" class="headerlink" title="使用golang memcache client"></a>使用golang memcache client</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/bradfitz/gomemcache/memcache</span><br></pre></td></tr></table></figure>
<p>使用方法参考 <a href="https://godoc.org/github.com/bradfitz/gomemcache/memcache" target="_blank" rel="noopener">https://godoc.org/github.com/bradfitz/gomemcache/memcache</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/beego使用godep管理依赖/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/beego使用godep管理依赖/" itemprop="url">beego使用godep管理依赖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:36:47+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tools/godep</span><br></pre></td></tr></table></figure>
<p>出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package golang.org/x/tools/go/vcs: unrecognized import path &quot;golang.org/x/tools/go/vcs&quot;</span><br></pre></td></tr></table></figure></p>
<p>解决：虽然出错但是某些文件已经下载下来，如<code>src/github.com/tools/godep/vendor/golang.org/x/tools/go/vcs</code>文件夹，创建<code>src/golang.org/x/tools/go/vcs</code>文件夹，并将<code>src/github.com/tools/godep/vendor/golang.org/x/tools/go/vcs</code>文件夹，并将其内容复制到<code>src/golang.org/x/tools/go/vcs</code>文件夹，重新<code>$ go get github.com/tools/godep</code>。</p>
<h1 id="保存依赖：旧版本"><a href="#保存依赖：旧版本" class="headerlink" title="保存依赖：旧版本"></a>保存依赖：旧版本</h1><p>进入beego项目，执行<code>godep save -r ./...</code>。<br>因为依赖的项目和项目本身都应该是个git repository，所以应该根据提示将依赖项目处理为git repository。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add *   </span><br><span class="line">git commit -m &quot;init&quot;</span><br></pre></td></tr></table></figure></p>
<p><code>godep save -r ./...</code>命令完成以下工作：<br>首先，godep会扫描当前目录下所属包中的import语句导入的所有外部依赖库（系统库忽略），取得外部依赖库的路径和当前对应的版本（即commit id）保存到Godeps/Godeps.json里，格式是JSON。<br>其次，godep会将每个依赖库都从$GOPATH目录拷贝到Godeps/_workspace下，注意拷贝的内容不包含代码管理信息比如.git目录，拷贝后的目录结构与$GOPATH完全相同。<br>并且beego项目内对外部依赖库的import路径都会被修改。</p>
<p>成功执行的话会在项目目录下生成Godeps目录。将beego项目重新提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每次新增一个原文件时，你都应该再次执行 godep save -r ./... 以确保你应用的相关依赖都被重写与记录。</span><br></pre></td></tr></table></figure>
<h1 id="保存依赖：新版本"><a href="#保存依赖：新版本" class="headerlink" title="保存依赖：新版本"></a>保存依赖：新版本</h1><p>进入beego项目，执行<code>godep save ./...</code>。<br>在GO15VENDOREXPERIMENT=1时，将使用vendor目录（而不是Godeps目录）存放copy的第三方包，并在godep go build时不再rewrite GOPATH就可以实现利用vendor下第三方包的构建。</p>
<h1 id="升级godep到最新版本"><a href="#升级godep到最新版本" class="headerlink" title="升级godep到最新版本"></a>升级godep到最新版本</h1><p>如果要用到go 1.5 vendor，那么godep要升级（<code>go get -u github.com/tools/godep;go build github.com/tools/godep</code>）到当前的最新版本“commit d8799f112f6c8dfe1e56142831bc3bb5c8796a0e”。最新版本兼容老版本的功能，同时提供对go 1.5 vendor支持，两者之间转换的开关就是环境变量：<code>GO15VENDOREXPERIMENT</code>。</p>
<p>当GO15VENDOREXPERIMENT没有被set时，godep沿用以前的方式；当GO15VENDOREXPERIMENT = 1时，godep将用vendor替代Godeps目录以存放第三方包，同时go save将无法使用-r命令行选项(-r选项用于重写源码中的import path)：<br>如果使用<code>godep save -r</code><br>将出现<code>godep: flag -r is incompatible with the vendoring experiment</code></p>
<p><strong>注意：go get github.com/tools/godep之后最好使用一个新项目验证保存依赖情况，验证godep是否是最新版本。</strong></p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>加入A机器上的项目使用godep保存依赖，并移植到B机器，之后B机器的项目引用了新的第三方库，如果继续使用<code>godep save ./…</code>保存依赖的话，可能会出现一些错误。这种情况下，首先执行<code>godep restore</code>，再执行<code>godep save ./…</code>。</p>
<h1 id="迁移：待检验正确性"><a href="#迁移：待检验正确性" class="headerlink" title="迁移：待检验正确性"></a>迁移：待检验正确性</h1><p>由于godep前后的两种工作模式并不兼容，因此大量使用godep的repo，如果想使用Go 1.5 vendor，那么在升级到Go 1.5之后需要做一些迁移工作。godep没有提供自动的迁移工具，目前只能手动迁移，godep github主页上给出了手动迁移的命令步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unset GO15VENDOREXPERIMENT</span><br><span class="line">godep restore</span><br></pre></td></tr></table></figure></p>
<p>如果之前使用了godep save -r，那么下面这行命令将自动undo rewritten import。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godep save ./…</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf Godeps</span><br><span class="line">export GO15VENDOREXPERIMENT=1</span><br><span class="line">godep save ./…</span><br></pre></td></tr></table></figure>
<p>Godeps/_workspace/src的文件将”moved”到vendor/。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/Cmake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/Cmake/" itemprop="url">Cmake</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:34:25+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PROJECT"><a href="#PROJECT" class="headerlink" title="PROJECT"></a>PROJECT</h1><p>格式：<code>PROJECT(projectname [CXX] [C] [Java])</code><br>定义工程名称，指定工程支持的语言，支持的语言列表可以忽略，默认情况表示支持所有语言。这个指令隐式的定义了两个 cmake 变量:<code>&lt;projectname&gt;_BINARY_DIR</code>以及<code>&lt;projectname&gt;_SOURCE_DIR</code>。内部编译的话两个变量都是指向工程所在路径。工程名一般大写。</p>
<h1 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h1><p><code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>是cmake系统预定义变量，值分别跟<code>&lt;projectname&gt;_BINARY_DIR</code>以及<code>&lt;projectname&gt;_SOURCE_DIR</code>一致。</p>
<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><p>格式：<code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><br>显式定义变量。引用变量的方式为<code>${...}</code>，但有一些例外，比如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。</p>
<h1 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h1><p>格式：<code>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot; ...)</code><br>向终端输出用户定义的信息，包含了三种类型:<br><code>SEND_ERROR</code>：产生错误，生成过程被跳过。<br><code>SATUS</code>：输出前缀为—的信息。<br><code>FATAL_ERROR</code>：立即终止所有 cmake 过程。</p>
<h1 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h1><p>格式：<code>ADD_EXECUTABLE(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])</code><br>生成可执行文件，注意：工程名与可执行文件名没有任何关系。</p>
<h1 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h1><p>1、变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名。<br>2、指令(参数1 参数2…)<br>参数使用括弧括起，参数之间使用空格或分号分开。<br>3、指令是大小写无关的，参数和变量是大小写相关的。推荐全部使用大写指令。<br>4、参数可使用双引号。</p>
<h1 id="内部编译-内部构建"><a href="#内部编译-内部构建" class="headerlink" title="内部编译/内部构建"></a>内部编译/内部构建</h1><p>编译方式：在工程目录中执行<code>cmake .</code>。<br>源文件、CMakeLists.txt都在工程目录中，生成的中间文件、Makefile等都在本目录中。生成一些无法通过使用make distclean自动删除的中间文件（因为无法跟踪）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
