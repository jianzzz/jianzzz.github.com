<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="自学项目,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Part 1: Physical Page Management程序的几乎所有代码都集中在 pmap.c 文件中。此部分为物理页面管理，强调对机器拥有的物理内存的管理，包括建立对应的数据结构、处理分配和回收动作等。需要完成boot_alloc()、mem_init() (only up to the call to check_page_free_list(1))、page_init()、page">
<meta name="keywords" content="自学项目">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记05 - Lab2: Memory Management">
<meta property="og:url" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="Part 1: Physical Page Management程序的几乎所有代码都集中在 pmap.c 文件中。此部分为物理页面管理，强调对机器拥有的物理内存的管理，包括建立对应的数据结构、处理分配和回收动作等。需要完成boot_alloc()、mem_init() (only up to the call to check_page_free_list(1))、page_init()、page">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/1.JPG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/2.jpg">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/3.JPG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/4.JPG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/5.JPG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/6.JPG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/7.JPG">
<meta property="og:updated_time" content="2019-06-12T12:04:32.223Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记05 - Lab2: Memory Management">
<meta name="twitter:description" content="Part 1: Physical Page Management程序的几乎所有代码都集中在 pmap.c 文件中。此部分为物理页面管理，强调对机器拥有的物理内存的管理，包括建立对应的数据结构、处理分配和回收动作等。需要完成boot_alloc()、mem_init() (only up to the call to check_page_free_list(1))、page_init()、page">
<meta name="twitter:image" content="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/1.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/">





  <title>笔记05 - Lab2: Memory Management | 蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">笔记05 - Lab2: Memory Management</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:08:04+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>程序的几乎所有代码都集中在 pmap.c 文件中。此部分为物理页面管理，强调对机器拥有的物理内存的管理，包括建立对应的数据结构、处理分配和回收动作等。需要完成<code>boot_alloc()</code>、<code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)、<code>page_init()</code>、<code>page_alloc()</code>、<code>page_free()</code>等函数。</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>JOS 的启动过程实际上是先把 bootsector 的内容读到 0x7c00 处 （注意，bootsector 的代码在编译的时候已经故意地把逻辑地址的首地址定在了 0x7c00 上），bootsector 中的代码开始执行后，会从磁盘上紧接着自己的第 2 个扇区开始，一直读 8 个扇区的内容（一共是 8×512=4KB， ELF 头的大小）到 0x10000（64KB）的地方，然后，通过对 ELF 头的解析，得到 kernel 模块编译出来后所占的大小，并将 kernel 读到物理内存 0x100000（1MB）开始的地方。然后加载 <code>entry_pgdir</code> 的物理地址到 cr3 中开启分页，并调用 <code>i386_init()</code> 函数，而 <code>i386_init()</code> 函数在将自己的 BSS 区域清零后，调用 <code>cons_init()</code> 函数设置好屏幕显示设备为 cprintf 的运行做好准备后就调用 <code>mem_init()</code> 函数。 <code>mem_init();</code> 函数调用 <code>i386_detect_memory();</code> 函数读 CMOS 取得物理内存的实际大小。<code>i386_init()</code> 函数最后会调用 <code>monitor(NULL);</code> 并进入循环，处理用户通过终端输入的命令。<br>在调用 <code>i386_init()</code> 函数以前，内存分布如下所示：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/1.JPG" title="在调用i386_init函数以前内存分布"></p>
<h2 id="以下是物理内存管理设计思想"><a href="#以下是物理内存管理设计思想" class="headerlink" title="以下是物理内存管理设计思想"></a>以下是物理内存管理设计思想</h2><p>调用<code>i386_detect_memory()</code>函数获取到物理内存的基本内存页数和总内存页数（包括扩展内存）。  </p>
<p>调用<code>boot_alloc()</code>函数为页目录分配 4KB 的空间。外部字符数组变量 edata 和 end，其中 edata 表示的是 bss 节起始位置（虚拟地址），而 end 则是表示内核可执行程序结束位置（虚拟地址）。<code>boot_alloc()</code>函数从 end 表示的位置（注意是<strong>线性地址</strong>）开始进行 4K 位置对齐，然后分配足够页空间。nextfree 表示空闲的线性地址，npages 表示总内存页数。根据<code>(uint32_t)nextfree - KERNBASE &gt; npages * PGSIZE</code>判断是否越界。每次分配后对 nextfree 进行 4K 对齐。</p>
<p>使用<code>boot_alloc()</code>函数分配 pages 结构体数组空间(struct PageInfo 类型)，共 npages 项，将其清零，后续将从该数组空间中动态分配出页空间（<strong>比如分配页存储页表等</strong>）。pages 数组与实际物理空间存在映射关系，不需要通过pages 数组存储物理页位置。struct PageInfo 包括 <code>pp_link</code> 和 <code>pp_ref</code>， <code>pp_ref</code>标识页空间是否可用，<code>pp_link</code>用于回溯前一个空闲的PageInfo，形成双向列表（具体见<code>page_init()</code>）。pages 始终指向页空间首位置，使用下标向后访问所有可用/不可用内存；<code>page_free_list</code> 始终指向可用页空间的末尾位置，往回指的指针 <code>pp_link</code> 要越过非空物理页,这样 <code>page_free_list</code> 才能通过 <code>pp_link</code> 往回获取空闲空间。<strong>由此可知， PageInfo 结构体数组空间是连续的，对于每次分配出的PageInfo指针，都可以计算出其与数组头之间的偏移，从而计算出当前是分配到第几页物理页；另一方面，从<code>page_free_list</code>角度看，连续的 PageInfo 结构体数组空间又是由指针回溯的不连续空间，从而可以自由合并和分出PageInfo空间。</strong></p>
<p>关于内存可用与否：<br>第一页数据是被使用的，该页保存了实模式IDT和BIOS数据结构。<br>第二页至基本内存结束位置(640K)是可用的。<br>[IOPHYSMEM, EXTPHYSMEM)即[0x0A0000,0x100000)即[640K,1MB)是被使用的。<code>io_hole</code> = 96 pages。<br>扩展内存开始位置至当前 pages 数组存储的末端为不可使用的部分（准确来说应该是使用 <code>boot_alloc(0)</code> 获取得到的线性地址，此线性地址才是代表 <code>boot_alloc()</code> 后 4K 对齐的位置），<code>boot_alloc(0)</code> 的线性地址开始至可用内存末端即为可用的。<br>注意：扩展内存开始位置为 1M，内核代码存放于 0x100000 处，即 1M 处，KERNBASE 是内核代码存储起点的线性地址。对于存于物理地址 1M 后的数据，其线性地址减去 KERNBASE 的值相当于该处与内核代码存储起点线性地址位置的差，而不是与 0x0 的差, 需要加上 1M 的空间，即 256 page。</p>
<p><code>page_alloc()</code>函数将从 pages 数组空间中由后往前分配，通过使用 <code>page_free_list</code> 指针和 <code>pp_link</code> 成员。当传入参数标识非 0 时，分配的空间将被清零。虽然一开始 pages 数组空间被清零，但此刻分配的空间可能是之前被使用后回收的，不一定为空。<br><code>page_free()</code>函数回收页空间，将<code>page_free_list</code>指向回收的空间。</p>
<h1 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h1><p>通过 Part1 的几个函数，我们得以在可用内存空间上调用<code>boot_alloc()</code>函数分配足够的页对齐的空间大小，并且通过映射物理页使用情况的 pages 数组来分配二级页表页和索引页目录项到该二级页表页，以及分配物理页和索引二级页表项到该物理页。</p>
<h2 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h2><p>1、x86的虚拟地址包括段选择子和偏移部分，经过段地址转换以后，获得线性地址，再经过页地址转换以后，获得物理地址。<br>2、<strong>一个C指针就是代表虚拟地址的偏移地址部分。</strong><br>3、boot/boot.S对GDT表进行设置，其中所有段基址设为0，段限长设为0xffffffff，因此段选择子部分失去了对段地址转换的影响，线性地址等于偏移地址（那也就是说一个C指针就是代表线性地址？）。<br>在内核还没动态创建页目录和页表之前，为了能在0xf0100000地址上运行内核代码，jos通过手写、静态初始化页目录和页表映射了前4M内存空间。而lab2实验则是动态映射物理地址空间的低256MB（0x00000000 - 0x0fffffff）到线性地址（0xf0000000 - 0xffffffff）。<br>4、qemu使用<code>info pg</code>命令可以查看当前页表的详细信息，包括映射的内存范围、权限以及标识。<code>info mem</code>命令概述了哪个范围的虚拟地址被映射，以及其权限。<br>5、页目录所在的物理页面的首地址在启动 x86 的页式地址管理前，需要放到 CR3 中，这样 x86 在进行页式地址转换时会自动地从 CR3 中取得页目录地址，从而找到当前的页目录。<br>6、在现代操作系统中，我们经常可以听到“用户进程的虚地址空间为 4GB”的说法，怎么来实现呢？原理其实很简单：为每个用户进程创建一个页目录，并将这个页目录保存到用户进程的上下文中，当该用户进程被切换过来执行的时候，就将该用户进程的页目录地址写入 CR3，并重新启动一次页式内存管理。当然如果采用这种方式，势必占用更多的内存用于页式地址变换。对于老版本的 Linux 系统以及我们现在接触的 JOS 系统， 为了避免太大的内存开销（另一个原因是因为还没有虚拟内存的支持），在整个系统中只使用一个内核页目录。这就意味着，整个系统的线性地址空间只有 4GB，而且是所有（操作系统内核、各个用户程序）代码所公用的！这种情况下，就必须对线性地址进行合理的规划了。<br>7、对于页式地址管理，由于页目录以及页表都存放在物理内存的页面中，要进行地址变换先要到内存中访问页目录和页表。由于 CPU 和内存速度的不匹配，为了最小化用于地址转换的总线周期， x86 系统中设计了用于地址翻译的缓存来解决这一问题，这一缓存称为 TLB（ Translation Look-aside buffer，即旁路转换缓冲，或称为页表缓冲，或转换后备缓冲区），在该缓存中存放了最近访问的页目录和页表条目，由于程序执行的局部性原理，下一次的地址转换往往跟上一次的地址转换采用的是同一个页目录表项和页表项），同时，由于 TLB 跟处理器的距离更近，这样就极大地提高了地址翻译的效率和速度。但是，这样做可能存在一个潜在的问题：页目录（表）数据项的不一致性。以前系统里对应一个线性地址只有唯一的存放在内存中的页目录和页表，用于完成翻译的工作，但是现在由于 TLB 的存在，系统可能在高速缓存中也存放了一份页表项数据，用于更快地对地址进行翻译。因为 TLB 中的数据对于程序员来说是不可见的，程序对于页表项或者页目录项的修改并不能马上反映到 TLB 中，这样就可能导致错误的地址翻译，因为为了提高翻译的速度，处理器总是尽量地采用 TLB 中的页表数据进行地址的翻译。所以，为了避免这种数据的不一致性所导致的地址翻译的错误情形的出现，系统程序员就必须在对页表进行修改后使 TLB 中旧的页表数据失效。使其失效的办法有两个，一个是重载 CR3，使整个 TLB 中的数据都失效，也可以采用 invlpg 指令。</p>
<p>以下是线性地址到物理页映射的设计思想：<br><code>pgdir_walk()</code>函数根据线性地址返回二级页表项入口。首先获取页目录项位置，使用指针指向其索引位置。如果页目录项不存在二级页表映射，且create标识为0，则返回NULL。否则使用<code>page_alloc</code>函数分配页表空间，分配失败则返回NULL，否则将分配的PageInfo结构体引用加1，并将其对应的物理页地址和权限（<strong>二级页表权限设为 kern R/W, user R/W</strong>）存在页目录项中。二级页表物理地址是4K对齐的，将其低12位清零然后转化为内核地址，使用指针指向它。<strong>注意到页目录和页表存的是物理地址，而指向页目录和页表的指针需要使用逻辑地址。</strong>最后根据指向二级页表的指针和通过线性地址求得的二级页表项索引，返回指向二级页表项的指针。<code>pgdir_walk()</code>只负责创建二级页表，然后返回指向二级页表项的指针，不对二级页表做处理，也不做其对物理页映射。我们知道，pages结构体数组是用于映射所有内存空间的，<code>page_free_list</code>指针指向的结构体所映射的内存空间均可用。<code>page_alloc</code>函数将从 pages 数组空间中分配可用空间，结构体映射的物理页地址将作为线性地址的页表，将其存储到页目录里。</p>
<p><code>page_lookup()</code>函数根据线性地址返回二级页表项所指的物理页对应的PageInfo数据结构。<code>pte_t **pte_store</code>存储的是二级页表项的地址（传递过来的是某个指针的地址，对于那个指针来说，函数执行后它就指向对应的二级页表项了），设计这个指针的含义是：当通过<code>page_remove()</code>移除线性地址对应的物理页时，可以清空二级页表项的内容。<code>page_lookup()</code>函数调用<code>pgdir_walk()</code>获得指向二级页表项的指针，不允许创建二级页表。如果页目录项不存在二级页表映射且不允许创建二级页表，或者没有空间分配二级页表，<code>pgdir_walk()</code>会返回NULL，则<code>page_lookup()</code>返回NULL。如果获得的二级页表项不存在物理页映射，则<code>page_lookup()</code>返回NULL。否则将二级页表项的地址存于<code>pte_t **pte_store</code>，<code>pgdir_walk()</code>返回的二级页表项指针内容是所指的物理页物理地址，将其低12位清零，并返回对应的PageInfo数据结构。</p>
<p><code>page_remove()</code>函数移除线性地址对应的物理页，清空二级页表项，使tlb无效化。如果不同的线性地址映射到同一个二级页表项，它们就映射到同一个物理页。另一种情况是不同的线性地址映射到不同的二级页表项，且它们通过<code>page_insert</code>映射到同一个物理页，这代表的是不同的二级页表项存取同一个物理页地址。通过<code>page_remove</code>即可解除情况1到二级页表项的映射，在这里，一旦线性地址对应到二级页表项，即将其清空。<code>page_remove()</code>函数通过调用<code>page_lookup()</code>函数获得线性地址对应的物理页的PageInfo数据结构，然后调用<code>page_decref()</code>函数将PageInfo对象引用减1，如果引用为0则释放该内存页。</p>
<p><code>page_insert()</code>函数将映射物理页的PageInfo数据结构的地址及访问权限存于线性地址所对应的二级页表项内。<code>page_insert()</code>函数首先调用<code>pgdir_walk()</code>函数获得指向线性地址的二级页表项的指针，允许创建二级页表。当对应的二级页表不存在且没有足够内存空间创建二级页表时，<code>pgdir_walk()</code>函数返回NULL，则<code>page_insert()</code>函数返回-1。否则<code>pgdir_walk()</code>函数返回指向二级页表项的指针，当该指针的P存在位为1时，代表当前二级页表项存在物理页映射，这时候需要判断该物理页与要插入的物理页是否是同一页，判断方法是：将指针内容（已经是物理地址）低12位清零，转化为PageInfo指针p，并与函数参数<code>PageInfo *pp</code>进行比较。如果是同一页（p与pp指向同个结构体），应该允许修改权限（包括降低权限，所以先清空低12位）后直接返回0，否则调用<code>page_remove()</code>函数移除线性地址对应的物理页，清空二级页表项。接着待插入的PageInfo指针pp的引用加1，将pp对应的物理页物理地址及权限存于二级页表项处，使tlb无效化。注意如果已映射的物理页和待插入的物理页是同一页的话，不能先移除物理页p再将pp的引用加1，因为一旦移除物理页p，p可能因为引用为0而被释放，进而page_free_list指向这块内存页，将其标记为可用，而此时pp的物理页是不可用的。</p>
<p><code>boot_map_region()</code>函数将线性地址空间[va, va+size)映射到物理地址空间[pa, pa+size)。pa、va是页对齐的，size是页大小的倍数。<code>boot_map_region()</code>函数循环调用<code>pgdir_walk()</code>函数返回指向二级页表项的指针，然后将对应的物理地址和权限存储到该指针。jos只有一个内核页目录，最多映射4G空间。jos将[KERNBASE,4G)的空间映射到物理内存上，其中KERNBASE=0xf0000000=3840M，4G=4096M，两者相差256M。因此，物理内存最多映射256M，即[0,256M)。4G等于0x100000000，其被映射的最后一页的起点地址是0xfffff000，这也就是<code>boot_map_region()</code>中能被映射的最后一个线性地址。</p>
<h1 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h1><p>jos一共有三个线性地址到物理地址的映射是需要的，此部分负责进行映射：<br><code>[UPAGES, sizeof(PAGES) ] =&gt; [pages, sizeof(PAGES)]</code>，这里 PAGES 代表页面管理结构所占用的空间；<br><code>[KSTACKTOP – KSTKSIZE, 8] =&gt; [bootstack, 8]</code>，<br>其中 bootstack 为内核编译时预先留下的 8 个页面（用做内核堆栈）；<br><code>[KERNBASE, 4G) =&gt; [0, pages in the memory)</code>，这个地址映射范围比较广，含盖了所有物理内存。这里是256M。<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/2.jpg" title="线性地址映射"></p>
<p><code>以下是对question的解答：</code><br><strong>2. 哪些页目录项已经被填充？它们映射到哪些地址并指向哪些内容？</strong><br>使用技巧：使用qemu调试后，在执行qemu的控制台里，先后按下ctrl、a、h查看帮助，先后按下ctrl、a、c可切换qemu监控器和终端控制台，切换到qemu监控器后，执行<code>info pg</code>可查看当前页表结构。<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/3.JPG" title="当前页表结构"><br>以其中的<code>[ef000-ef3ff]  PDE[3bc]     -------UWP</code>为例，它表示该页目录项映射的线性空间范围是[ef000000, ef3fffff]，两者之差为3fffff，即4M大小。3bc表示索引是956。UWP表示该项是kernel RW, user RW且president的。  </p>
<p>上图表示的页目录项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Entry       Base Virtual Address    Points to (logically):</span><br><span class="line">1023(3ff)   0xffc0000               Page table for top 4MB of phys memory, kernel RW, user NONE</span><br><span class="line">1022(3fe)   0xff80000               Page table for second to top 4MB of phys mem, kernel RW, user NONE</span><br><span class="line">.</span><br><span class="line">960(3c0)    0xf0000000              Page table for bottom 4MB of phys memory, kernel RW, user NONE</span><br><span class="line">959(3bf)    0xefc00000              (0xefff8000 - 0xf0000000 Kernel stack, kernel RW, user NONE)</span><br><span class="line">                                    (0xefc00000 - 0xefff8000 Invalid memory, or maybe other cpu&apos;s stack)</span><br><span class="line">957(3bd)    0xef400000              Current page table kernel R-, user R- (pgdir)</span><br><span class="line">956(3bc)    0xef000000              User pages, kernel R, user R</span><br><span class="line">.</span><br><span class="line">2           0x00800000</span><br><span class="line">1           0x00400000</span><br><span class="line">0           0x00000000              &lt;Nothing, mapping got cleared&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 内核环境和用户环境被映射到同一个地址空间，为什么用户程序不会读写内核内存？有什么保护机制吗？</strong><br>ULIM和UTOP将虚拟内存分为各个段。(ULIM, 4GB)只有内核环境能读写，(UTOP, ULIM]内核和用户环境都可以读取，[0x0, UTOP]是用户环境空间。这些内存空间被权限位所保护，如PTE_W(可写)和PTE_U(用户)，这些是在页表/页目录项中设置的标识。<br>具体用于保护的机制是当前特权级别(CPL)，CS的低2位。CPL=0则代表特权O/S，CPL=3 代表用户可访问。这也被用来检测当前的模式，以及我们是否可以写入虚拟内存地址。</p>
<p><strong>4.jos能支持的最大物理内存是多少？为什么？</strong><br>这个操作系统能支持的最大物理内存是256 MB。这是因为我们希望能够将所有的线性地址映射到物理地址。事实证明这样做使它更容易从物理地址反向映射到虚拟地址。</p>
<p><strong>5.如果我们真的有最大数量的物理内存，需要多少空间开销来管理内存？</strong><br>管理内存有页表和页目录，4G空间需要1个页目录和1024个页表，总共需要的空间开销是4KB * 1024 + 4KB。</p>
<p><strong>6.重新阅读kern/entry.S和kern/entrypgdir.c，我们开启分页后，EIP仍然是小于1MB的值，我们是在哪个point开始在基于KERNBASE的EIP上执行指令？从我们开启分页的时刻，到我们开始在基于KERNBASE的EIP上执行指令的时刻，这段时间为什么能够使用low EIP？</strong><br>在entry.S中，执行<code>jmp *%eax</code>指令之后eip将会加上KERNBASE。在开启分页到执行<code>jmp *%eax</code>指令这段期间，之所以能够使用low EIP，是因为线性地址[0, 4MB)和[KERNBASE, KERNBASE+4MB)同时映射到[0,4MB)物理地址，如果不映射线性地址[0, 4MB)，则low eip的线性地址不在可访问线性地址范围内，将出现非法访问。</p>
<p><code>以下是对Challenge的解答：</code>  </p>
<h2 id="Changeling1"><a href="#Changeling1" class="headerlink" title="Changeling1"></a>Changeling1</h2><p>我们使用了很多二级页表来映射KERNBASE地址，一个更有效的方法是使用页目录项的PTE_PS (“Page Size”)位，最初的80386不支持该位，但近年来的x86处理器可支持。阅读【Intel® 64 and IA-32 Architectures Software Developer’s Manual】第3.6 节【PAGING (VIRTUAL MEMORY) OVERVIEW】。**<br>如果将CR4中的PSE位打开，那么就可以开启4MB物理页。那么对应使用该物理页的虚拟地址寻址方式变为：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/4.JPG" title="开启4MB物理页的虚拟地址寻址方式"><br>这个时候相应的页目录表项也要修改，要修改其PS位表明该表项对应的地址是4MB，不用再进行二级页表寻址了：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/5.JPG" title="修改页目录表项PS位"><br>设置了使用4MB页表以后，那些二级页表查找和插入的过程就不能通用了，即<code>pgdir_walk()</code>、<code>page_insert()</code>函数等。但这不影响<code>check_page()</code>函数的检查，因为<code>check_page()</code>函数虽然调用了<code>pgdir_walk()</code>、<code>page_insert()</code>等函数，但是其检查逻辑是先模拟插入page再检查，二级页表的创建和页目录存储二级页表地址这些操作仍会被模拟（虽然此时页目录项的内容应该是4MB页地址，但其实是存了二级页表的地址）。相反，<code>check_kern_pgdir()</code>函数则不会成功执行，因为该函数是直接检查线性地址到物理地址的实际映射情况，再没有模拟插入page、创建二级页表的情况，所以其在涉及到二级页表的查询将会出错。所以修改为4MB页以后，应该注释掉<code>check_kern_pgdir()</code>函数的调用。如果qemu模拟器没有出现Triple fault，则代表寻址是正确的。实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">mem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// Turn on CR4_PSE for 4MB page</span><br><span class="line">	lcr4 (rcr4 () | CR4_PSE);</span><br><span class="line">	...</span><br><span class="line">	//boot_map_region(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U | PTE_P);</span><br><span class="line">	...</span><br><span class="line">	//boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line"> 	...</span><br><span class="line">	//boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">	...</span><br><span class="line">	// Check that the initial page directory has been set up correctly.</span><br><span class="line">	//check_kern_pgdir();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	jos只有一个内核页目录，最多映射4G空间。</span><br><span class="line">	jos将[KERNBASE,4G)的空间映射到所有物理内存上，这段内存是256M，</span><br><span class="line">	其中KERNBASE=0xf0000000=3840M，4G=4096M，两者相差256M。</span><br><span class="line">	因此，物理内存最多映射256M。4G等于0x100000000，其被映射的最后一页的起点地址是0xfffff000，</span><br><span class="line">	这也就是boot_map_region中能被映射的最后一个线性地址。</span><br><span class="line"></span><br><span class="line">	todo...可能存在的问题是：映射的是256M的内存，但是实际上只有64M可用的内存空间，</span><br><span class="line">	这些内存空间有对应的页面管理结构，其中一部分被作为映射256M内存空间时的二级页表。</span><br><span class="line">*/</span><br><span class="line">static void</span><br><span class="line">boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// Fill this function in</span><br><span class="line">	/*</span><br><span class="line">		使用下述方法时，在映射[KERNBASE,4G)地址时</span><br><span class="line">		只能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W | PTE_P);，</span><br><span class="line">		不能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">		0xffffffff - KERNBASE + 1 = 0x10000000，KERNBASE+ 0x10000000会越界。</span><br><span class="line">	*/</span><br><span class="line">	/*</span><br><span class="line">	uintptr_t current_va;</span><br><span class="line">	physaddr_t current_pa = pa;</span><br><span class="line">	// The highest possible address of a virtual page</span><br><span class="line">  	uint32_t last_page_addr = 0xfffff000;</span><br><span class="line">	for (current_va = va; current_va &lt; va+size; current_va += PGSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		pte_t *pte = pgdir_walk(pgdir,(void *)current_va,true);</span><br><span class="line">		if(pte == NULL) return;</span><br><span class="line">		*pte = (current_pa | perm | PTE_P);</span><br><span class="line">		 </span><br><span class="line">		//此判断是有必要的，当将[KERNBASE,4G)映射到[0,256M)时，线性地址累积到0xfffff000的时候，for循环的判断条件仍然是成立的。</span><br><span class="line">		if (current_va == last_page_addr)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		current_pa += PGSIZE; </span><br><span class="line">	&#125; </span><br><span class="line">	*/</span><br><span class="line">	/*</span><br><span class="line">		使用下述方法时，在映射[KERNBASE,4G)地址时</span><br><span class="line">		本应该使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);，</span><br><span class="line">		不能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W | PTE_P);，</span><br><span class="line">		因为这会导致循环次数减1，246M物理内存最后的1页没有被映射。</span><br><span class="line">		但由于实际的npages为16639，检测的总空间为64M，</span><br><span class="line">		check_kern_pgdir()函数会针对npages大小检测KERNBASE以上的地址映射情况，</span><br><span class="line">		超过64M以上的物理内存不会被检测到，所以并没有导致出错。</span><br><span class="line">		但严谨来说应该使用第一种情况。</span><br><span class="line">	*/</span><br><span class="line">	int i;</span><br><span class="line">    for (i = 0; i &lt; size/PGSIZE; ++i, va += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        pte_t *pte = pgdir_walk(pgdir, (void *) va, 1); //create</span><br><span class="line">        if (pte == NULL) panic(&quot;boot_map_region panic, out of memory&quot;);</span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">boot_map_region_4m(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	pde_t *pde;</span><br><span class="line">	int i;</span><br><span class="line">    for (i = 0; i &lt; size/PTSIZE; ++i, va += PTSIZE, pa += PTSIZE) &#123;</span><br><span class="line">        pde = pgdir + PDX(va); </span><br><span class="line">        *pde = pa | perm | PTE_P | PTE_PS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Changeling2"><a href="#Changeling2" class="headerlink" title="Changeling2"></a>Changeling2</h2><p>扩展jos的命令，1、当给定线性地址的范围时，以一种易读的格式展示内存页映射情况。如’showmappings 0x3000 0x5000’命令可以展示线性地址0x3000、0x4000、0x5000的物理页映射及其权限位。2、能显式清除、设置或改变当前地址空间映射的权限。3、给定一段线性地址/物理地址范围，显示其内容，必须确保当给定范围跨页面边界的时候显示代码的正确性。**<br>1、提供两个函数，一个是将地址字符串转换为整数，一个是将读入参数，按页大小输出二级页表项内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uint32_t jz_xtoi(char* pstr)&#123;</span><br><span class="line">	uint32_t res = 0;</span><br><span class="line">	pstr += 2;//0x...</span><br><span class="line">	while(*pstr)&#123;</span><br><span class="line">		if(*pstr &gt;= &apos;a&apos; &amp;&amp; *pstr &lt;= &apos;z&apos;) *pstr = *pstr - &apos;a&apos; + 10 + &apos;0&apos;;</span><br><span class="line">		else if(*pstr &gt;= &apos;A&apos; &amp;&amp; *pstr &lt;= &apos;Z&apos;) *pstr = *pstr - &apos;A&apos; + 10 + &apos;0&apos;;</span><br><span class="line">		res = res*16 + *pstr - &apos;0&apos;;</span><br><span class="line">		++pstr;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">mon_showmappings(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 3) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: showmappings 0xbegin_addr 0xend_addr\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	 </span><br><span class="line">	//将地址字符串转换int，然后判断低12位是不是0</span><br><span class="line">	uint32_t begin = jz_xtoi(argv[1]), end = jz_xtoi(argv[2]);</span><br><span class="line">	if((begin &amp; 0xfff) != 0 || (end &amp; 0xfff) != 0 )&#123;</span><br><span class="line">		cprintf(&quot;Make sure the addr&apos;s low 12 bits is zero\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(&quot;Attention! You may test addr above UPAGES(0xef000000)\n&quot;);</span><br><span class="line">	cprintf(&quot;begin:%p, end:%p\n&quot;,begin,end);</span><br><span class="line">	pde_t *kpgdir = KADDR(rcr3()), *pde; </span><br><span class="line">	pte_t *pte, *p;</span><br><span class="line">	uint32_t va;</span><br><span class="line">	for (va = begin; va &lt;= end; va += PGSIZE) </span><br><span class="line">	&#123; </span><br><span class="line">                //or you can use pgdir_walk</span><br><span class="line">		pde = &amp;kpgdir[PDX(va)];</span><br><span class="line">		if (*pde &amp; PTE_P)&#123; </span><br><span class="line">			pte = (pte_t*) KADDR(PTE_ADDR(*pde)); </span><br><span class="line">			if (*pte &amp; PTE_P)&#123; </span><br><span class="line">				p = &amp;pte[PTX(va)];</span><br><span class="line">				cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">					va, *p, *p&amp;PTE_P, *p&amp;PTE_W, *p&amp;PTE_U);			</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/6.JPG" title="showmappings执行结果"><br>2、使用<code>page_walk()</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">mon_setpermissions(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 4) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: setpermissions 0xaddr [0|1 :clear or set] [P|W|U]\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	 </span><br><span class="line">	//将地址字符串转换int，然后判断低12位是不是0</span><br><span class="line">	uint32_t va = jz_xtoi(argv[1]);</span><br><span class="line">	if((va &amp; 0xfff) != 0 )&#123;</span><br><span class="line">		cprintf(&quot;Make sure the addr&apos;s low 12 bits is zero\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte_t *pte = pgdir_walk((pde_t *)KADDR(rcr3()),(void *)va,false);</span><br><span class="line">	if (pte &amp;&amp; (*pte &amp; PTE_P))&#123;  </span><br><span class="line">		cprintf(&quot;before setpermissions %p\n&quot;,va);</span><br><span class="line">		cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">			va, *pte, *pte&amp;PTE_P, *pte&amp;PTE_W, *pte&amp;PTE_U);			</span><br><span class="line">		uint32_t perm = 0;</span><br><span class="line">	    if (argv[3][0] == &apos;P&apos;) perm = PTE_P;</span><br><span class="line">	    if (argv[3][0] == &apos;W&apos;) perm = PTE_W;</span><br><span class="line">	    if (argv[3][0] == &apos;U&apos;) perm = PTE_U;</span><br><span class="line">	    if (argv[2][0] == &apos;0&apos;)  //clear</span><br><span class="line">	        *pte = *pte &amp; ~perm;</span><br><span class="line">	    else    //set</span><br><span class="line">	        *pte = *pte | perm;</span><br><span class="line">	    cprintf(&quot;after setpermissions %p\n&quot;,va);</span><br><span class="line">		cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">			va, *pte, *pte&amp;PTE_P, *pte&amp;PTE_W, *pte&amp;PTE_U);		</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/7.JPG" title="setpermissions执行结果"><br>3、代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">mon_dumpcontents(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 4) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: dumpcontents [p|v :physical or virtual] 0x3000 10\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	  </span><br><span class="line">	void** begin = NULL;</span><br><span class="line">	long length = strtol(argv[3],0,0);</span><br><span class="line">	uint32_t i; </span><br><span class="line"> 	if (argv[1][0] == &apos;p&apos;) &#123;</span><br><span class="line">		begin = (void**)(jz_xtoi(argv[2]) + KERNBASE);  </span><br><span class="line">	&#125; else if (argv[1][0] == &apos;v&apos;) &#123;  </span><br><span class="line">		begin = (void**)(jz_xtoi(argv[2])); </span><br><span class="line">	&#125;</span><br><span class="line">	if(begin &gt; begin + length)&#123;</span><br><span class="line">		cprintf(&quot;out of memory.\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">    for (i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">        cprintf(&quot;va at %x is %x\n&quot;, begin+i, begin[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于指针的指针可以参考C语言指针部分的博客。上述设计思想是：指针所加内容是指针存储的地址，所加范围是由指针指向的对象类型决定。因此，二级指针<code>begin+i</code>所加内容是二级指针存储的一级指针地址，所加范围是由二级指针所指向的一级指针决定，即每次加4个字节。<code>begin[i]</code>是<code>*(begin+i)</code>，即一级指针的内容。因此，这里是将内存内容当作一级指针内容看待！ </p>
<h2 id="Changeling3"><a href="#Changeling3" class="headerlink" title="Changeling3"></a>Changeling3</h2><p>操作系统一般会映射内核到低线性地址上，留下高地址部分给用户程序。x86内核由于存在向后兼容的虚拟8086模式，处理器会“硬连线式”使用线性空间的低地址部分，所以即使内核映射在那里也无法使用所有映射地址。但是，可以通过设计内核，不再为内核保存任何固定的线性地址部分，允许用户级进程整个无限制使用4GB的虚拟地址空间，同时还从这些进程中充分保护内核，和保护相互不同的进程。请写出满足上述要求的内核设计大纲（相关技术可称为follow the bouncing kernel），明确指出处理器在内核和用户模式之间转换会发生什么，描述内核会如何访问物理内存和IO设备，以及如何通过系统调用访问用户环境的虚拟地址空间。最后从灵活性、性能、内核的复杂性等阐述该方案的优缺点**  </p>
<h2 id="Changeling4"><a href="#Changeling4" class="headerlink" title="Changeling4"></a>Changeling4</h2><p>jos系统是从页粒度上分配和释放内存，但没有通用的malloc/free工具。如果我们要支持某些类型的I/O设备，它们需要物理上大于4KB的连续缓冲区，或者如果我们为了最大的处理器效率，需要在用户级环境（不仅仅是内核）上分配和映射4MB的superpages，那么将会产生问题。请概括出一个内核内存分配系统，支持管理2的幂大小的页，分配单元大小从4KB至一个合理大小值。确保存在将大分配单元按需求切分为小单元和将小单元合并为大单元的方案。**</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/自学项目/" rel="tag"># 自学项目</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/20/笔记04-HW02-boot-xv6/" rel="next" title="笔记04 - HW02: boot xv6">
                <i class="fa fa-chevron-left"></i> 笔记04 - HW02: boot xv6
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/20/笔记06-x86-v6-book-Chapter-1-Operating-system-organization/" rel="prev" title="笔记06 - x86 v6 book | Chapter 1 Operating system organization">
                笔记06 - x86 v6 book | Chapter 1 Operating system organization <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      
        <div onclick="ShowGitment()" id="gitment-display-button">显示 Gitment 评论</div>
        <div id="gitment-container" style="display:none"></div>
      
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-1-Physical-Page-Management"><span class="nav-number">1.</span> <span class="nav-text">Part 1: Physical Page Management</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景知识"><span class="nav-number">1.1.</span> <span class="nav-text">背景知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以下是物理内存管理设计思想"><span class="nav-number">1.2.</span> <span class="nav-text">以下是物理内存管理设计思想</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-2-Virtual-Memory"><span class="nav-number">2.</span> <span class="nav-text">Part 2: Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景知识-1"><span class="nav-number">2.1.</span> <span class="nav-text">背景知识</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-3-Kernel-Address-Space"><span class="nav-number">3.</span> <span class="nav-text">Part 3: Kernel Address Space</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Changeling1"><span class="nav-number">3.1.</span> <span class="nav-text">Changeling1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changeling2"><span class="nav-number">3.2.</span> <span class="nav-text">Changeling2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changeling3"><span class="nav-number">3.3.</span> <span class="nav-text">Changeling3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changeling4"><span class="nav-number">3.4.</span> <span class="nav-text">Changeling4</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
