<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="自学项目,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="The UVPTx86将虚拟地址转换为物理地址：CR3指向页目录，PDX是页目录索引，PTX是二级页表索引。对于处理器而言，并没有页目录、页表、页的概念，相反它只负责计算：pd = lcr3(); pt = (pd+4PDX); page = (pt+4PTX);页目录是“特殊”的页表，假设我们在页目录中某一索引项V存储页目录本身的地址：当设计PDX=PTX=V时，则可以通过pd = lcr3()">
<meta name="keywords" content="自学项目">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记011 - Lab3: User Environments">
<meta property="og:url" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="The UVPTx86将虚拟地址转换为物理地址：CR3指向页目录，PDX是页目录索引，PTX是二级页表索引。对于处理器而言，并没有页目录、页表、页的概念，相反它只负责计算：pd = lcr3(); pt = (pd+4PDX); page = (pt+4PTX);页目录是“特殊”的页表，假设我们在页目录中某一索引项V存储页目录本身的地址：当设计PDX=PTX=V时，则可以通过pd = lcr3()">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/1.png">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/2.PNG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/3.PNG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/4.PNG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/5.PNG">
<meta property="og:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/6.PNG">
<meta property="og:updated_time" content="2019-06-12T12:04:32.145Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记011 - Lab3: User Environments">
<meta name="twitter:description" content="The UVPTx86将虚拟地址转换为物理地址：CR3指向页目录，PDX是页目录索引，PTX是二级页表索引。对于处理器而言，并没有页目录、页表、页的概念，相反它只负责计算：pd = lcr3(); pt = (pd+4PDX); page = (pt+4PTX);页目录是“特殊”的页表，假设我们在页目录中某一索引项V存储页目录本身的地址：当设计PDX=PTX=V时，则可以通过pd = lcr3()">
<meta name="twitter:image" content="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/">





  <title>笔记011 - Lab3: User Environments | 蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">笔记011 - Lab3: User Environments</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:14:27+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="The-UVPT"><a href="#The-UVPT" class="headerlink" title="The UVPT"></a>The UVPT</h1><p>x86将虚拟地址转换为物理地址：CR3指向页目录，PDX是页目录索引，PTX是二级页表索引。对于处理器而言，并没有页目录、页表、页的概念，相反它只负责计算：<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong><br>页目录是“特殊”的页表，假设我们在页目录中某一索引项V存储页目录本身的地址：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/1.png" title="x86将虚拟地址转换为物理地址"><br>当设计PDX=PTX=V时，则可以通过<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong>后可以获得页目录的某一项。在jos中，V=0x3BD，所以<strong>(0x3BD&lt;&lt;22)|(0x3BD&lt;&lt;12) = 0xef400000 = UVPD</strong>。当PDX=V而PTX!=V时，通过<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong>后将指向到某一个页表的某一项，即：所有PDX=V的虚拟页刚好是所有页表本身，在jos中，V=0x3BD，所以<strong>UVPT = (0x3BD&lt;&lt;22) = 0xef400000</strong>，从该地址起的4M虚拟地址空间映射了jos的所有页表。设计UVPT的意义即在于通过虚拟地址可以访问到页表，但其前提在于<strong>在页目录中索引项V存储页目录本身的地址</strong>。</p>
<h1 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h1><p>在本实验中，术语<strong>environment</strong>和<strong>process</strong>是可以互换的，两者都是允许运行程序的一个抽象。jos的<strong>environment</strong>和unix的<strong>process</strong>提供不同的接口，因此提供了不同的语义，jos更加强调<strong>environment</strong>而不是<strong>process</strong>。<br>关于environment，jos提供了三个全局变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//kern/env.c</span><br><span class="line">struct Env *envs = NULL;		// All environments</span><br><span class="line">struct Env *curenv = NULL;		// The current env</span><br><span class="line">static struct Env *env_free_list;	// Free environment list</span><br></pre></td></tr></table></figure></p>
<p>jos内核最多支持“同时”执行NENV（inc/env.h）个活跃环境，所有不活跃的Env数据结构保存在<code>env_free_list</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//inc/env.h</span><br><span class="line">struct Env &#123;</span><br><span class="line">	struct Trapframe env_tf;	// Saved registers</span><br><span class="line">	struct Env *env_link;		// Next free Env</span><br><span class="line">	envid_t env_id;			// Unique environment identifier</span><br><span class="line">	envid_t env_parent_id;		// env_id of this env&apos;s parent</span><br><span class="line">	enum EnvType env_type;		// Indicates special system environments</span><br><span class="line">	unsigned env_status;		// Status of the environment</span><br><span class="line">	uint32_t env_runs;		// Number of times environment has run</span><br><span class="line"></span><br><span class="line">	// Address space</span><br><span class="line">	pde_t *env_pgdir;		// Kernel virtual address of page dir</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>env_tf</code>：见inc/trap.h，当环境没被执行时（即当前执行内核代码或其他环境的代码），保存了环境的被保存的寄存器值。内核在从用户态切换到内核态的时候保存这些寄存器，确保环境可以被恢复执行。<br><code>env_link</code>：连接到下一个Env，该Env位于<code>env_free_list</code>上，<code>env_free_list</code>上指向第一个空闲的环境。<br><code>env_id</code>：当前使用Env数据结构的环境的唯一标识。当一个用户环境终止时，内核可以重新分配相同的Env数据结构给不同的环境，但是<code>env_id</code>不会相同。<br><code>env_parent_id</code>：创建本环境的父环境id，可用于构建“family tree”，进而安全控制哪个环境可以对其他哪些环境做什么任务。<br><code>env_type</code>：用于区分特殊的环境，大部分时候是<code>ENV_TYPE_USER</code>。<br><code>env_status</code>：以下几种值之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENV_FREE：表明Env数据结构不活跃，位于env_free_list中。</span><br><span class="line">ENV_RUNNABLE：表明Env数据结构所代表的环境正等待处理器执行。</span><br><span class="line">ENV_RUNNING：表明Env数据结构所代表的环境正被执行。</span><br><span class="line">ENV_NOT_RUNNABLE：表明Env数据结构所代表的环境是活跃的，但还不能执行，比如它正在等待其他环境的interprocess communication (IPC)。</span><br><span class="line">ENV_DYING：表明Env数据结构所代表的环境是一个zombie。下一次trap到内核的时候，zombie环境将被释放。</span><br></pre></td></tr></table></figure></p>
<p><code>env_pgdir</code>：保存了环境的页目录的内核虚拟地址。  </p>
<p><strong>与unix对比</strong>：jos的<strong>environment</strong>也包含了<strong>thread</strong>和<strong>address space</strong>两个概念，<strong>thread</strong>的定义主要是被保存的寄存器（<code>env_tf</code>），<strong>address space</strong>的定义主要是页目录和页表的指向（<code>env_pgdir</code>）。<br><strong>与xv6对比</strong>：jos的<strong>struct Env</strong>类似于xv6的<strong>proc</strong>，两者都保存了用户模式寄存器状态，但是jos的环境并没有自己的内核栈，因为jos一次只有一个环境是活跃的，所以只需要一个内核栈。</p>
<h2 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h2><p><code>i386_init()</code>函数之后，并没有进入循环，而是相应的对进程结构初始化和中断初始化，<code>i386_init()</code>函数最后会调用<code>env_run(&amp;envs[0])</code>；运行一个进程。一个进程的执行不能对内核（kernel）和其他进程产生干扰，当进程执行特权指令时，需要处理器产生中断，从用户态切换到内核态，完成任务后中断返回到用户态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 1.修改kern/pmap.c中mem_init()函数，分配并映射envs数组（NENV instances），参考pages数组的分配和映射。pages数组基址映射到UPAGES虚拟地址，envs数组基址映射到UENVS虚拟地址，两者的二级页表项权限都是用户只读，用户环境不能修改数组本身。顺利完成的话将通过check_kern_pgdir()检查。</span><br></pre></td></tr></table></figure></p>
<p>解决方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//pmap.c</span><br><span class="line">                                   ...</span><br><span class="line">	//////////////////////////////////////////////////////////////////////</span><br><span class="line">	// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	envs = (struct Env*)boot_alloc(NENV*sizeof(struct Env));</span><br><span class="line">	memset(envs,0,NENV*sizeof(struct Env)); </span><br><span class="line">                                   ...</span><br><span class="line">	//////////////////////////////////////////////////////////////////////</span><br><span class="line">	// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</span><br><span class="line">	// (ie. perm = PTE_U | PTE_P).</span><br><span class="line">	// Permissions:</span><br><span class="line">	//    - the new image at UENVS  -- kernel R, user R</span><br><span class="line">	//    - envs itself -- kernel RW, user NONE</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	boot_map_region(kern_pgdir,UENVS,PTSIZE,PADDR(envs),PTE_U | PTE_P);</span><br><span class="line">                                   ...</span><br></pre></td></tr></table></figure></p>
<p>这里注意到一个问题：pages和envs本身作为内核代码的数组，拥有自己的虚拟地址，且内核可对其进行读写。<code>boot_map_region</code>函数将两个数组分别映射到了UPAGES和UENVS起4M空间的虚拟地址，这相当于另外的映射镜像，其二级页表项权限被设为用户/内核可读，因此通过UPAGES和UENVS的虚拟地址去访问pages和envs的话，只能读不能写。<br>页面管理空间的布局情况如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/2.PNG" title="页面管理空间"></p>
<h2 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h2><p>由于还没实现文件系统，因此没办法从inode里读取程序内容，而是设置成由内核加载内嵌到内核的静态二进制镜像，且为ELF可执行格式，将嵌入到内核中的用户程序取出释放到相应链接器指定好的用户虚拟空间里。如果想了解二进制文件怎么连接进内核里，可以在build 内核之后查看kern/Makefrag、obj/kern/kernel.sym等文件。在JOS系统里面，采用和管理页相同的方式来管理进程，即用一个进程表来管理所有的进程，空闲的进程通过<code>env_link</code>相连接，用<code>env_free_list</code>指向空闲进程表的头节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exercise 2.在kern/env.c中完成以下函数：</span><br><span class="line">env_init()：初始化进程数据结构数组，将所有数据结构加到env_free_list上。调用env_init_percpu函数为特权级别0(内核)和特权级别3(用户)将段式硬件配以单独的段。</span><br><span class="line">env_setup_vm()：分配页目录，初始化进程的内核部分地址空间。</span><br><span class="line">region_alloc()：分配和映射物理空间。</span><br><span class="line">load_icode()：解析ELF二进制镜像，加载进新进程的地址空间。</span><br><span class="line">env_create()：通过env_alloc分配一个新进程，调用load_icode加载ELF二进制镜像。</span><br><span class="line">env_run()：在用户模式下执行新进程。</span><br></pre></td></tr></table></figure>
<p>进程的管理方法和页面的管理方法是相同的，都是用一组结构体的数组来管理，在这种管理的方式下，对于空闲进程的申请和添加，只需要用<code>env_free_list</code>这个参数就可以了。进程表的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	// Set up envs array</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	env_free_list = NULL;  </span><br><span class="line">    int i;  </span><br><span class="line">    for( i = NENV -1; i&gt;=0; i--)&#123;  </span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_id = 0;  </span><br><span class="line">        envs[i].env_link = env_free_list;  </span><br><span class="line">        env_free_list = &amp;envs[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">	// Per-CPU part of the initialization</span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个用户进程的建立:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//init.c</span><br><span class="line">ENV_CREATE(user_hello, ENV_TYPE_USER);</span><br><span class="line"></span><br><span class="line">//env.h</span><br><span class="line">#define ENV_PASTE3(x, y, z) x ## y ## z</span><br><span class="line"></span><br><span class="line">#define ENV_CREATE(x, type)						\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[];	\</span><br><span class="line">		env_create(ENV_PASTE3(_binary_obj_, x, _start),		\</span><br><span class="line">			   type);					\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_create(uint8_t *binary, enum EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	struct Env *newEnv;</span><br><span class="line">	//Allocates a new env </span><br><span class="line">	int i = env_alloc(&amp;newEnv,0);</span><br><span class="line">	if(i&lt;0) panic(&quot;env_create&quot;);</span><br><span class="line">	//loads the named elf binary into</span><br><span class="line">	load_icode(newEnv,binary);</span><br><span class="line">	//set env_type</span><br><span class="line">	newEnv-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>env_alloc</code>向进程表申请空闲的进程，在<code>env_alloc</code>的函数中，向进程表申请空闲的进程，对新申请的进程的struct Env(进程描述符)进行初始化，主要是对段寄存器的初始化。内核要开始的第一个用户进程不是通过中断等方法来进入到内核的，而是由内核直接载入的。对进程的进程描述符进行初始化，是为了模仿int x指令的作用，模拟第一个进程是通过中断进入了内核，在内核处理完了相应的操作之后，才返回用户态的。<strong>xv6的做法是也是类似载入程序内容后对进程的进程描述符进行初始化，不过它之后是通过int指令来中断，执行exec。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">int</span><br><span class="line">env_alloc(struct Env **newenv_store, envid_t parent_id)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t generation;</span><br><span class="line">	int r;</span><br><span class="line">	struct Env *e;</span><br><span class="line"></span><br><span class="line">	if (!(e = env_free_list))</span><br><span class="line">		return -E_NO_FREE_ENV;</span><br><span class="line"></span><br><span class="line">	// Allocate and set up the page directory for this environment.</span><br><span class="line">	if ((r = env_setup_vm(e)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line"></span><br><span class="line">	//todo...?????????????????????</span><br><span class="line">	// Generate an env_id for this environment.</span><br><span class="line">	generation = (e-&gt;env_id + (1 &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - 1);</span><br><span class="line">	if (generation &lt;= 0)	// Don&apos;t create a negative env_id.</span><br><span class="line">		generation = 1 &lt;&lt; ENVGENSHIFT;</span><br><span class="line">	e-&gt;env_id = generation | (e - envs);</span><br><span class="line"> </span><br><span class="line">	// Set the basic status variables.</span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = 0;</span><br><span class="line"></span><br><span class="line">	// Clear out all the saved register state,</span><br><span class="line">	// to prevent the register values</span><br><span class="line">	// of a prior environment inhabiting this Env structure</span><br><span class="line">	// from &quot;leaking&quot; into our new environment.</span><br><span class="line">	memset(&amp;e-&gt;env_tf, 0, sizeof(e-&gt;env_tf)); //env_tf是Trapframe结构体，不是Trapframe结构体指针!</span><br><span class="line"> </span><br><span class="line">	// Set up appropriate initial values for the segment registers.</span><br><span class="line">	// GD_UD is the user data segment selector in the GDT, and</span><br><span class="line">	// GD_UT is the user text segment selector (see inc/memlayout.h).</span><br><span class="line">	// The low 2 bits of each segment register contains the</span><br><span class="line">	// Requestor Privilege Level (RPL); 3 means user mode.  When</span><br><span class="line">	// we switch privilege levels, the hardware does various</span><br><span class="line">	// checks involving the RPL and the Descriptor Privilege Level</span><br><span class="line">	// (DPL) stored in the descriptors themselves.</span><br><span class="line">	e-&gt;env_tf.tf_ds = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_es = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_ss = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">	e-&gt;env_tf.tf_cs = GD_UT | 3;</span><br><span class="line">	// You will set e-&gt;env_tf.tf_eip later.</span><br><span class="line"></span><br><span class="line">	// commit the allocation</span><br><span class="line">	env_free_list = e-&gt;env_link;</span><br><span class="line">	*newenv_store = e;</span><br><span class="line"> </span><br><span class="line">	cprintf(&quot;env_id, %x\n&quot;, e-&gt;env_id);</span><br><span class="line">	cprintf(&quot;[%08x] new env %08x\n&quot;, curenv ? curenv-&gt;env_id : 0, e-&gt;env_id);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>env_setup_vm</code>创建进程页目录。<strong>在xv6中，每个进程都有自己的内核栈，进程的trapframe也是存在内核栈中。但是jos中用户进程是使用同一个内核栈虚拟地址的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static int</span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	struct PageInfo *p = NULL;</span><br><span class="line"></span><br><span class="line">	// Allocate a page for the page directory</span><br><span class="line">	if (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		return -E_NO_MEM;</span><br><span class="line"> </span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	//在没有具体的映射之前，物理地址都是直接加上KERNBASE作为虚拟地址的!!!</span><br><span class="line">	//内核空间的变量的虚拟地址也是如此</span><br><span class="line">	e-&gt;env_pgdir = (pde_t *) page2kva(p); //pa + KERNBASE !!!!!!</span><br><span class="line">	p-&gt;pp_ref = 1;</span><br><span class="line">	//use kern_pgdir as a template</span><br><span class="line">	/*</span><br><span class="line">	由于每个用户进程都需要共享内核空间，所以对于用户进程而言，在UTOP以上的部分，和系统内核的空间是完全一样的。</span><br><span class="line">	因此在pgdir开始设置的时候，只需要在一级页表目录上，把共享部分的一级页表目录部分复制进用户进程的地址空间就可以了，</span><br><span class="line">	这样，就实现了页面的共享。因为一级页目录里面存储的是二级页表目录的物理地址，其直接映射到物理内存部分，</span><br><span class="line">	而共享的内核部分的二级页目录在前期的内核操作中，已经完成了映射，所以二级页目录是不需要初始化的。</span><br><span class="line">	简单来说，不需要映射二级页表的原因是，用户进程可以和内核共用这些二级页表。</span><br><span class="line"></span><br><span class="line">	UTOP以下部分清空: 注意4G虚拟地址空间是由低到高每4M按顺序映射到页目录的一项的，因此需要取出UTOP的PDX索引部分，将前PDX项清空。</span><br><span class="line">	*/</span><br><span class="line">	memcpy(e-&gt;env_pgdir,kern_pgdir,PGSIZE);</span><br><span class="line">	memset(e-&gt;env_pgdir,0,UTOP &gt;&gt; PTSHIFT);</span><br><span class="line"></span><br><span class="line">	// UVPT maps the env&apos;s own page table read-only.</span><br><span class="line">	// Permissions: kernel R, user R</span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>load_icode</code>将用户进程的文件载入内存。由于还没有实现文件系统，所以用户进程实际的存放的位置实际上是在内存中的，文件载入内存，实际上是内存之间的数据的复制而已。程序载入内存的时候，需要把pgdir设置为用户进程的页目录，这样，这些程序才会载入用户进程所属的地址空间，而且在载入的过程中，根据elf文件中程序头表中载入内存的va和memsz，还需要为用户空间申请新的地址映射，在这个过程中，会建立新的页表。加载完ELF文件之后，为进程再申请一页物理页作为用户栈，并映射到USTACKTOP - PGSIZE，之前tampframe的esp也指向了USTACKTOP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static void</span><br><span class="line">load_icode(struct Env *e, uint8_t *binary)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	struct Elf *elf = (struct Elf *)binary;</span><br><span class="line">	if (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(&quot;load_icode&quot;); </span><br><span class="line">	struct Proghdr *ph = (struct Proghdr *)(binary+elf-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; elf-&gt;e_phnum; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		if(ph-&gt;p_type != ELF_PROG_LOAD) &#123;//不可载入段  </span><br><span class="line">			ph++;</span><br><span class="line">		 	continue;</span><br><span class="line">		&#125;</span><br><span class="line">		//xv6分配用户空间是连续的, 给出起始地址va和结束地址，然后ROUNDUP(va)，根据结束地址分配了足够的页空间，</span><br><span class="line">		//va的值是结束地址，而不是当前空间顶端。读取下一段的时候，新的开始地址是上次结束地址, 新的结束地址是ph.vaddr + ph.memsz。 </span><br><span class="line">		//jos分配用户空间不是连续的,而是根据ph-&gt;p_va作为每次的开始地址，以p_memsz为长度进行页分配。</span><br><span class="line">		region_alloc(e,(void*)ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">		//read into env&apos;s memory , need env&apos;s pgdir</span><br><span class="line">		memcpy((char*)ph-&gt;p_va,(char*)(binary + ph-&gt;p_offset),ph-&gt;p_filesz);</span><br><span class="line">		ph++;</span><br><span class="line">	&#125;</span><br><span class="line">	// Now map one page for the program&apos;s initial stack</span><br><span class="line">	// at virtual address USTACKTOP - PGSIZE.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	region_alloc(e,(void*)USTACKTOP - PGSIZE,PGSIZE);</span><br><span class="line"></span><br><span class="line">	//todo...binary的数据位于内核空间的哪个节？</span><br><span class="line">	e-&gt;env_tf.tf_eip = elf-&gt;e_entry;  // main </span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到一个现象，加载程序分配用户空间时，<strong>在xv6中，分配的地址空间是连续的，进程的用户地址空间也是通过加载过程中分配的地址空间范围来决定。而在jos中，用户空间是不一定连续的，每次在加载段的时候，都是从新的段虚拟地址开始映射，不关心之前段的结束地址。jos中也没有设置进程的地址空间大小。因此，jos和xv6为进程分配物理空间的函数有些不同，xv6会记录上次分配的结束地址，而jos不会。</strong><code>region_alloc</code>为va申请物理空间，并且完成映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static void</span><br><span class="line">region_alloc(struct Env *e, void *va, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	if(ROUNDUP((pte_t)va + len, PGSIZE) &gt;= KERNBASE)&#123; </span><br><span class="line">    	panic(&quot;region_alloc panic, out of memory1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int npages = (ROUNDUP((pte_t)va + len, PGSIZE) - ROUNDDOWN((pte_t)va, PGSIZE)) / PGSIZE;  </span><br><span class="line">	struct PageInfo *p = NULL; </span><br><span class="line">	int i=0;</span><br><span class="line">  	for(; i&lt;npages; i++)&#123;</span><br><span class="line">                //加上ALLOC_ZERO标志则物理页内容初始化为&apos;\0&apos;，如果这里没有初始化，则最好在分配物理页并且将内容拷贝进来后，将剩余的空间置0</span><br><span class="line">		if (!(p = page_alloc(ALLOC_ZERO)))&#123;</span><br><span class="line">			 panic(&quot;region_alloc panic, out of memory2&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//map, use page_insert</span><br><span class="line">		if(page_insert(e-&gt;env_pgdir,p,(void*)((pte_t)va+i*PGSIZE),PTE_U|PTE_W)!=0)&#123;</span><br><span class="line">			panic(&quot;region_alloc panic, out of memory3&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">  	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后<code>env_run</code>开始准备运行进程，先切换到用户进程的地址空间，然后调用<code>env_pop_tf</code>载入寄存器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	// Step 1: If this is a context switch (a new environment is running):</span><br><span class="line">	//	   1. Set the current environment (if any) back to</span><br><span class="line">	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="line">	//	      what other states it can be in),</span><br><span class="line">	//	   2. Set &apos;curenv&apos; to the new environment,</span><br><span class="line">	//	   3. Set its status to ENV_RUNNING,</span><br><span class="line">	//	   4. Update its &apos;env_runs&apos; counter,</span><br><span class="line">	//	   5. Use lcr3() to switch to its address space.</span><br><span class="line">	// Step 2: Use env_pop_tf() to restore the environment&apos;s</span><br><span class="line">	//	   registers and drop into user mode in the</span><br><span class="line">	//	   environment. </span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	if(!e) panic(&quot;env_run panic&quot;); </span><br><span class="line">	if(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	&#125;	</span><br><span class="line">	curenv = e;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">	e-&gt;env_runs += 1;</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); </span><br><span class="line"></span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));//never return  </span><br><span class="line">	//panic(&quot;env_run not yet implemented&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">env_pop_tf(struct Trapframe *tf)  </span><br><span class="line">&#123;  </span><br><span class="line">    __asm __volatile(&quot;movl %0,%%esp\n&quot;  </span><br><span class="line">        &quot;\tpopal\n&quot;  </span><br><span class="line">        &quot;\tpopl %%es\n&quot;  </span><br><span class="line">        &quot;\tpopl %%ds\n&quot;  </span><br><span class="line">        &quot;\taddl $0x8,%%esp\n&quot; /* skip tf_trapno and tf_errcode */  </span><br><span class="line">        &quot;\tiret&quot;  </span><br><span class="line">        : : &quot;g&quot; (tf) : &quot;memory&quot;);  </span><br><span class="line">    panic(&quot;iret failed&quot;);  /* mostly to placate the compiler */  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>movl %0,%%esp</strong>，这里出现了占位符%0，通过后面的参数可以看到这里的占位符代表的意思是memory中的变量tf，即Trapframe的指针地址。iret之后发生特权级的改变(即由内核态转到了用户态)，所以iret总共会压出5个寄存器，依次是eip、cs、eflags、esp、ss，即iret会从栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器，然后弹出esp和ss寄存器的值，这些函数在<code>env_alloc()</code>以及<code>load_icode()</code>中都设置好了，其中EIP为用户程序入口地址，CS为用户程序代码段基地址。完成iret之后，eip就指向了程序的入口地址，cs也由内核态转向了用户态， esp也由内核栈转到了用户栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调试技巧：</span><br><span class="line">调用env_pop_tf后，将开始执行用户代码，并且不会返回。使用b *0x...在env_pop_tf处设置断点，然后单步调试直至执行用户代码。参考obj/user/hello.asm，在sys_cputs()中的int $0x30处设置断点，如果以上函数补充正确的话，运行至此的指令均不会出错。下面将对中断进行处理。</span><br></pre></td></tr></table></figure>
<h2 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h2><p>在没有实现系统调用之前，处理器一旦进入用户模式将没有办法返回。只有实现基本的异常和系统调用处理，才能使内核从用户模式代码中恢复内核对处理器的控制。另外，诸如异常、陷阱、中断、错误、中止（exception, trap, interrupt, fault, abort）等概念，在架构或操作系统中并没有标准意义，因此在一个特定的体系结构中如xv6，经常不考虑它们之间的细微差别。</p>
<h2 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h2><p>exceptions和interrupts都是“protected control transfers”（受保护控制转移）的，它们将导致处理器从用户态切换为内核态，但用户代码不会影响其他进程以及内核。在Intel的术语中，<strong>interrupt</strong>通常指由外部异步事件引起的受保护控制转移（外部是相对于处理器而言），如外部设备I/O活动的通知，<strong>exception</strong>通常指由当前执行代码同步引起的受保护控制转移，如除0或非法内存访问。<br>为了保护控制转移，处理器仅在一定的控制条件下允许进入内核。x86使用两种保护机制：<strong>1、中断描述符表IDT，2、任务状态段TSS。</strong><br><strong>中断描述符表interrupt descriptor table</strong>：x86允许多达256个不同的中断或异常的内核入口点，每一个都有不同的中断向量。一个向量是一个0到255之间的数字。IDT表设置在内核的私有内存中，CPU使用向量在IDT表中进行索引，找到入口点后，处理器将会加载对应的值到eip（instruction pointer register）中，该值指向处理异常的内核代码，同时加载对应的值到cs（code segment register）中，该值的0-1位表明了执行异常处理代码的特权级别。<strong>在jos中，所有异常都在内核模式下处理，特权级别为0。</strong><br><strong>任务状态段TSS</strong>：处理器需要在调用执行异常处理代码之前保存好旧寄存器的状态，保证异常处理完毕后能恢复用户代码的执行。当interrupt或trap导致从用户态到内核态的特权级别改变时，x86处理器还将切换到内核内存的栈。task state segment即TSS指定了段选择子（ss）和栈地址（esp）。处理器将在新的栈上push SS、ESP、EFLAGS、CS、EIP，和一个可选的error code，然后从中断描述符加载cs和ip，并设置esp和ss引用新的栈。TSS可以用于各种各样的目的，但jos只使用它来定义处理器从用户模式切换到内核模式后的内核栈。因为jos的内核模式在特权级别0上，所以处理器使用ESP0和SS0来定义进入内核模式的内核栈。<strong>不同于xv6的设计，jos只用一个内核栈地址，其栈顶被映射到KSTACKTOP上，而xv6的每一个进程都有对应的内核栈。</strong><br><strong>TSS描述的是一个task在执行中的状态信息，重在描述代码切换之间权限的转换，用于保护机制。Env对应的是一个用户进程的状态，主要用于保持用户进程的独立，这里的进程是一个抽象程度较高的概念，包括PCB(jos中 evns 数组就等价于 PCB 表)、地址空间等，不仅仅是一段用户程序代码。</strong><br>TSS结构如下所示：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/3.PNG" title="TSS结构"></p>
<h2 id="Exceptions-and-Interrupts-Example"><a href="#Exceptions-and-Interrupts-Example" class="headerlink" title="Exceptions and Interrupts Example"></a>Exceptions and Interrupts Example</h2><p>假设处理器正在执行用户进程代码，并遇到了一条尝试除以0的divide指令：<br>1、处理器切换到TSS指定的SS0和ESP0指向的栈，jos中分别是GD_KD和KSTACKTOP。<br>2、处理器将相关寄存器保存到内核栈，从KSTACKTOP开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>3、除0异常在x86上是中断向量0，处理器读取IDT表的第0项，根据该项描述的信息设置CS:EIP，指向处理函数。<br>4、处理函数获得控制权，开始处理异常，比如终止用户进程。</p>
<p>对于某些x86异常，处理器可能会将错误码进栈，比如页错误。布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20</span><br><span class="line">|     error code     |     &quot; - 24 &lt;---- ESP</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，将相关寄存器（和某些异常的错误码）保存到内核栈后，处理器才读取IDT表，寻找处理函数。</strong></p>
<h2 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h2><p>处理器可以处理来自内核或用户模式的中断和异常。只有由用户模式切换到内核模式的时候，处理器才会在保存旧寄存器之前自动切换栈，并根据IDT调用合适的处理函数。如果中断或异常发生的时候，处理器已经处于内核模式（<strong>CS的低2位为0</strong>），将只在原来的栈上保存数据。这种情况下处理器可以优雅地处理由内核代码本身引起的内嵌异常。这种能力也是实施保护的工具，详见后面系统调用。<br>如果处理器已经在内核模式中且需要处理一个内嵌的异常，因为不需要切换栈，处理器不保存旧SS或ESP寄存器。对于不会导致错误码进栈的异常，进入异常处理程序的时候内核栈的样子如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>对于需要将错误码进栈的异常，进入异常处理程序的时候内核栈的样子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">|     error code     |     &quot; - 16 </span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>假如处理器处于内核模式，且由于某些原因（如缺乏栈空间）导致无法保存处理器的旧状态，那么处理器将没有办法恢复原先状态。内核应该设计为不会发生这种情况。</p>
<p>JOS 系统中断过程的控制流如下所示：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/4.PNG" title="JOS 系统中断过程的控制流"></p>
<h2 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h2><p>kern/trap.h包含了内核专属的定义，inc/trap.h包含了用户级别的程序和库可用的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exercise 4: 在kern/trapentry.S中定义每个中断对应的中断处理程序，在kern/trap.c中根据定义好的中断处理程序初始化IDT。</span><br><span class="line">每个中断对应的中断处理程序实际上是在内核栈中设置好Trapframe的布局结构，然后将这个结构传递给trap()函数进行处理，最后在trap_dispatch()中进行具体中断处理程序的分发。</span><br></pre></td></tr></table></figure></p>
<p>关于中断处理程序的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */ </span><br><span class="line"> #define TRAPHANDLER(name, num)						\</span><br><span class="line"> 	.globl name;		/* define global symbol for &apos;name&apos; */	\</span><br><span class="line"> 	.type name, @function;	/* symbol type is function */		\</span><br><span class="line"> 	.align 2;		/* align function definition */		\</span><br><span class="line"> 	name:			/* function starts here */		\</span><br><span class="line"> 	pushl $(num);							\</span><br><span class="line"> 	jmp _alltraps</span><br><span class="line"></span><br><span class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</span><br><span class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="line"> * format in either case.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)					\</span><br><span class="line">	.globl name;							\</span><br><span class="line">	.type name, @function;						\</span><br><span class="line">	.align 2;							\</span><br><span class="line">	name:								\</span><br><span class="line">	pushl $0;							\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br></pre></td></tr></table></figure></p>
<p>这两个宏的功能是接受一个函数名和中断向量编号，定义出相应的以该函数名命名的中断处理程序，中断处理程序的执行流程是向栈里压入相关错误码和中断号，然后跳转到_alltraps把Trapframe剩下的部分在栈中设置好。对于某些中断，处理器将向栈中放入对应的中断错误码。当系统没有放入错误码的时候，中断处理函数则使用<code>TRAPHANDLER_NOEC</code>手动补齐。<code>当用户使用int指令手动调用中断时，处理器不会放入错误码。</code>具体的中断处理程序定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */  </span><br><span class="line">TRAPHANDLER_NOEC(entry_point0,T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point1,T_DEBUG) </span><br><span class="line">TRAPHANDLER_NOEC(entry_point2,T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point3,T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point4,T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point5,T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point6,T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point7,T_DEVICE)</span><br><span class="line">TRAPHANDLER(entry_point8,T_DBLFLT)</span><br><span class="line"># TRAPHANDLER(entry_point9,T_COPROC)</span><br><span class="line">TRAPHANDLER(entry_point10,T_TSS)</span><br><span class="line">TRAPHANDLER(entry_point11,T_SEGNP)</span><br><span class="line">TRAPHANDLER(entry_point12,T_STACK)</span><br><span class="line">TRAPHANDLER(entry_point13,T_GPFLT)</span><br><span class="line">TRAPHANDLER(entry_point14,T_PGFLT)</span><br><span class="line"># TRAPHANDLER(entry_point15,T_RES)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point16,T_FPERR) </span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(entry_point48,T_SYSCALL) </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line"> .globl _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">  # Build trap frame. //将用户进程的寄存器保存</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es </span><br><span class="line">  pushal</span><br><span class="line">  //load GD_KD into %ds and %es</span><br><span class="line">  movw $(GD_KD), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es </span><br><span class="line">  pushl %esp</span><br><span class="line">  call trap</span><br><span class="line"></span><br><span class="line"># entry point table</span><br><span class="line">.data</span><br><span class="line">.globl entry_points</span><br><span class="line">entry_points:</span><br><span class="line">  .long entry_point0</span><br><span class="line">  .long entry_point1</span><br><span class="line">  .long entry_point2</span><br><span class="line">  .long entry_point3</span><br><span class="line">  .long entry_point4</span><br><span class="line">  .long entry_point5</span><br><span class="line">  .long entry_point6</span><br><span class="line">  .long entry_point7</span><br><span class="line">  .long entry_point8</span><br><span class="line">#  .long entry_point9</span><br><span class="line">  .long 0   #attendion: instead we should fill the hole with 0, or it will cause entry_points array&apos;s wrong index</span><br><span class="line">  .long entry_point10</span><br><span class="line">  .long entry_point11</span><br><span class="line">  .long entry_point12</span><br><span class="line">  .long entry_point13</span><br><span class="line">  .long entry_point14</span><br><span class="line">#  .long entry_point15</span><br><span class="line">  .long 0   #attendion: instead we should fill the hole with 0, or it will cause entry_points array&apos;s wrong index</span><br><span class="line">  .long entry_point16</span><br><span class="line">  .long 0   </span><br><span class="line">...</span><br><span class="line">  .long entry_point48</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>为了方便，将中断处理程序函数名定义到函数名数组<code>entry_points</code>中。之后初始化IDT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c</span><br><span class="line">void</span><br><span class="line">trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	extern struct Segdesc gdt[];</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	/*</span><br><span class="line">	 * add by jianzzz</span><br><span class="line">	 */</span><br><span class="line">	//entry_points store handler-function&apos;s address</span><br><span class="line">	extern uint32_t entry_points[]; //see in trapentry.S</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; 16; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		if (i==T_BRKPT)</span><br><span class="line">			SETGATE(idt[i], 0, GD_KT, entry_points[i], 3)</span><br><span class="line">		else if(i!=9 &amp;&amp; i!=15)</span><br><span class="line">			SETGATE(idt[i],0,GD_KT,entry_points[i],0);//todo...why GD_KT???  </span><br><span class="line">	&#125; </span><br><span class="line">	SETGATE(idt[T_SYSCALL],0,GD_KT,entry_points[T_SYSCALL],3); </span><br><span class="line">	// Per-CPU setup </span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SETGATE第三个参数cs设为内核的代码段<code>GD_KT</code>。最后一个参数是用户特权级。到此为止，就完成了中断响应机制的建立。<br>中断处理过程图示如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/5.PNG" title="中断处理过程"><br>中断门格式如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/6.PNG" title="中断门"><br>其结构 struct Gatedesc 是在 inc/mmu.h 中定义的。由其结构可知，中断或异常也有特权级别，由中断门描述符中的 DPL 约束，门描述符中的段选择子中的 CPL 说明中断处理程序运行的特权级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Questions:</span><br><span class="line">1、为什么需要设计为每一个中断/异常都有单独的中断处理程序？如果所有的中断/异常都传递到相同的处理程序，会丢失什么特性？（这里指的中断处理程序是指跳转到_alltraps之前的处理过程）</span><br><span class="line">中断处理程序在真正的处理之前会将中断号放入内核栈以组织成Trapframe的结构，如果所有的中断/异常都跳到同一个处理程序，那么无法正确设置中断/异常的中断号等。</span><br><span class="line">2、user/softint程序的预想结果是抛出general protection fault (trap 13)，但程序代码是执行int $14，如果内核实际允许该程序执行int $14并调用页错误处理程序，会发生什么情况？</span><br><span class="line">中断向量14 Page fault的调用权限为0，只能由内核抛出，直接在softint中用int指令调用将会产生一般保护错误。</span><br></pre></td></tr></table></figure>
<h1 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h1><h2 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h2><p>当处理器遇到页错误时，会将导致页错误的线性地址保存到处理器控制寄存器CR2中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 5.修改trap_dispatch()，将页错误分发给page_fault_handler()处理。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123;</span><br><span class="line">	case (T_PGFLT):</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>
<h2 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h2><p>中断向量3(<strong>T_BRKPT</strong>)断点异常通常是用于允许调试器通过用单字节的int3软件中断指令临时替换相关程序指令的方式在程序代码中插入断点。jos中我们将这个异常变成一个粗糙的系统调用，任何用户程序都可以调用它从而嵌入到jos内核监控，在这个角度上jos相当于一个粗糙的调试器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 6.修改trap_dispatch()，使得断点异常嵌入到内核监控程序。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_BRKPT):</span><br><span class="line">		//print_trapframe(tf);</span><br><span class="line">		monitor(tf);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">//see in kern/trap.c, trap_init() </span><br><span class="line">    if (i==T_BRKPT)</span><br><span class="line">        SETGATE(idt[i], 0, GD_KT, entry_points[i], 3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 熟悉EFLAGS，修改jos内核监控程序，当因为int3发生断点中断嵌入内核监控的时候，能够在当前位置执行“continue”操作和一次单步执行一条指令。</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://www.zhihu.com/question/40555332/answer/87130016?from=profile\_answer\_card" target="_blank" rel="noopener">https://www.zhihu.com/question/40555332/answer/87130016?from=profile\_answer\_card</a> ，一般情况下，在指令被执行前，断点指令会产生调试异常，如果异常处理程序在返回前没有移除断点的话，处理器在重启指令之前会再次发现断点，进而生成另一个调试异常。为了防止重复进入调试中断，Intel 64和IA-32架构使用RF标志控制处理器对指令断点的响应。RF置1则禁用断点指令产生调试异常，但是其它情况仍可以产生调试异常。RF置0则断点指令会产生调试异常。调试软件必须在用IRETD指令返回到被中断程序之前，将栈中的EFLAGES映象中的该位置为1，以阻止断点指令产生另外的调试异常。在返回并成功执行断点指令之后，处理器会自动清零该位，从而允许继续通过断点指令产生调试异常。<br>在jos中，情况有所不同。jos遇到断点指令后直接陷入了监控程序，而不会产生调试异常，因此跟RF没有什么关系。为了能够单步调试，需要EFLAGS的TF(Trap Flag)跟踪标志，置1则开启单步执行调试模式，置0则关闭。在单步执行模式下，处理器在每条指令后产生一个调试异常，这样在每条指令执行后都可以查看执行程序的状态。当然，为了达到观察每次调试结果，我们也同样需要将调试异常嵌入内核监控。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_DEBUG):</span><br><span class="line">		//print_trapframe(tf);</span><br><span class="line">		monitor(tf);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">//see in kern/monitor.c</span><br><span class="line">int mon_continue(int argc,char **argv,struct Trapframe *tf)&#123; </span><br><span class="line">	uint32_t eflags;</span><br><span class="line">	if(tf==NULL)&#123; </span><br><span class="line">		cprintf(&quot;No trapped environment\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	eflags=tf-&gt;tf_eflags; </span><br><span class="line">	eflags &amp;= ~FL_TF; </span><br><span class="line">	tf-&gt;tf_eflags=eflags; </span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mon_step(int argc,char **argv,struct Trapframe *tf)&#123; </span><br><span class="line">	uint32_t eflags;</span><br><span class="line">	if(tf==NULL)&#123; </span><br><span class="line">		cprintf(&quot;No trapped environment\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	eflags=tf-&gt;tf_eflags;</span><br><span class="line">	eflags |= FL_TF; </span><br><span class="line">	tf-&gt;tf_eflags=eflags;  </span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设<code>mon_continue</code>对应的指令的continue，<code>mon_step</code>对应的指令是step。那么每次执行step的话，就相当于执行一次单步调试，这是因为：当我们执行int3时，eip记录了int3指令的下一条用户指令的位置，然后断点异常嵌入内核监控，此时如果输入step，内核会执行对应的<code>mon_step</code>函数，设置TF标志，然后返回-1；由于返回-1，内核会跳出监控程序返回用户程序，执行eip所指向的用户指令，记录下一条指令位置，然后发生调试异常嵌入内核监控，重复上述步骤即相当于每次执行一次单步调试。我们可以借助eip值和用户程序的asm文件查看每次执行的用户指令。如果输入continue会发生什么事呢：由于用户程序由lib/entry.S开始执行，然后调用lib/libmain.c中的libmain函数，可以看到最后libmain函数会调用exit，因此如果输入continue将会返回用户程序，最终触发一次系统调用并结束用户程序。</p>
<h2 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h2><p>jos的系统调用是通过int 0x30实现的。程序将会使用寄存器传递系统调用号和系统调用参数，这样就不需要在用户环境的栈或指令流中进行查找。系统调用号存在%eax中，系统调用参数存在%edx, %ecx, %ebx, %edi, %esi中，最多传递5个参数。<strong>xv6使用宏定义将用户调用转换为系统调用，并使用用户栈传递参数；不同于xv6，用户程序调用系统调用时，jos通过汇编指令同时完成参数传递和调用转换，见lib/syscall.c</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//see in lib/syscall.c</span><br><span class="line">//用户代码通过该接口进行系统调用</span><br><span class="line">static inline int32_t</span><br><span class="line">syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t ret;</span><br><span class="line"></span><br><span class="line">	// Generic system call: pass system call number in AX,</span><br><span class="line">	// up to five parameters in DX, CX, BX, DI, SI.</span><br><span class="line">	// Interrupt kernel with T_SYSCALL.</span><br><span class="line">	//</span><br><span class="line">	// The &quot;volatile&quot; tells the assembler not to optimize</span><br><span class="line">	// this instruction away just because we don&apos;t use the</span><br><span class="line">	// return value.</span><br><span class="line">	//</span><br><span class="line">	// The last clause tells the assembler that this can</span><br><span class="line">	// potentially change the condition codes and arbitrary</span><br><span class="line">	// memory locations.</span><br><span class="line"></span><br><span class="line">	asm volatile(&quot;int %1\n&quot;</span><br><span class="line">		: &quot;=a&quot; (ret)</span><br><span class="line">		: &quot;i&quot; (T_SYSCALL),</span><br><span class="line">		  &quot;a&quot; (num),</span><br><span class="line">		  &quot;d&quot; (a1),</span><br><span class="line">		  &quot;c&quot; (a2),</span><br><span class="line">		  &quot;b&quot; (a3),</span><br><span class="line">		  &quot;D&quot; (a4),</span><br><span class="line">		  &quot;S&quot; (a5)</span><br><span class="line">		: &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line"></span><br><span class="line">	if(check &amp;&amp; ret &gt; 0)</span><br><span class="line">		panic(&quot;syscall %d returned %d (&gt; 0)&quot;, num, ret);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exercise 7.为系统调用添加处理程序，包括：</span><br><span class="line">1、kern/trapentry.S定义“预先”处理程序。</span><br><span class="line">2、kern/trap.c的trap_init()函数初始化idt表。</span><br><span class="line">3、trap_dispatch()调用syscall()，执行系统调用。</span><br><span class="line">4、实现kern/syscall.c的syscall()。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)				\</span><br><span class="line">	.globl name;						\</span><br><span class="line">	.type name, @function;					\</span><br><span class="line">	.align 2;						\</span><br><span class="line">	name:							\</span><br><span class="line">	pushl $0;						\</span><br><span class="line">	pushl $(num);						\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">TRAPHANDLER_NOEC(entry_point48,T_SYSCALL) </span><br><span class="line"></span><br><span class="line">//see in kern/trap.c, trap_init()</span><br><span class="line">SETGATE(idt[T_SYSCALL],0,GD_KT,entry_points[T_SYSCALL],3); </span><br><span class="line"></span><br><span class="line">//see in kern/trap.c,trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_SYSCALL):</span><br><span class="line">		ret_code = syscall(</span><br><span class="line">			tf-&gt;tf_regs.reg_eax,</span><br><span class="line">			tf-&gt;tf_regs.reg_edx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">			tf-&gt;tf_regs.reg_edi,</span><br><span class="line">			tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = ret_code;//attention</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">/see in kern/syscall.c, syscall()</span><br><span class="line">int32_t</span><br><span class="line">syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</span><br><span class="line">&#123;</span><br><span class="line">	// Call the function corresponding to the &apos;syscallno&apos; parameter.</span><br><span class="line">	// Return any appropriate return value.</span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	//panic(&quot;syscall not implemented&quot;);</span><br><span class="line"></span><br><span class="line">	switch (syscallno) &#123;</span><br><span class="line">	case SYS_cputs:&#123;</span><br><span class="line">		sys_cputs((char *)a1,a2); //refer to lib/syscall.c</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_cgetc:&#123;</span><br><span class="line">		return sys_cgetc();</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_getenvid:&#123;</span><br><span class="line">		return sys_getenvid();</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_env_destroy:&#123;</span><br><span class="line">		return sys_env_destroy(a1);</span><br><span class="line">	&#125;</span><br><span class="line">	case NSYSCALLS:</span><br><span class="line">	default:</span><br><span class="line">		return -E_NO_SYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 使用sysenter和sysexit指令代替int 0x30和iret指令来实现系统调用。sysenter/sysexit的速度快于int/iret，因为使用了寄存器而不是栈。jos中可以这样实现：在kern/trapentry.S中添加sysenter_handler，用以保存返回用户程序的信息、设置内核环境、将syscall()参数进栈，然后直接调用syscall()。syscall()返回时，设置好返回信息后执行sysexit指令。同时，在kern/init.c设置model specific registers (MSRs)，可参考Section 6.1.2 in Volume 2 of the AMD Architecture Programmer&apos;s Manual和the reference on SYSENTER in Volume 2B of the Intel reference manuals。最后，lib/syscall.c必须支持sysenter指令。</span><br><span class="line">使用sysenter时，寄存器的布局可能是：</span><br><span class="line">	eax                - syscall number</span><br><span class="line">	edx, ecx, ebx, edi - arg1, arg2, arg3, arg4</span><br><span class="line">	esi                - return pc</span><br><span class="line">	ebp                - return esp</span><br><span class="line">	esp                - trashed by sysenter</span><br><span class="line">GCC的内联汇编程序将在被直接告知加载值的时候自动保存寄存器。内联汇编程序不支持保存%ebp，需要添加代码来保存和恢复。返回地址可以通过使用类似于leal after_sysenter_label, %%esi的指令存在%esi中。</span><br><span class="line">注意到这个方法最多支持4个参数，不同于原来可支持5个参数的方法。另外这个方法不更新当前进程的trapframe，不适合后续lab添加的一些system call。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h2><p>用户程序由lib/entry.S开始执行，经过一些设置之后调用lib/libmain.c中的libmain函数。libmain函数会调用umain，umain是用户程序的主函数入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 8. lib/entry.S已经定义envs指向UENVS，需要在libmain函数中初始化全局变量thisenv指向当前进程的struct Env结构，用户程序通过thisenv获取进程的相关信息。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//see in lib/libmain.c</span><br><span class="line">void</span><br><span class="line">libmain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	// set thisenv to point at our Env structure in envs[].</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	thisenv = 0; </span><br><span class="line">	//envs see in inc/lib.h</span><br><span class="line">	thisenv = &amp;envs[ENVX(sys_getenvid())]; </span><br><span class="line">	</span><br><span class="line">	// save the name of the program so that panic() can use it</span><br><span class="line">	if (argc &gt; 0)</span><br><span class="line">		binaryname = argv[0];</span><br><span class="line"></span><br><span class="line">	// call user main routine</span><br><span class="line">	umain(argc, argv); //see in user/*.c</span><br><span class="line"></span><br><span class="line">	// exit gracefully</span><br><span class="line">	exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h2><p>操作系统通常依赖于硬件支持来实现内存保护。当程序试图访问一个无效的或者没有权限的地址，处理器停止导致故障的指令然后陷入到内核。如果故障是可以解决的，内核可以修复它并让程序继续运行。如果故障是不可以解决的，那么程序将不能继续执行，因为引起故障的指令永远不会被越过。<br>故障可以被解决的一个例子是：自动扩展栈。在许多系统中最初只分配了一页的栈空间。当程序错误访问到栈地址时（further down the stack），内核自动分配这些页并且恢复程序执行。基于此，内核按需分配栈空间，但是程序在拥有任意大栈的“错觉”下正常工作。<br>系统调用给内核留下了一个内存保护的问题：许多系统调用接口让用户程序传递指针到内核中，这些指针指向了可读写的用户缓冲区，内核在执行系统调用时会间接引用这些指针。这会引发两个问题：<br>1、在内核中发生页错误比在用户程序中发生页错误更加严重。如果内核在操作自己的数据结构时发生了页错误，页错误处理程序应该panic内核，因为这是内核的bug。但如果是间接引用用户程序传递的指针引起的页错误，需要一种方式记住这些间接引用导致的页错误都是代表用户程序的。<br>2、内核通常比用户程序拥有更多的内存权限。用户程序传递给内核的指针指向的内存对于内核来说可能是可读写的，但对于用户程序来说是不能读写的。内核应当注意不要暴露一些私有信息或破坏内核完整性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 9. 解决上述两个问题。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">问题1的解决：在kern/trap.c的page_fault_handler函数中识别页错误是发生在内核模式还是用户模式中（判断tf_cs的低2位），如果是内核模式，直接panic；如果是用户模式，销毁进程。</span><br><span class="line">//see in kern/trap.c</span><br><span class="line">void</span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">	// Read processor&apos;s CR2 register to find the faulting address</span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	// Handle kernel-mode page faults.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	if ((tf-&gt;tf_cs&amp;3) == 0)</span><br><span class="line">		panic(&quot;Kernel page fault!&quot;);</span><br><span class="line">	// We&apos;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="line">	// the page fault happened in user mode.</span><br><span class="line"></span><br><span class="line">	// Destroy the environment that caused the fault.</span><br><span class="line">	cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">问题2的解决：查看kern/pmap.c的user_mem_assert函数，并实现user_mem_check。然后在kern/syscall.c中检查系统调用的参数。user_mem_check函数主要是根据给定的权限查看给定的[va, va+len)是否有对应的访问权限。</span><br><span class="line">//see in kern/pmap.c</span><br><span class="line">//</span><br><span class="line">// Check that an environment is allowed to access the range of memory</span><br><span class="line">// [va, va+len) with permissions &apos;perm | PTE_P&apos;.</span><br><span class="line">// Normally &apos;perm&apos; will contain PTE_U at least, but this is not required.</span><br><span class="line">// &apos;va&apos; and &apos;len&apos; need not be page-aligned; you must test every page that</span><br><span class="line">// contains any of that range.  You will test either &apos;len/PGSIZE&apos;,</span><br><span class="line">// &apos;len/PGSIZE + 1&apos;, or &apos;len/PGSIZE + 2&apos; pages.</span><br><span class="line">//</span><br><span class="line">// A user program can access a virtual address if (1) the address is below</span><br><span class="line">// ULIM, and (2) the page table gives it permission.  These are exactly</span><br><span class="line">// the tests you should implement here.</span><br><span class="line">//</span><br><span class="line">// If there is an error, set the &apos;user_mem_check_addr&apos; variable to the first</span><br><span class="line">// erroneous virtual address.</span><br><span class="line">//</span><br><span class="line">// Returns 0 if the user program can access this range of addresses,</span><br><span class="line">// and -E_FAULT otherwise.</span><br><span class="line">//</span><br><span class="line">int</span><br><span class="line">user_mem_check(struct Env *env, const void *va, size_t len, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	cprintf(&quot;user_mem_check va: %x, len: %x\n&quot;, va, len);</span><br><span class="line">	uint32_t begin = (uint32_t)ROUNDDOWN((char*)va,PGSIZE);</span><br><span class="line">	uint32_t end = (uint32_t)ROUNDUP((char*)(va+len),PGSIZE);</span><br><span class="line">	uint32_t i=0;</span><br><span class="line">	for(i=begin;i&lt;end;i+=PGSIZE)&#123;</span><br><span class="line">		pte_t *pte = pgdir_walk(env-&gt;env_pgdir,(void *)i,false);</span><br><span class="line">		if(i&gt;=ULIM || !pte || !(*pte &amp; PTE_P) || (*pte &amp; perm) != perm)&#123;</span><br><span class="line">			user_mem_check_addr = (i&lt;(uint32_t)va?(uint32_t)va:i);</span><br><span class="line">			return -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(&quot;user_mem_check success va: %x, len: %x\n&quot;, va, len);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Checks that environment &apos;env&apos; is allowed to access the range</span><br><span class="line">// of memory [va, va+len) with permissions &apos;perm | PTE_U | PTE_P&apos;.</span><br><span class="line">// If it can, then the function simply returns.</span><br><span class="line">// If it cannot, &apos;env&apos; is destroyed and, if env is the current</span><br><span class="line">// environment, this function will not return.</span><br><span class="line">//</span><br><span class="line">void</span><br><span class="line">user_mem_assert(struct Env *env, const void *va, size_t len, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	if (user_mem_check(env, va, len, perm | PTE_U) &lt; 0) &#123;</span><br><span class="line">		cprintf(&quot;[%08x] user_mem_check assertion failure for &quot;</span><br><span class="line">			&quot;va %08x\n&quot;, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">		env_destroy(env);	// may not return</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//see in kern/syscall.c</span><br><span class="line">// Print a string to the system console.</span><br><span class="line">// The string is exactly &apos;len&apos; characters long.</span><br><span class="line">// Destroys the environment on memory errors.</span><br><span class="line">static void</span><br><span class="line">sys_cputs(const char *s, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	// Check that the user has permission to read memory [s, s+len).</span><br><span class="line">	// Destroy the environment if not.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	//see in kern/env.c : int	envid2env(envid_t envid, struct Env **env_store, bool checkperm);</span><br><span class="line">	//struct Env* e ;</span><br><span class="line">	//envid2env(sys_getenvid(),&amp;e,1);</span><br><span class="line">	user_mem_assert(curenv, s, len, PTE_U);//see in kern/pmap.c</span><br><span class="line">	// Print the string supplied by the user.</span><br><span class="line">	cprintf(&quot;%.*s&quot;, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p>1、二进制文件怎么连接进内核里？<br>2、如何生成唯一pid？以及pid与ENVX的关系<br>3、binary的数据位于内核空间的哪个节？<br>4、为什么所有中断都设置为中断门？<br>5、Exercise 7的Challenge实现<br>6、实际用户程序编译之后的地址与所谓的段选择子:偏移的对应关系？<br>7、各种门的使用情况</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/自学项目/" rel="tag"># 自学项目</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/20/笔记10-HW4-xv6-lazy-page-allocation/" rel="next" title="笔记10 - HW4: xv6 lazy page allocation">
                <i class="fa fa-chevron-left"></i> 笔记10 - HW4: xv6 lazy page allocation
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/" rel="prev" title="笔记012 - x86 v6 book | Chapter 3 Traps, interrupts, and drivers">
                笔记012 - x86 v6 book | Chapter 3 Traps, interrupts, and drivers <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      
        <div onclick="ShowGitment()" id="gitment-display-button">显示 Gitment 评论</div>
        <div id="gitment-container" style="display:none"></div>
      
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#The-UVPT"><span class="nav-number">1.</span> <span class="nav-text">The UVPT</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-A-User-Environments-and-Exception-Handling"><span class="nav-number">2.</span> <span class="nav-text">Part A: User Environments and Exception Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Allocating-the-Environments-Array"><span class="nav-number">2.1.</span> <span class="nav-text">Allocating the Environments Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Creating-and-Running-Environments"><span class="nav-number">2.2.</span> <span class="nav-text">Creating and Running Environments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-Interrupts-and-Exceptions"><span class="nav-number">2.3.</span> <span class="nav-text">Handling Interrupts and Exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basics-of-Protected-Control-Transfer"><span class="nav-number">2.4.</span> <span class="nav-text">Basics of Protected Control Transfer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exceptions-and-Interrupts-Example"><span class="nav-number">2.5.</span> <span class="nav-text">Exceptions and Interrupts Example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nested-Exceptions-and-Interrupts"><span class="nav-number">2.6.</span> <span class="nav-text">Nested Exceptions and Interrupts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Setting-Up-the-IDT"><span class="nav-number">2.7.</span> <span class="nav-text">Setting Up the IDT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><span class="nav-number">3.</span> <span class="nav-text">Part B: Page Faults, Breakpoints Exceptions, and System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-Page-Faults"><span class="nav-number">3.1.</span> <span class="nav-text">Handling Page Faults</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Breakpoint-Exception"><span class="nav-number">3.2.</span> <span class="nav-text">The Breakpoint Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-calls"><span class="nav-number">3.3.</span> <span class="nav-text">System calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#User-mode-startup"><span class="nav-number">3.4.</span> <span class="nav-text">User-mode startup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-faults-and-memory-protection"><span class="nav-number">3.5.</span> <span class="nav-text">Page faults and memory protection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#遗留的问题"><span class="nav-number">4.</span> <span class="nav-text">遗留的问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
