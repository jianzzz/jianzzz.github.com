<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝色步行者">
<meta property="og:url" content="http://www.jianzzz.com/page/4/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓝色步行者">
<meta name="twitter:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/page/4/">





  <title>蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/24/K-R-Chapter-5-Pointers-and-Arrays/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/K-R-Chapter-5-Pointers-and-Arrays/" itemprop="url">K&R Chapter 5. Pointers and Arrays</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T22:29:53+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《5-1-Pointers-and-Addresses》"><a href="#《5-1-Pointers-and-Addresses》" class="headerlink" title="《5.1 Pointers and Addresses》"></a>《5.1 Pointers and Addresses》</h1><p><code>*ip += 1</code> 将ip指向的内容加1，等同于 <code>++*ip</code> 和 <code>(*ip)++</code>，其中 <code>(*ip)++</code> 的括号是必须的，<strong>因为*和++都是由右往左联合</strong>。</p>
<h1 id="《5-2-Pointers-and-Function-Argument》"><a href="#《5-2-Pointers-and-Function-Argument》" class="headerlink" title="《5.2 Pointers and Function Argument》"></a>《5.2 Pointers and Function Argument》</h1><p>C使用按值传递的方式传递参数给函数。被调用函数 the called function 无法通过直接的方式改变调用函数 the calling function 的变量。</p>
<h1 id="《5-3-Pointers-and-Arrays》"><a href="#《5-3-Pointers-and-Arrays》" class="headerlink" title="《5.3 Pointers and Arrays》"></a>《5.3 Pointers and Arrays》</h1><p>假设int a[10]和int *pa，<strong>pa = &amp;a[O]</strong>，则pa和a的值一样。<br>因为数组的名字是最初的元素位置的同义词，所以<strong>pa = &amp;a[O]</strong>可以写成<strong>pa = a</strong>。</p>
<p>a[i]可以写成<em>(a+i)，**C会间接将a[i]转化为`</em>(a+i)<code>**。&amp;a[i]等同于a+i。简单来讲， **array-and-index 的表达式等价于写成 a pointer and offset 的表达式**。</code>[]<code>优先级高于</code><em><code>，X[ii][j]等价于</code>(</em>(X+ii))[j]<code>但不等价于</code>*(X+ii)[j]`。</p>
<p>指针和数组名的区别：指针是变量，pa=a和pa++是合法的；数组名不是变量，a=pa和a++是不合法的。传递一个数组名给函数时，传递的是首元素的位置，对被调用函数而言，该函数参数就是一个指针，一个包含地址的变量。</p>
<p><code>int a[5]={1,2,3,4,5};int *ptr=(int *)(&amp;a+1);</code> 数组名就是数组0号元素的地址，a = &amp;a[0]。&amp;a是指向一个有5个整型元素的数组的地址，<code>int *ptr=(int*)(&amp;a+1) =&gt; int *ptr=(int*)(a地址 + sizeof(a));</code>，<code>sizeof(a) = 5*sizeof(int)</code>。而<code>printf(&quot;%p\n&quot;, iArry);</code>和<code>printf(&quot;%p\n&quot;, &amp;iArry);</code>输出的地址值是一致的，这说明底层实现并没有为二级指针创建临时变量什么的，而只是在计算一级指针和二级指针的方式上有所区别。</p>
<h1 id="《5-4-Address-Arithmetic》"><a href="#《5-4-Address-Arithmetic》" class="headerlink" title="《5.4 Address Arithmetic》"></a>《5.4 Address Arithmetic》</h1><p><strong>指针和整数不能互换</strong>，0则是特例，指针可被赋值0，也可以和0作比较。C保证 0 永远不会是数据的合法地址，可以通过返回 0 (函数返回值为指针类型)来标识异常事件。符号常量NULL定义于stdio.h，代表一个指针的特殊值，经常用于代替0。</p>
<p>当两个指针指向不同的数组时，指针之间的运算或比较是未定义的。但存在一个特例：超出数组末端的第一个元素的地址可以用于指针运算，如：<strong>int array[10]; int* a = array + 10;</strong></p>
<p>指针减法：指向相同数组的两个指针p和q，如果p &lt; q，q-p+1将返回从p到q的元素个数。</p>
<h1 id="《5-5-Character-Pointers-and-Functions》"><a href="#《5-5-Character-Pointers-and-Functions》" class="headerlink" title="《5.5 Character Pointers and Functions》"></a>《5.5 Character Pointers and Functions》</h1><p>strcpy函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array版本</span><br><span class="line">/* strcpy: copy t to s; array subscript version */</span><br><span class="line">void strcpy(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    i = 0;</span><br><span class="line">    while ((s[i] = t[i]) != &apos;\0&apos;)</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pointers版本1</span><br><span class="line">/* strcpy: copy t to s; pointer version 1 */</span><br><span class="line">void strcpy(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    while ((*s = *t) != &apos;\0&apos;) &#123;</span><br><span class="line">        s++;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointers版本2</span><br><span class="line">/* strcpy: copy t to s; pointer version 2 */</span><br><span class="line">void strcpy(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    while (( *s++ = *t++) != &apos;\0&apos; )</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pointers版本3</span><br><span class="line">/* strcpy: copy t to s; pointer version 3 */</span><br><span class="line">void strcpy(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    while (*s++ = *t++)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strcmp函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array版本</span><br><span class="line">/* strcmp: return &lt;0 if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */</span><br><span class="line">int strcmp(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; s[i] == t[i]; i++)</span><br><span class="line">        if (s[i] == &apos;\0&apos;)</span><br><span class="line">            return 0;</span><br><span class="line">    return s[i] - t[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pointers版本</span><br><span class="line">/* strcmp: return &lt;0 if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */</span><br><span class="line">int strcmp(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *s == *t; s++, t++)</span><br><span class="line">        if (*s == &apos;\0&apos; )</span><br><span class="line">            return 0;</span><br><span class="line">    return *s - *t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习5-3：实现strcat(s,t)函数(Chapters 2)的指针版本，将字符串t复制到s的末端。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(*s++); /* Get to the end of the string */</span><br><span class="line">    s--;           /*get back to the end of the string.*/</span><br><span class="line">while((*s++ = *t++));</span><br></pre></td></tr></table></figure></p>
<p><strong>练习5-4：实现strend(s,t)函数，如果字符串t出现在s的末端，返回1，否则返回0。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int strend(char *s, char *t)</span><br><span class="line">&#123;</span><br><span class="line">        char *sc = s;</span><br><span class="line">        char *tc = t;</span><br><span class="line"></span><br><span class="line">        while (*s != &apos;\0&apos;)</span><br><span class="line">                s++;</span><br><span class="line">        while (*t != &apos;\0&apos;)</span><br><span class="line">                t++;</span><br><span class="line">        while (s &gt; sc &amp;&amp; t &gt; tc &amp;&amp; *s-- == *t--) ;</span><br><span class="line">        return (t == tc &amp;&amp; *s == *t ? 1 : 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>练习5-5：实现strncpy(s,t,n)、strncat(s,t,n)、strncmp(s,t,n)函数，至多操作参数字符串的前n个字符。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">char *_strncpy(char *s, const char *ct, size_t n) &#123;</span><br><span class="line">	char *p;</span><br><span class="line"></span><br><span class="line">	p = s;</span><br><span class="line">	for (; n &gt; 0 &amp;&amp; *ct != &apos;\0&apos;; --n)</span><br><span class="line">		*p++ = *ct++;</span><br><span class="line">	for (; n &gt; 0; --n)</span><br><span class="line">		*p++ = &apos;\0&apos;;</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">char *_strncat(char *s, const char *ct, size_t n) &#123;</span><br><span class="line">	char *p;</span><br><span class="line"></span><br><span class="line">	p = s;</span><br><span class="line">	while (*p != &apos;\0&apos;)</span><br><span class="line">		++p;</span><br><span class="line">	for (; n &gt; 0 &amp;&amp; *ct != &apos;\0&apos;; --n)</span><br><span class="line">		*p++ = *ct++;</span><br><span class="line">	*p = &apos;\0&apos;;</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">//库函数strncmp(&quot;a&quot;, &quot;b&quot;,0)会返回0</span><br><span class="line">int _strncmp(char *s, char *t,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; n&gt;0 &amp;&amp; *s == *t; s++, t++,n--)</span><br><span class="line">        if (*s == &apos;\0&apos; )</span><br><span class="line">            return 0;</span><br><span class="line">    if(n==0 ) return 0;</span><br><span class="line">    return *s - *t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/24/K-R-Chapter-2-Types-Operators-and-Expressions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/K-R-Chapter-2-Types-Operators-and-Expressions/" itemprop="url">K&R Chapter 2. Types, Operators, and Expressions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T22:27:21+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《2-9-Bitwise-operators》"><a href="#《2-9-Bitwise-operators》" class="headerlink" title="《2.9 Bitwise operators》"></a>《2.9 Bitwise operators》</h1><h2 id="逻辑位移和算术位移"><a href="#逻辑位移和算术位移" class="headerlink" title="逻辑位移和算术位移"></a>逻辑位移和算术位移</h2><p>&lt;&lt; 是左移，&gt;&gt; 是右移，右操作数（right operand）必须为正数。<br>左移都是寄存器二进制位整体向左移动，并在右边补0。<br>右移的话，如果左操作数是无符号数，如unsigned int、unsigned char等，则整体向右移，并在左边补0。如果左操作数是有符号数，如int、char、short等，则整体向右移后，某些机器会在左边补上符号数（算术位移），而某些机器会在左边补上0（逻辑位移）。</p>
<p>在汇编指令中，SHL和SHR表示逻辑左移和逻辑右移，SAR和SAL表示算术左移和算术右移。一般的说法是：如果左操作数是有符号数，编译产生的汇编指令是算术位移指令；如果是无符号数，编译产生的汇编指令则是逻辑位移指令。而根据K&amp;R的说法，应该是：如果左操作数是有符号数，某些机器会生成算术位移指令，而某些机器会生产逻辑位移指令；如果是无符号数，编译产生的汇编指令则是逻辑位移指令。</p>
<p>示例：编写函数getbits(x,p,n)，返回x从位置p开始的n bit（向右对齐）。假设最右端是位置0，n和p都是正数。getbits(x,4,3)返回三个bit，分别是位置4、3、2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* getbits: get n bits from position p */</span><br><span class="line">unsigned getbits(unsigned x, int p, int n)</span><br><span class="line">&#123;</span><br><span class="line">    return (x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习2-6：编写函数setbits(x,p,n,y)，将x中从第p位开始的n个(二进制)位设置为y中最右边n位的值，x的其余各位保持不变。<br>思路是：将x从第p位开始的n个位清零，<strong>x &amp;~(~(~0&lt;&lt; n) &lt;&lt; (p + 1 -n))</strong>；将y的最右边n位移到p位置，其他位清零，<strong>(y &amp; ~(~0 &lt;&lt;n )) &lt;&lt; (p + 1 - n)</strong>；两者相或。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* setbits : set n bits of x at position p with bits of y */</span><br><span class="line">unsigned setbits ( unsigned x, int  p, int n, unsigned y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &amp;~(~(~0&lt;&lt; n) &lt;&lt; (p + 1 -n)) | (y &amp; ~(~0 &lt;&lt;n )) &lt;&lt; (p + 1 - n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习2-7：编写函数invert(x,p,n)，将x从位置p开始的n bit取反，其他位不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned invert(unsigned x, int p, int n)</span><br><span class="line">&#123;</span><br><span class="line">    return x ^ ((~(~0&lt;&lt;n))&lt;&lt; p+1-n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>练习2-8：编写函数rightrot(x,n)，将x向右循环n个位置后返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned rightrot(unsigned x, unsigned n)</span><br><span class="line">&#123;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        if ((x &amp; 1) == 1)</span><br><span class="line">            x = (x &gt;&gt; 1) | ~(~0U &gt;&gt; 1);</span><br><span class="line">        else</span><br><span class="line">            x = (x &gt;&gt; 1);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/24/数组与指针笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/数组与指针笔记/" itemprop="url">数组与指针笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T22:13:45+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">f(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[4];</span><br><span class="line">    int *b = malloc(16);</span><br><span class="line">    int *c;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    printf(&quot;1: a = %p, b = %p, c = %p\n&quot;, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    for (i = 0; i &lt; 4; i++)</span><br><span class="line">        a[i] = 100 + i;</span><br><span class="line">    c[0] = 200;</span><br><span class="line">    printf(&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">       a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">    c[1] = 300;</span><br><span class="line">    *(c + 2) = 301;</span><br><span class="line">    3[c] = 302; /* c 语言数组名和下标可以互换，c[3] 和 3[c] 是一样的*/</span><br><span class="line">    printf(&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">       a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">    c = c + 1;</span><br><span class="line">    *c = 400;</span><br><span class="line">    printf(&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">       a[0], a[1], a[2], a[3]);</span><br><span class="line"></span><br><span class="line">    c = (int *) ((char *) c + 1);</span><br><span class="line">    *c = 500;</span><br><span class="line">    printf(&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">       a[0], a[1], a[2], a[3]);</span><br><span class="line">    /*</span><br><span class="line">        int 占 4 个字节，char 占 1 个字节，c 所指的 int 原来是 400，((char *) c + 1) 以后指向第二个字节，(int *) ((char *) c + 1)后</span><br><span class="line">        占据原来 a[1] 的高 3 字节和 a[2] 的低 1 字节，*c = 500 以后，a[1] 的高 3 字节存储了 500，  a[1] 的低 1 字节保留原来 301 的单字节</span><br><span class="line">        部分，  a[2] 的低 1 字节被置 0 .</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    b = (int *) a + 1;</span><br><span class="line">    c = (int *) ((char *) a + 1);</span><br><span class="line">    printf(&quot;6: a = %p, b = %p, c = %p\n&quot;, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int ac, char **av)</span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="《c和指针》部分抄录"><a href="#《c和指针》部分抄录" class="headerlink" title="《c和指针》部分抄录"></a>《c和指针》部分抄录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下是《c和指针》关于指针的指针的部分抄录：</span><br></pre></td></tr></table></figure>
<p>假设：<br>int a = 12;<br>int *b = &a;<br>int **c = &b;<br>他们在内存中的模样大概是：<br><img src="/2017/08/24/数组与指针笔记/1.JPG" title="指针的指针"><br>利用上述中间的一级指针可以编写代码输出内存内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void** addr = (void**) begin;</span><br><span class="line">for (i = 0; i &lt; n; ++i)</span><br><span class="line">    printf(&quot;VM at %x is %x\n&quot;, addr+i, addr[i]);</span><br></pre></td></tr></table></figure></p>
<p>上述设计思想是：指针所加内容是指针存储的地址，所加范围是由指针指向的对象类型决定。因此，二级指针<code>addr+i</code>所加内容是二级指针存储的一级指针地址，所加范围是由二级指针所指向的一级指针决定，此处一级指针是void <em>，即每次加4个字节（若是有二级指针&amp;a是指向一个有5个整型元素的数组的地址，&amp;a+1就是从a向后跳过一个完整的数组所占用的内存空间）。<code>addr[i]</code>是`</em>(addr+i)`，即一级指针的内容。因此，这里是将内存内容当作一级指针内容看待！</p>
<p>假设：<br>char ch = ‘a’;<br>char <em>cp = &ch;<br>1、</em><code>*++cp</code>: 间接访问操作符作用于增值后的指针的拷贝上，所以它的右值是ch后面那个内存地址的值，而它的左值就是那个位置本身。<br><img src="/2017/08/24/数组与指针笔记/2.JPG" title="*++cp"><br>2.<code>*cp++</code>: 使用后缀++操作符的右值和左值分别是变量ch的值和ch的内存位置，也就是cp原先所指。同样，后缀++操作符在周围的表达式中使用其原先操作数的值。后缀++操作符的优先级高于*操作符，但表达式的结果看上去像是先执行间接访问操作。事实上这里涉及三个步骤：（1）++操作符产生cp的一份拷贝，（2）然后++操作符增加cp的值，（3）最后在cp的拷贝上执行间接访问操作。这个表达式常常在循环中出现，首先用一个数组的地址初始化指针，然后使用这种表达式就可以依次访问该数组的内容了。<br><img src="/2017/08/24/数组与指针笔记/3.JPG" title="*cp++"><br>3.<code>++*cp</code>: 由于这两个操作符的结合性都是从右往左，所以首先执行的是间接访问操作。然后cp所指向的位置的值增加1，表达式的结果是这个增值后的值的一份拷贝。<br><img src="/2017/08/24/数组与指针笔记/4.JPG" title="++*cp"><br>4.<code>(*cp)++</code>: 使用后缀++操作符，我们必须加上括号，使它首先执行间接访问操作，这个表达式的计算过程与前一个表达式相似，但结果值是ch增值前的原先值。<br><img src="/2017/08/24/数组与指针笔记/5.JPG" title="(*cp)++"><br><code>记住两个结论：1、++优先级大于*; 2、后缀++始终返回一份拷贝（可能是指针拷贝）。</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/24/c语言内存对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/c语言内存对齐/" itemprop="url">c语言内存对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T22:10:06+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="结构体对齐原因"><a href="#结构体对齐原因" class="headerlink" title="结构体对齐原因"></a>结构体对齐原因</h1><p>结构体对齐原因有很大部分是因为计算机扫描的内存单元个数，也就是数据总线的大小。<br>内存对齐的问题主要存在于理解struct等复合结构在内存中的存储结构。<br>在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然对界（alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，但不一定是相邻存储，第一个成员的地址和整个结构的地址相同。</p>
<h1 id="对齐的原则"><a href="#对齐的原则" class="headerlink" title="对齐的原则"></a>对齐的原则</h1><p><strong>原则1</strong>：数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员obj存储的起始位置要从该成员obj大小的整数倍开始（比如int在32位机为４字节，则要从4的整数倍地址开始存储）。<br><strong>原则2</strong>：结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储。）<br><strong>原则3</strong>：收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。如果是结构体B包含了结构体A对象a，判断最大成员时并不是a，而是a结构体的最大成员。<br>（补：上述取最大成员的大小后，实际上应该取[#pragma pack指定的数值]与[最大成员的数值]比较小的那个为准）</p>
<p>这三个原则具体怎样理解呢？我们看下面几个例子，通过实例来加深理解。<br>例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">    short a1;</span><br><span class="line">    short a2;</span><br><span class="line">    short a3;</span><br><span class="line">&#125;A;</span><br><span class="line">struct&#123;</span><br><span class="line">    long a1;</span><br><span class="line">    short a2;</span><br><span class="line">&#125;B;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(A) = 6; 这个很好理解，三个short都为2。<br>sizeof(B) = 8; 这个比是不是比预想的大2个字节？long为4，short为2，整个为8，因为原则3。</p>
<p>例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">struct B&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(A) = 8; int为4，char为1，short为2，这里用到了原则1和原则3。<br>sizeof(B) = 12; 是否超出预想范围？char为1，int为4，short为2，怎么会是12？还是原则1和原则3。</p>
<p>深究一下，为什么是这样，我们可以看看内存里的布局情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             a         b        c</span><br><span class="line">A的内存布局：1111,     1*,      11</span><br><span class="line"></span><br><span class="line">             b         a        c</span><br><span class="line">B的内存布局：1***,     1111,    11**</span><br></pre></td></tr></table></figure></p>
<p>其中星号*表示填充的字节。<br>A中，b后面为何要补充一个字节？因为c为short，其起始位置要为2的倍数，就是原则1。c的后面没有补充，因为b和c正好占用4个字节，整个A占用空间为4的倍数，也就是最大成员int类型的倍数，所以不用补充。<br>B中，b是char为1，b后面补充了3个字节，因为a是int为4，根据原则1，起始位置要为4的倍数，所以b后面要补充3个字节。c后面补充两个字节，根据原则3，整个B占用空间要为4的倍数，c后面不补充，整个B的空间为10，不符，所以要补充2个字节。</p>
<p>再看两个结构中含有结构成员的例子：<br>例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int a;</span><br><span class="line">    double b;</span><br><span class="line">    float c;</span><br><span class="line">&#125;;</span><br><span class="line">struct B&#123;</span><br><span class="line">    char e[2];</span><br><span class="line">    int f;</span><br><span class="line">    double g;</span><br><span class="line">    short h;</span><br><span class="line">    struct A i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sizeof(A) = 24; 这个比较好理解，int为4，double为8，float为4，总长为8的倍数，补齐，所以整个A为24。<br>sizeof(B) = 48; 看看B的内存布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">             e    f     g        h        i</span><br><span class="line">B的内存布局：11**,1111, 11111111,11******,1111****, 11111111, 1111****</span><br></pre></td></tr></table></figure></p>
<p>例4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int m1;</span><br><span class="line">    int *m2;</span><br><span class="line">&#125;a;</span><br><span class="line">struct B&#123;</span><br><span class="line">    int m1;</span><br><span class="line">    struct A m2;</span><br><span class="line">&#125;b;</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(a));</span><br><span class="line">printf(&quot;%d\n&quot;,sizeof(b));</span><br></pre></td></tr></table></figure></p>
<p>输出16 24。原则2，A的存储位置将由8开始，所以结构体B的成员b.m2.m1并不会与b.m1同存储于前八个字节中；原则3，结构体的总大小并不是取决于结构体A的大小，而是A结构体的最大成员，所以总大小是24而不是32。</p>
<h1 id="为什么要设计内存对齐"><a href="#为什么要设计内存对齐" class="headerlink" title="为什么要设计内存对齐"></a>为什么要设计内存对齐</h1><p>考虑一个问题，为什么要设计内存对齐的处理方式呢？<br>引入内存对齐的原因一方面在于硬件取指的方便，例如在32位总线系统上，如果一个int变量（4字节）放在一个4的倍数开始的内存地址中，则CPU可以一次将其数值读出，否则的话就要分两次才能读出。另一个重要的原因在于移植性的要求，也就是说不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。引入内存对齐的目的主要是为了可移植性以及最大限度提升硬件性能。详细可参看如下链接<a href="http://www.doc88.com/p-032414262099.html" target="_blank" rel="noopener">http://www.doc88.com/p-032414262099.html</a></p>
<h1 id="设计结构体习惯"><a href="#设计结构体习惯" class="headerlink" title="设计结构体习惯"></a>设计结构体习惯</h1><p>最后顺便提一点，在设计结构体的时候，一般会遵照一个习惯，就是把占用空间小的类型排在前面，占用空间大的类型排在后面，这样可以相对节约一些对齐空间。</p>
<p>另外，测试得知，假如结构体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct execcmd&#123;</span><br><span class="line">	int type;</span><br><span class="line">	char *argv[10];</span><br><span class="line">&#125;;</span><br><span class="line">struct execcmd *cmd;</span><br><span class="line">printf(&quot;%d %d\n&quot;,sizeof(cmd-&gt;argv),sizeof(*cmd));</span><br></pre></td></tr></table></figure></p>
<p>将输出80,88，指针（占8个字节）数组argv开始位置并不是以整个数组为准，而是以数组元素为准。<br>内容引用于：<a href="http://blog.csdn.net/tic_yx/article/details/9718971" target="_blank" rel="noopener">c中的内存对齐</a></p>
<h1 id="关于union大小的计算"><a href="#关于union大小的计算" class="headerlink" title="关于union大小的计算"></a>关于union大小的计算</h1><p>union联合体是可以（在不同时刻）保存不同类型和长度的对象的变量，通过单块的存储区存放不同类型的数据，各个成员分享共同的存储空间，联合的长度由两点决定：（1)要满足大于等于最大的成员长度;(2)且是满足(1)条件下最大的成员类型（union的对齐大小）的最小倍数。<br>存放变量时将会从内存中的同一位置开始，后面的变量将会覆盖以前的变量，但是如果占用的内存小于前者，那么以前未被覆盖的内存存储对象将会保持不变。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记021-Lab5-File-system-Spawn-and-Shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记021-Lab5-File-system-Spawn-and-Shell/" itemprop="url">笔记021 - Lab5: File system, Spawn and Shell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:19:58+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h1><p>jos实现的文件系统要比大多数文件系统简单（包括xv6），主要在分层目录结构的管理下实现文件的增删查改。<br>jos操作系统是单用户的，不提供多用户的保护。因此，jos文件系统不支持UNIX文件所有权和权限的概念，不支持硬链接、符号链接、时间戳或特殊设备文件。</p>
<h1 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h1><p>大多数unix文件系统将磁盘空间分为两种区域类型：inode regions和data regions。unix文件系统为每个文件分配一个inode，文件的inode保存了文件的关键元数据（meta-data）：如stat属性和指向data blocks的指针。data regions被分为8KB或更大的数据块data blocks，用于保存文件数据和目录元数据（directory meta-data）。目录项directory entries包含文件名和指向inodes的指针。假如有多个目录项指向了同一个文件的inodes，说明该文件被hard-linked。由于jos文件系统不支持hard links，所以不需要这种级别的“间接寻址”，jos文件系统不会使用inodes，而是在描述文件的相关目录项中保存文件/子目录的元数据。<br>文件和目录在逻辑上都会关联到一系列data blocks，这些data blocks可能是分散在磁盘上，就好比虚拟地址空间关联到一系列分散的物理页。文件系统隐藏了数据块分布的细节，提供在文件内任意偏移处读写字节序列的接口。对于创建和删除文件等操作，文件系统内部处理了所有相关的目录修改。jos文件系统允许用户进程直接读取目录元数据（e.g., read），用户进程可以自己实现目录浏览（e.g. 实现ls），而不必依赖于特定的文件系统调用接口。这种方法的缺点是应用程序依赖于目录元数据的格式，一旦修改了文件系统的内部布局，应用程序需要作出修改或重新编译。</p>
<h1 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h1><p>大多数磁盘无法支持字节粒度的读写，取而代之的是sector粒度的读写，通常是512字节。文件系统分配和使用磁盘存储的单元是block。sector和block的术语区别是：sector size是磁盘硬件的一个属性，block size则是操作系统使用磁盘所使用的一个概念。文件系统的block size必须是sector size的整数倍。<br>xv6将block size定义为512字节。由于存储空间越来越便宜，而且更大粒度有利于存储管理，所以大多数现代文件系统使用了更大的block size。jos文件系统使用了4096字节大小的block size，方便于匹配页大小。</p>
<h1 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h1><p>文件系统通常在磁盘某个容易寻找的位置保留特定的磁盘块，用于存储文件系统的元数据描述属性。比如：block size、disk size、查找root目录所需的元数据、文件系统上次挂载时间、上次检查磁盘错误的时间等。这些特殊的磁盘块称为superblocks。<br>jos文件系统有一块superblock，位于磁盘的block 1，它的定义是inc/fs.h的struct Super。block 0用于保留启动引导程序和分区表，所以文件系统没有使用它。许多现代的文件系统维护了多个superblocks，并在磁盘的多个位置进行复制，一旦某一个损坏了或其他原因，就可以使用下一个superblock。</p>
<p>磁盘布局如下：<br><img src="/2017/08/20/笔记021-Lab5-File-system-Spawn-and-Shell/1.png" title="disk布局"></p>
<h1 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h1><p>inc/fs.h的struct File定义了描述文件的元数据布局。jos的文件元数据包括文件名、大小、类型（常规文件还是目录）、指向blocks的指针。jos没有inodes，所以文件元数据直接存储在磁盘的目录项中。不像其他文件系统，无论是在磁盘上还是在内存上，jos使用File数据结构来代表文件元数据。</p>
<p>File元数据的格式如下：<br><img src="/2017/08/20/笔记021-Lab5-File-system-Spawn-and-Shell/2.png" title="File元数据的格式"><br>struct File的<code>f_direct</code>数组的前十个成员存储了文件前10个blocks的block numbers，这10个blocks被称为文件的direct blocks。对于小于10*4096 = 40KB的文件，意味着该文件所有blocks的block numbers将直接在File结构上直接匹配。对于更大的文件，则另外分配一个磁盘块以保存4096/4 = 1024个blocks的block number，该磁盘块称为文件的indirect block。因此，文件大小的上限是1034 blocks，大于4M。为了支持更大的文件，其他文件系统通常支持double-indirect和triple-indirect blocks。</p>
<h1 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h1><p>jos的File结构体既可以代表常规文件，也可以代表目录。文件系统以同样的方式管理常规文件和目录文件，除了：文件系统不解析常规文件相关联的数据块内容，但会将目录文件的内容解析为一系列的File结构，用于描述目录中的文件和子目录。<br>superblock包含了一个File结构（struct Super的root区域），用于保存root目录的元数据。该目录文件的内容是一系列File结构，用于描述root目录中的文件和子目录。</p>
<h1 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h1><p>我们主要实现以下关键功能：读取blocks到block cache中、刷新block cache到磁盘中、分配磁盘块、映射文件偏移到磁盘块、实现read/write/open的IPC接口。</p>
<h1 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h1><p>操作系统需要能够访问磁盘，传统的monolithic操作系统策略是在内核中添加IDE磁盘驱动并且提供文件系统访问磁盘所需的系统调用接口，而jos的做法是将IDE磁盘驱动作为用户级别文件系统进程的一部分。需要对内核作轻微修改，确保文件系统进程拥有实现磁盘访问所需的相关特权。<br>依赖轮询和基于可编程输入输出（”programmed I/O” - PIO）的磁盘访问，可以很方便在用户空间实现磁盘访问。jos不使用中断来实现磁盘访问，虽然在用户模式下也可以实现以中断驱动的设备驱动程序，但是内核必须识别设备中断并分配到正确的用户模式进程，难度更大。<br>x86处理器使用了EFLAGS的IOPL位来决定是否允许保护模式代码使用device I/O指令（如IN和OUT指令）。device I/O指令需要访问的所有IDE磁盘寄存器都在x86的I/O space上而不是被内存映射，为了允许文件系统可以访问这些寄存器，我们只需要提供I/O privilege即可。EFLAGS的IOPL位使得内核可以简单地使用”all-or-nothing”方法来控制用户代码是否可以访问I/O space。在jos中，我们将文件系统实现为一个用户进程，其他进程使用IPC与文件系统进程通信，并且只允许文件系统进程访问I/O space，但不允许其他进程访问I/O space。</p>
<p>I/O space请参考 <a href="http://blog.csdn.net/southcamel/article/details/12031705" target="_blank" rel="noopener">I/O space</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 1. i386_init使用了ENV_TYPE_FS来标识文件系统进程，修改env.c的env_create函数，使其能根据ENV_TYPE_FS向文件系统进程给出相关的I/O权限。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//env.c的env_create函数</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">env_create(uint8_t *binary, enum EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here.  </span><br><span class="line">	struct Env *newEnv;</span><br><span class="line">	//Allocates a new env </span><br><span class="line">	int i = env_alloc(&amp;newEnv,0);</span><br><span class="line">	if(i&lt;0) panic(&quot;env_create&quot;);</span><br><span class="line">	//loads the named elf binary into</span><br><span class="line">	load_icode(newEnv,binary);</span><br><span class="line">	//set env_type</span><br><span class="line">	newEnv-&gt;env_type = type;</span><br><span class="line">	</span><br><span class="line">	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span><br><span class="line">	// LAB 5: Your code here.</span><br><span class="line">	if (type == ENV_TYPE_FS)&#123; </span><br><span class="line">		// Give I/O privileges while in file environment. </span><br><span class="line">		newEnv-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question. 是否需要对内核作出什么修改，确保在进行进程切换时相关的I/O权限设置能够正常地保存和恢复？</span><br></pre></td></tr></table></figure>
<p>不需要。进程切换时硬件会自动保存elfags，而在执行新进程时，<code>env_pop_tf</code>的iret指令会恢复eflags。</p>
<p>本实验的GNUmakefile将obj/kern/kernel.img作为disk 0的镜像，将obj/fs/fs.img作为disk 1的镜像。在本实验中，文件系统只能访问disk 1，而disk 0用于启动内核。<br><img src="/2017/08/20/笔记021-Lab5-File-system-Spawn-and-Shell/3.JPG" title="disk 0,disk 1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! JOS目前用的是最简单的PIO（Programming I/O）方式与磁盘交互。请实现中断驱动的IDE磁盘访问（可借助DMA（直接存储器存取））。可以考虑该设备驱动移植到内核中，或者移植到用户空间中、与文件系统进程在一块，或者移植到单独的进程中。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h1><p>jos将借助处理器的虚拟内存实现一个简单的buffer cache（block cache），见fs/bc.c。<br>jos文件系统能够处理的磁盘大小被限制在3GB以内。文件系统进程的地址空间[DISKMAP,DISKMAP+DISKMAX)，即[0x10000000,0xD0000000)被保留，用于磁盘的内存映射，如：block 0映射到0x10000000，block 1映射到0x10001000。fs/bc.c的diskaddr函数实现了磁盘块到虚拟地址的映射。<br>由于文件系统进程的虚拟地址空间完全独立于其他进程，且文件系统进程唯一要完成的工作是实现文件访问，所以通过上述方式保留大部分进程地址空间的做法是合理的；但是对于32位机子上真正实现的文件系统而言，上述方式并不合适，因为现代磁盘大于3G。不过，类似的buffer cache管理方法仍然适用于64位地址空间的机器。<br>为了避免将整个磁盘读取内存，jos实现了一种请求分页demand paging的形式，当在某个磁盘映射区域发生页错误时，分配相关的页并且读取相关的block。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exercise 2. 实现fs/bc.c的bc_pgfault和flush_block函数。</span><br><span class="line">bc_pgfault用于在页错误时从磁盘中加载页，注意给定的addr可能没有对齐block边界、ide_read操作的是sectors而不是blocks。</span><br><span class="line">flush_block函数根据需要将block写入到磁盘。如果block没有在block cache中（该页没被映射）或者block不是dirty的，flush_block函数什么都不做。</span><br><span class="line">jos将使用VM hardware来追踪一个磁盘块自从上次读取或写入磁盘之后是否被修改过。使用PTE_D标志位标记block是否dirty。处理器写页时，设置PTE_D位；将block写入到磁盘后，清除PTE_D位。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//fs/bc.c的bc_pgfault</span><br><span class="line">// Allocate a page in the disk map region, read the contents</span><br><span class="line">	// of the block from the disk into that page.</span><br><span class="line">	// Hint: first round addr to page boundary. fs/ide.c has code to read</span><br><span class="line">	// the disk.</span><br><span class="line">	//</span><br><span class="line">	// LAB 5: you code here:</span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	if ((r = sys_page_alloc(0, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;in bc_pgfault, sys_page_alloc: %e&quot;, r); </span><br><span class="line">	if ((r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) &lt; 0)</span><br><span class="line">		panic(&quot;in bc_pgfault, ide_write: %e&quot;, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// Clear the dirty bit for the disk block page since we just read the</span><br><span class="line">	// block from disk</span><br><span class="line">	if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0)</span><br><span class="line">		panic(&quot;in bc_pgfault, sys_page_map: %e&quot;, r);</span><br></pre></td></tr></table></figure>
<p>注意：<code>flush_block</code>函数的参数是文件系统进程中映射到磁盘块的虚拟地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//fs/bc.c的flush_block</span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	int r; </span><br><span class="line">	if(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;</span><br><span class="line">		if ((r = ide_write(blockno*BLKSECTS, addr, BLKSECTS)) &lt; 0)</span><br><span class="line">			panic(&quot;in flush_block, ide_write: %e&quot;, r);</span><br><span class="line">		if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0)</span><br><span class="line">			panic(&quot;in flush_block, sys_page_map: %e&quot;, r);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>fs/fs.c的<code>fs_init</code>是使用block cache的一个例子。初始化block cache之后（设置页错误处理函数，尝试读取super block的映射内存，该动作会导致页错误并最终读取super block到内存中），<code>fs_init</code>函数将全局结构体指针变量super指向了磁盘disk 1的内存映射区域，之后就可以读取super结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 一旦block出错，block cache将不会移除相应内容，并且会永远保存在内存中。请给block cache添加回收策略。使用PTE_A访问位，对任何页的访问，硬件都会设置该位。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">???</span><br><span class="line">包括bc_pgfault检查block是否为空的原因？</span><br><span class="line">http://wenku.baidu.com/link?url=oANF8V6KZIkGoabt_gkRjWaqoq1nkOq9U7XPMxHRVaeSXjMubzS8I5bNzDCnEYNli0BPrbs0Zc0OJ7vDHBVPnsj8YZ1BHELOSOWWEI0J64i</span><br></pre></td></tr></table></figure>
<h1 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h1><p><code>fs_init</code>设置了bitmap指针指向block 2的起始位置（但不一定就是说只有block 2被用于block map），bitmap是一个<code>uint32_t *</code>类型的指针，用于判断磁盘块是否已被分配使用，每一个bit位代表一个block，置0代表对应的block已被用。在fs被制成镜像时已经默认将block 0、block 1以及被用于bitmap的块对应的bit位置0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 3. 实现alloc_block，在bitmap中查找可用的block，一旦找到，更新对应的bit位，并将该bit位所在的bitmap block更新到磁盘中（注意不一定是block 2），返回对应的block number。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//fs.c</span><br><span class="line">int</span><br><span class="line">alloc_block(void)</span><br><span class="line">&#123;</span><br><span class="line">	// The bitmap consists of one or more blocks.  A single bitmap block</span><br><span class="line">	// contains the in-use bits for BLKBITSIZE blocks.  There are</span><br><span class="line">	// super-&gt;s_nblocks blocks in the disk altogether.</span><br><span class="line"></span><br><span class="line">	// LAB 5: Your code here.</span><br><span class="line">	//panic(&quot;alloc_block not implemented&quot;);</span><br><span class="line">	uint32_t i;  </span><br><span class="line">	for (i = 0; i &lt; super-&gt;s_nblocks; i++)&#123;</span><br><span class="line">		if(bitmap[i/32] &amp; 1&lt;&lt;(i%32))&#123;</span><br><span class="line">			bitmap[i/32] &amp;= ~(1&lt;&lt;(i%32));</span><br><span class="line">			flush_block((void *) &amp;bitmap[i / 32]);</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h1><p>fs/fs.c提供了一系列函数用于解析和管理File结构、浏览和管理目录文件项、由根目录开始解析一个绝对路径等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 4. 完成file_block_walk和file_get_block函数。</span><br></pre></td></tr></table></figure></p>
<p><code>file_block_walk</code>函数的原型是<code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>，指定File f和该文件的某个逻辑block number，在<code>f_direct[NDIRECT]</code>或<code>f_indirect</code>对应的间接块中寻找对应存储磁盘block number的项，将该项地址存储到ppdiskbno，如果alloc为true则允许创建间接块（并清0）。<br><code>file_get_block</code>函数的原型是<code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>，指定File f和该文件的某个逻辑block number，在<code>f_direct[NDIRECT]</code>或<code>f_indirect</code>对应的间接块中找到逻辑block number对应的磁盘block存储位置pdiskbno，如果该位置数据为空，则分配一个新的磁盘block并将磁盘block number存到pdiskbno上。将新分配的磁盘block对应的虚拟地址存储到blk中。注意到：每个磁盘块都有对应的虚拟地址，但是此时新分配的磁盘块并未读入到内存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</span><br><span class="line">&#123; </span><br><span class="line">	int r;</span><br><span class="line">	if(filebno &lt; NDIRECT)&#123;</span><br><span class="line">		*ppdiskbno = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	filebno -= NDIRECT;</span><br><span class="line"></span><br><span class="line">	if(filebno &lt; NINDIRECT)&#123;</span><br><span class="line">		if(!f-&gt;f_indirect)&#123;</span><br><span class="line">			if (!alloc) return -E_NOT_FOUND;</span><br><span class="line">			//alloc indirect block</span><br><span class="line">			if((r=alloc_block()) &lt; 0) return r;//-E_NO_DISK</span><br><span class="line">			f-&gt;f_indirect = r;</span><br><span class="line">			memset(diskaddr(f-&gt;f_indirect),0,BLKSIZE);</span><br><span class="line">		&#125; </span><br><span class="line">		*ppdiskbno = &amp;(((uint32_t *)diskaddr(f-&gt;f_indirect))[filebno]);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">file_get_block(struct File *f, uint32_t filebno, char **blk)</span><br><span class="line">&#123; </span><br><span class="line">	int r;</span><br><span class="line">	uint32_t *pdiskbno;</span><br><span class="line">	//ok to alloc indirect block</span><br><span class="line">	if((r = file_block_walk(f,filebno,&amp;pdiskbno,true)) &lt; 0) return r;</span><br><span class="line">	if(pdiskbno == NULL || *pdiskbno == 0)&#123; // target block hasnot been allocated</span><br><span class="line">		if((r=alloc_block()) &lt; 0) return r;//-E_NO_DISK</span><br><span class="line">		*pdiskbno = r;</span><br><span class="line">	&#125;</span><br><span class="line">	*blk = (char *)(diskaddr(*pdiskbno));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 如果某些文件操作执行一半的时候，由于崩溃或重启可能导致文件系统损坏。尝试实现软更新或日志文件系统，使得文件系统损坏是可恢复的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h1><p>客户端进程不能直接调用文件系统进程的函数，而是通过远程过程调用（RPC - remote procedure call）的形式，jos的RPC基于IPC机制。以读取文件为例，RPC过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure></p>
<p>read根据文件描述符号找出对应的文件描述符，然后将请求分配给正确的设备读取函数<code>devfile_read</code>（可以有更多的设备类型如管道）。<code>devfile_read</code>负责构造ipc请求参数，并调用fsipc函数发送ipc请求，解压返回结果并返回。fsipc函数负责发送ipc请求并接收响应结果。<br>文件系统服务代码为fs/serv.c。在serve函数循环体中，阻塞等待接收文件操作ipc请求，并分发到对应的处理函数如<code>serve_read</code>，然后将处理结果通过ipc回送。<code>serve_read</code>根据请求中的文件信息寻找对应的OpenFile结构，然后调用<code>file_read</code>函数读取磁盘文件，并更新文件偏移。<br>jos的ipc允许发送一个32-bit数和一个共享页地址。客户端发送给文件系统服务端的请求中，使用了32-bit数来传递请求类型，并将请求参数存放在union Fsipc中，该结构的数据存于ipc共享页中。在客户端进程中，固定的共享地址是fsipcbuf；在服务端进程中，固定将接收的共享页映射到fsreq(0x0ffff000)。<br>文件系统进程使用ipc回送结果，使用了32-bit数来传递返回码。<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>会返回数据，数据将写到共享页中。进行文件读取时，客户端进程发送buffer映射页，ipc send会将该页映射到文件系统进程中，文件系统填充该页后，发送执行结果到客户端，并解除映射。文件系统进程不需要将映射页发送给客户端，因为两者已经共享内存了。而对于<code>FSREQ_OPEN</code>，它会向客户端共享一个新的“Fd page”，该文件描述符页地址会作为ipc结果返回。  </p>
<p>ipc可支持并发访问文件系统，文件系统进程每次ipc recv时阻塞，假设有多个进程并发向文件系统发送请求，由于内核锁的原因，某个时刻只能有一个进程导致进入内核模式且对文件系统进程的阻塞状态进行解除；等执行下一个进程导致进入内核模式时，文件系统已经不再是阻塞状态了，因此后续所有进程都需要循环尝试ipc send直到文件系统进程再次阻塞。文件系统进程处理完一个进程的请求之后才会再次陷入阻塞。<br>注意到：文件操作涉及的ipc调用时，可能会出现客户端调用<code>ipc_recv</code>并指定期望接收到响应页的虚拟地址，而文件系统进程则是根据情况返回响应页虚拟地址或0。如果客户端指定接收的虚拟地址，文件系统进程返回的地址却为0，我们会在<code>ipc_send</code>中将值为0的地址重新设为一个标志”no page”的特定值，但在<code>sys_ipc_try_send</code>中我们又尝试对发送的地址进行页对齐检查。因此，鉴于以上情况，标志”no page”的特定值必须页对齐，可设为KERNBASE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 5. 实现fs/serv.c的serve_read。serve_read调用file_read函数读取磁盘文件，serve_read本身只需要提供文件读取的RPC接口。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">serve_read(envid_t envid, union Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line">	struct Fsreq_read *req = &amp;ipc-&gt;read;</span><br><span class="line">	struct Fsret_read *ret = &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line">	if (debug)</span><br><span class="line">		cprintf(&quot;serve_read %08x %08x %08x\n&quot;, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	// Lab 5: Your code here:</span><br><span class="line">	int r;</span><br><span class="line">	struct OpenFile *o;</span><br><span class="line">	if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line">	if ((r = file_read(o-&gt;o_file,ret-&gt;ret_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line">	o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 6. 实现fs/serv.c的serve_write、lib/file.c的devfile_write。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// lib/file.c的devfile_write</span><br><span class="line"></span><br><span class="line">static ssize_t</span><br><span class="line">devfile_write(struct Fd *fd, const void *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	// Make an FSREQ_WRITE request to the file system server.  Be</span><br><span class="line">	// careful: fsipcbuf.write.req_buf is only so large, but</span><br><span class="line">	// remember that write is always allowed to write *fewer*</span><br><span class="line">	// bytes than requested.</span><br><span class="line">	// LAB 5: Your code here</span><br><span class="line">	//panic(&quot;devfile_write not implemented&quot;);</span><br><span class="line">	uint32_t max = PGSIZE - (sizeof(int) + sizeof(size_t));//see fs.h</span><br><span class="line">	if (n &gt; max) n = max;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">	fsipcbuf.write.req_n = n; </span><br><span class="line">	memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">	return fsipc(FSREQ_WRITE, NULL);	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//fs/serv.c的serve_write</span><br><span class="line"></span><br><span class="line">// Write req-&gt;req_n bytes from req-&gt;req_buf to req_fileid, starting at</span><br><span class="line">// the current seek position, and update the seek position</span><br><span class="line">// accordingly.  Extend the file if necessary.  Returns the number of</span><br><span class="line">// bytes written, or &lt; 0 on error.</span><br><span class="line">int</span><br><span class="line">serve_write(envid_t envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line">	if (debug)</span><br><span class="line">		cprintf(&quot;serve_write %08x %08x %08x\n&quot;, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	// LAB 5: Your code here.</span><br><span class="line">	//panic(&quot;serve_write not implemented&quot;);</span><br><span class="line">	int r;</span><br><span class="line">	struct OpenFile *o;</span><br><span class="line">	if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line">	if ((r = file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line">	o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h1><p>lib/spawn.c用于创建新进程（设置进程内核空间部分的页目录、复制父进程的trapframe等，但没有映射用户地址空间），设置子进程的trapframe（如修改eip入口为程序入口），初始化子进程用户栈（分配空间、存储传递的参数），从文件系统加载程序文件到新进程中（分配新物理页存储），然后让子进程开始执行该程序。spawn类似于UNIX的fork，在子进程中直接跟进exec。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exercise 7. spawn函数需要设置子进程的trapframe。实现sys_env_set_trapframe系统调用，需要检查给出的trapframe地址是否可写，并且需要确保子进程执行期间能够触发中断。</span><br><span class="line">注意到：系统调用过程中传递struct Trapframe *地址的方式是调用前先转换为uint32_t类型，调用后再转换为struct Trapframe *。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to set envid&apos;s trapframe. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	// check whether the user has supplied us with a good address!</span><br><span class="line">	user_mem_assert(e, tf, sizeof(struct Trapframe), PTE_U | PTE_W);//see in kern/pmap.c</span><br><span class="line">	e-&gt;env_tf = *tf;</span><br><span class="line">	// Enable interrupts while in user mode. </span><br><span class="line">	e-&gt;env_tf.tf_cs = GD_UT | 3;</span><br><span class="line">	e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 实现unix形式的exec。</span><br></pre></td></tr></table></figure>
<p>xv6创建子线程并执行新程序的流程大致是：1、用户态调用fork创建子进程，包括复制物理页。2、用户态执行用户子进程，调用exec尝试执行新程序。3、内核态读取新程序内容，映射到新的地址空间中。4、内核态更换子进程的地址空间，释放旧地址空间。<br>jos使用spawn创建子线程并执行新程序的流程大致是：1、用户态spawn创建子线程，只设置进程内核空间部分的页目录、复制父进程的trapframe等，但没有映射用户地址空间。2、用户态spawn读取程序文件到子进程地址空间中（调用系统调用函数分配、映射物理页）。3、用户态spawn设置子进程用户栈和trapframe（包括执行入口），调用系统调用函数更新子进程trapframe。4、用户态spawn设置子进程为可执行。<br>jos使用exec创建子线程并执行新程序的流程大致是：1、用户态exec调用fork创建子线程，地址空间映射为写时复制。2、用户态exec读取程序文件到子进程地址空间中，但注意应该是临时的空间（如段地址都加上一段临时位移）。3、用户态exec设置子进程用户栈和trapframe（包括执行入口），调用系统调用函数更新子进程trapframe。4、用户态exec调用系统调用函数更换地址空间映射。5、用户态exec设置子进程为可执行。<strong>（此流程的正确性待验证）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 实现mmap-style的内存映射文件，修改spawn，支持直接从ELF镜像文件中映射物理页。</span><br></pre></td></tr></table></figure></p>
<h1 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h1><p>unix文件描述符是一个综合概念，包括文件、管道、console I/O等设备类型。在jos中，每一个设备类型都有相关联的struct Dev，以及读写相关的函数指针。每一个struct Fd指明了它的设备类型，lib/fd.c的大多数函数只是负责分发处理函数到对应的struct Dev。<br>lib/fd.c同时负责维护每个应用进程的文件描述符表区域，该区域从FSTABLE开始，每个文件描述符对应一个页，一个进程一次最多可以打开32个文件描述符。当且仅当文件描述符被使用时，其相关的文件描述符表页才被映射。每个文件描述符还有一个可选的数据页，从FILEDATA地址开始。<br>我们希望通过fork和spawn来共享文件描述符状态，但是文件描述符状态是保存在用户空间中的。目前，fork将内存映射为写时复制，文件描述符状态会被复制而不是共享（意味着进程不能seek这些不是由它们本身打开的文件，也不能使用管道）；spawn则完全不处理这些相关内存，因此创建的新进程没有打开任何文件描述符。<br>因此，我们将标记特定部分的内存区域是共享的。采取的方法是使用页表项中的一个未使用位（如<code>PTE_COW</code>的做法一样）。具体使用的位是定义于inc/lib.h的<code>PTE_SHARE</code>位，Intel和AMD保留了三个软件可用的PTE位，这是其中之一。一旦页表项设置了<code>PTE_SHARE</code>位，则fork和spawn需要直接复制物理页到子进程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 8. 修改lib/fork.c的duppage和lib/spawn.c的copy_shared_pages，实现PTE_SHARE。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">duppage(envid_t envid, unsigned pn)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;duppage not implemented&quot;); </span><br><span class="line">	void *addr = (void *)(pn*PGSIZE);</span><br><span class="line">	if ( (uvpt[pn] &amp; PTE_SHARE) == PTE_SHARE ) &#123; </span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, uvpt[pn] &amp; PTE_SYSCALL)) &lt; 0)</span><br><span class="line">			panic(&quot;sys_page_map: %e\n&quot;, r);</span><br><span class="line">	&#125; else if( (uvpt[pn] &amp; PTE_W) == PTE_W || </span><br><span class="line">	    (uvpt[pn] &amp; PTE_COW) == PTE_COW)&#123; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, 0, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">copy_shared_pages(envid_t child)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 5: Your code here. </span><br><span class="line">	unsigned addr;</span><br><span class="line">	int r;</span><br><span class="line">	for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE)&#123;</span><br><span class="line">		if ((uvpd[PDX(addr)] &amp; PTE_P) == PTE_P</span><br><span class="line">			&amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE) == PTE_SHARE</span><br><span class="line">		    &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U) == PTE_U) &#123;</span><br><span class="line">		    if ((r = sys_page_map(0, (void *)addr, child, (void *)addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0)</span><br><span class="line">				panic(&quot;sys_page_map: %e\n&quot;, r);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>user/testpteshare.c中先在父进程的0xA0000000上分配页并设为共享页，然后调用fork创建子进程。在lab4中，我们映射的地址范围是[UTEXT,end[])，然而在user/testpteshare.c这种情况中，0xA0000000地址是大于end的，所以该共享页不会被映射到子进程中，后续子进程往0xA0000000写入数据会造成页错误，但是该页没被设为写时复制，会直接panic。因此，我们需要修正映射的地址范围，改为[0,USTACKTOP)，但需要判断是否有对应的页目录项和页表项。</p>
<h1 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h1><p>QEMU显示输出到CGA和串行口，但目前为止我们只在嵌入内核监控的时候进行输入。在QEMU图形窗口中的键入表现为键盘键入，在控制台的键入表现为串行口的特性。kern/console.c包含了内核监控所使用的键盘和串行驱动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 9. 在kern/trap.c中，调用kbd_intr处理IRQ_OFFSET+IRQ_KBD中断，调用serial_intr来处理IRQ_OFFSET+IRQ_SERIAL中断。</span><br></pre></td></tr></table></figure></p>
<p>lib/console.c实现了控制台input/output文件类型，当控制台文件类型消耗缓冲区的时候（drains the buffer），<code>kbd_intr</code>和<code>serial_intr</code>将最新读取的输入填充到一个缓冲区中。（控制台文件类型默认被stdin/stdout使用，除非用户对其重定向）</p>
<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>user/icode调用spawn执行init，init程序将控制台设为文件描述符0和1，然后调用spawn执行shell。注意到库函数cprintf直接向控制台输出，没有借助任何文件描述符代码。这种做法有利于debug但不利于使用管道与其他程序通信。使用类似fprintf(1, “…”, …)的形式向特定的文件描述符进行输出。printf(“…”, …)是输出到文件描述符1的简略形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 10. 在user/sh.c中添加相关内容，使之支持重定向。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void runcmd(char* s)</span><br><span class="line"></span><br><span class="line">		case &apos;&lt;&apos;:	// Input redirection</span><br><span class="line">			// Grab the filename from the argument list</span><br><span class="line">			if (gettoken(0, &amp;t) != &apos;w&apos;) &#123;</span><br><span class="line">				cprintf(&quot;syntax error: &lt; not followed by word\n&quot;);</span><br><span class="line">				exit();</span><br><span class="line">			&#125;</span><br><span class="line">			// Open &apos;t&apos; for reading as file descriptor 0</span><br><span class="line">			// (which environments use as standard input).</span><br><span class="line">			// We can&apos;t open a file onto a particular descriptor,</span><br><span class="line">			// so open the file as &apos;fd&apos;,</span><br><span class="line">			// then check whether &apos;fd&apos; is 0.</span><br><span class="line">			// If not, dup &apos;fd&apos; onto file descriptor 0,</span><br><span class="line">			// then close the original &apos;fd&apos;.</span><br><span class="line"></span><br><span class="line">			// LAB 5: Your code here.</span><br><span class="line">			//panic(&quot;&lt; redirection not implemented&quot;);			</span><br><span class="line">			if ((fd = open(t, O_RDONLY)) &lt; 0) &#123;</span><br><span class="line">				cprintf(&quot;open %s for read: %e&quot;, t, fd);</span><br><span class="line">				exit();</span><br><span class="line">			&#125;</span><br><span class="line">			if (fd != 0) &#123;</span><br><span class="line">				dup(fd, 0);</span><br><span class="line">				close(fd);</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 为shell添加更多功能，使之支持：</span><br><span class="line">backgrounding commands (ls &amp;)</span><br><span class="line">multiple commands per line (ls; echo hi)</span><br><span class="line">command grouping ((ls; echo hi) | cat &gt; out)</span><br><span class="line">environment variable expansion (echo $hello)</span><br><span class="line">quoting (echo &quot;a | b&quot;)</span><br><span class="line">command-line history and/or editing</span><br><span class="line">tab completion</span><br><span class="line">directories, cd, and a PATH for command-lookup.</span><br><span class="line">file creation</span><br><span class="line">ctl-c to kill the running environment</span><br></pre></td></tr></table></figure>
<h1 id="fd、dev、file"><a href="#fd、dev、file" class="headerlink" title="fd、dev、file"></a>fd、dev、file</h1><p>jos的文件系统进程负责维护File数据结构、fd与file之间的关系，并以fd与其他进程进行交互。其他进程并不操作File数据结构，而是以fd与文件系统进程进行交互，具体是共享填充fd数据结构的页面。<br>jos的文件描述符包括文件、管道、console I/O三种设备dev类型，每种类型都有相应的文件读写接口，定义一致。用户进程在使用时，具体指定一种dev类型。每个类型的dev都有对应的id，并存在fd中，然后调用库函数与文件系统交互。在上述三种文件类型中，只有涉及文件类型时才会与文件系统进程进程交互。<br>File的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct File &#123;</span><br><span class="line">	char f_name[MAXNAMELEN];	// filename</span><br><span class="line">	off_t f_size;			// file size in bytes</span><br><span class="line">	uint32_t f_type;		// file type</span><br><span class="line"></span><br><span class="line">	// Block pointers.</span><br><span class="line">	// A block is allocated iff its value is != 0.</span><br><span class="line">	uint32_t f_direct[NDIRECT];	// direct blocks</span><br><span class="line">	uint32_t f_indirect;		// indirect block</span><br><span class="line"></span><br><span class="line">	// Pad out to 256 bytes; must do arithmetic in case we&apos;re compiling</span><br><span class="line">	// fsformat on a 64-bit machine.</span><br><span class="line">	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];</span><br><span class="line">&#125; __attribute__((packed));	// required only on some 64-bit machines</span><br></pre></td></tr></table></figure></p>
<p>fd的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct FdFile &#123;</span><br><span class="line">	int id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Fd &#123;</span><br><span class="line">	int fd_dev_id;</span><br><span class="line">	off_t fd_offset;</span><br><span class="line">	int fd_omode;</span><br><span class="line">	union &#123;</span><br><span class="line">		// File server files</span><br><span class="line">		struct FdFile fd_file;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>dev的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Dev &#123;</span><br><span class="line">	int dev_id;</span><br><span class="line">	const char *dev_name;</span><br><span class="line">	ssize_t (*dev_read)(struct Fd *fd, void *buf, size_t len);</span><br><span class="line">	ssize_t (*dev_write)(struct Fd *fd, const void *buf, size_t len);</span><br><span class="line">	int (*dev_close)(struct Fd *fd);</span><br><span class="line">	int (*dev_stat)(struct Fd *fd, struct Stat *stat);</span><br><span class="line">	int (*dev_trunc)(struct Fd *fd, off_t length);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">extern struct Dev devfile;</span><br><span class="line">extern struct Dev devcons;</span><br><span class="line">extern struct Dev devpipe;</span><br></pre></td></tr></table></figure></p>
<h1 id="文件类型的交互"><a href="#文件类型的交互" class="headerlink" title="文件类型的交互"></a>文件类型的交互</h1><p>文件系统进程使用OpenFile关联file和fd，OpenFile定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct OpenFile &#123;</span><br><span class="line">	uint32_t o_fileid;	// file id</span><br><span class="line">	struct File *o_file;	// mapped descriptor for open file</span><br><span class="line">	int o_mode;		// open mode</span><br><span class="line">	struct Fd *o_fd;	// Fd page</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>OpenFile的fd关联着一个页地址，当具体分配fd时，会分配相应的物理页用于存储fd数据。进行文件读写时，fd用于保存文件的偏移、dev的id、文件id等信息，文件读写时是根据文件的偏移来计算逻辑块编号的；file则用于根据逻辑块编号查找存储的磁盘块编号。jos文件系统的磁盘块和文件系统进程的内存映射是固定的，根据file和逻辑块编号找到磁盘块编号之后，可得到对应的内存虚拟地址，在文件系统进程地址空间中读取该虚拟地址时，若发生页错误，文件系统进程注册的页错误处理函数会先读取磁盘内容到文件系统进程的地址空间中；用户进程写入内容到fd时，会在fd结构中找到对应的fileid并发送给文件系统进程，文件系统进程根据fileid找到对应的openfile，进而找到对应的file，并根据文件偏移计算逻辑块编号，再得到磁盘块编号和内存虚拟地址，最终填充数据到对应的内存空间中，支持close的时候会执行刷新动作，将脏内存内容更新到磁盘。</p>
<p>File数据结构既用于管理Dir，又用于管理File。File数据结构本身存储于文件系统进程的block diskmap内存空间中[0x10000000,0xD0000000)，dir关联的每一个block存储着若干直接子目录dir/file结构的数据，dir的size大小为存储直接子目录dir/file结构的所有block的总大小。</p>
<p>文件系统进程最多一次性支持1024个openfile，对应1024个fd，fd页地址从0xD0000000开始。用户进程发送文件open请求时，文件系统进程将寻找可用的fd并返回对应索引的openfile。open成功的情况是找到可用的fd和根据路径找到正确的file结构，然后使用ipc发送返回fd页地址，这种情况下fd页引用为2：一次是分配fd的时候，一次是ipc发送返回的时候映射到目标进程的地址空间；查找可用fd的过程中，如果fd页引用为0，会分配对应的物理页，使得fd页引用为1，此后如果出现其他错误，返回的fd页地址尚未被设置，则ipc发送返回的时候fd页不会映射到目标进程的地址空间，fd页引用保持为1；这说明，当fd页引用为0或1时，代表fd可用；下次查找可用fd的时候仍然会使用引用为1的fd，但省略分配新物理页的步骤，而只是累加fileid。 </p>
<p>open成功时使用ipc返回fd页地址，存储着fileid、devid等信息（devid初始化为文件类型对应的id）。之后，用户进程从fd中读取fileid等信息，与文件系统进程继续进行交互，也可以编码改变文件偏移等信息，因为文件系统进程与用户进程共享该fd页。</p>
<p>用户进程一次最多可以打开32个fd，具体相关的库函数见lib/fd.c。用户进程的fd页地址从0xD0000000开始，file设备的open函数（见file.c）的功能是在用户进程中分配空闲的fd页虚拟地址，然后向文件系统进程发送open文件的ipc请求，表示希望在该fd页虚拟地址上接收文件系统进程共享的fd页，open函数转换为相应的fd索引返回，此后使用fd索引即可在用户进程中找到对应的fd页和数据。</p>
<p>库函数fd.c负责管理fd索引和fd页之间的转换，以及由小到大分配用户fd。file.c、pipe.c、console.c为具体的设备文件，三者的访问接口一致，但具体实现细节不同。用户进程调用fd.c的相关函数进行文件读写时传递fd索引参数，fd.c的函数根据fd索引找到fd实例，然后找到具体的dev并调用对应的设备函数。</p>
<p>关于fd的释放，用户进程调用fd.c的close函数一方面会调用相关设备的close函数（文件设备的close函数会发送请求到文件系统进程，刷新内存脏页到磁盘），并解除用户进程在fd上的页映射，该做法会导致fd页的引用变为1，从而文件系统进程可复用该fd页。</p>
<h1 id="管道的交互"><a href="#管道的交互" class="headerlink" title="管道的交互"></a>管道的交互</h1><p>pipe的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Pipe &#123;</span><br><span class="line">	off_t p_rpos;		// read position</span><br><span class="line">	off_t p_wpos;		// write position</span><br><span class="line">	uint8_t p_buf[PIPEBUFSIZ];	// data buffer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>jos的管道大概实现是：在用户进程中分配两个<strong>fd页</strong>（权限设置为共享），fd0权限设为只读，fd1权限设为只写；这两个fd还有对应的data虚拟地址，两者映射到<strong>同一张物理页</strong>（权限设置为共享）表示管道共享这一张物理页，该物理页存储着pipe数据结构，包括读写指针和缓冲区。user/testpipe.c的大概过程是：主进程调用pipe分配两个fd，然后调用fork创建子进程，fork会将共享页之外的可写页/写时复制页映射为写时复制；此时父子进程都有相同的fd页映射和fd data页映射；之后子进程关闭fd1，解除fd1页映射，然后尝试从fd0中读取；父进程关闭fd0，解除fd0页映射，然后尝试往fd1中写入。由于父进程的fd0、fd1共享一张data物理页，fork的过程会将对应页访问权限映射到子进程中（fork中并没有将子进程对应的页权限也设为<code>PTE_SHARE</code>，这表示父进程共享给子进程的页不一定能共享给子进程创建的子子进程），所以子进程的fd0与父进程的fd1共享同一张data物理页。管道读写时实际上是操作data物理页，写时：对于每一个即将写入到缓冲区的字节，若写指针&gt;=读指针+缓冲区大小，说明缓冲区已满，调用<code>sys_yield</code>尝试切换执行其他进程，否则写入缓冲区并写指针加1（写入时写指针取余数）；读时：循环即将读取的字节大小，若读指针=写指针，说明缓冲区为空，调用<code>sys_yield</code>尝试切换执行其他进程，否则从缓冲区读取一个字节，读指针加1（读取时读指针取余数）。</p>
<p>注意到，jos的管道没有涉及到文件系统进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记020-HW11-xv6-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记020-HW11-xv6-log/" itemprop="url">笔记020 - HW11: xv6 log</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:19:30+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记019-HW10-bigger-files-for-xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记019-HW10-bigger-files-for-xv6/" itemprop="url">笔记019 - HW10: bigger files for xv6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:19:07+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>xv6的inode包括12个直接的block number和1个间接的block，间接的block存储128个block number，最大支持的文件长度为12+128=140个sectors。<br>修改xv6，将其中一个block number修改为双层间接的block，使得最大支持的文件长度为11+128+128x128=16523个sectors。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Makefile</span><br><span class="line"></span><br><span class="line">CPUS := 1</span><br><span class="line">QEMUOPTS : 添加 -snapshot</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载big.c，添加到Makefile的UPROGS。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">param.h 修改FSSIZE</span><br><span class="line"></span><br><span class="line">//#define FSSIZE       1000  // size of file system in blocks</span><br><span class="line">#define FSSIZE       21113  // size of file system in blocks</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fs.h 修改NDIRECT、MAXFILE、dinode.addrs，添加NDBINDIRECT</span><br><span class="line"></span><br><span class="line">//#define NDIRECT 12</span><br><span class="line">#define NDIRECT 11 </span><br><span class="line">#define NDBINDIRECT (NINDIRECT * NINDIRECT)</span><br><span class="line"></span><br><span class="line">#define NINDIRECT (BSIZE / sizeof(uint)) // 512/4=128</span><br><span class="line">//#define MAXFILE (NDIRECT + NINDIRECT)</span><br><span class="line">#define MAXFILE (NDIRECT + NINDIRECT +NDBINDIRECT)</span><br><span class="line"></span><br><span class="line">// On-disk inode structure</span><br><span class="line">struct dinode &#123;</span><br><span class="line">  short type;           // File type</span><br><span class="line">  short major;          // Major device number (T_DEV only)</span><br><span class="line">  short minor;          // Minor device number (T_DEV only)</span><br><span class="line">  short nlink;          // Number of links to inode in file system</span><br><span class="line">  uint size;            // Size of file (bytes)</span><br><span class="line">  //uint addrs[NDIRECT+1];   // Data block addresses</span><br><span class="line">  uint addrs[NDIRECT+2];   // Data block addresses</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">file.h 修改inode.addrs</span><br><span class="line"></span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  int flags;          // I_VALID</span><br><span class="line"></span><br><span class="line">  short type;         // copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  //uint addrs[NDIRECT+1];</span><br><span class="line">  uint addrs[NDIRECT+2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>fs.c的bmap()函数负责根据逻辑block number返回对应的物理block（若对应的记录为空，则先分配）。原先的bmap()函数先检查逻辑block number是否在NDIRECT范围内（直接的block）；否则，逻辑block number减去NDIRECT，检查新的逻辑block number是否在NINDIRECT范围内（间接的block）。新添加的处理过程是：逻辑block number再减去NINDIRECT，检查新的逻辑block number是否在NDBINDIRECT范围内（双层间接的block）。如果符合要求，则根据需要获取间接block内容或分配最终的block。</p>
<p>xv6 inode的标准格式如下：<br><img src="/2017/08/20/笔记019-HW10-bigger-files-for-xv6/1.JPG" title="xv6 inode的标准格式"><br>扩展后的xv6 inode的格式如下：<br><img src="/2017/08/20/笔记019-HW10-bigger-files-for-xv6/2.JPG" title="扩展后的xv6 inode的格式"></p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">$ big</span><br><span class="line">``` </span><br><span class="line">&#123;% asset_img 3.JPG 编译并运行 %&#125;</span><br><span class="line">可以看到，系统支持的size和nblocks都更新了，支持的最大文件长度为16523个sectors。</span><br><span class="line"></span><br><span class="line"># 源代码</span><br></pre></td></tr></table></figure></p>
<p>//fs.c</p>
<p>static uint<br>bmap(struct inode <em>ip, uint bn)<br>{<br>  uint addr, </em>a;<br>  struct buf *bp;</p>
<p>  if(bn &lt; NDIRECT){<br>    if((addr = ip-&gt;addrs[bn]) == 0)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    return addr;<br>  }<br>  bn -= NDIRECT;</p>
<p>  if(bn &lt; NINDIRECT){<br>    // Load indirect block, allocating if necessary.<br>    if((addr = ip-&gt;addrs[NDIRECT]) == 0)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    if((addr = a[bn]) == 0){<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    }<br>    brelse(bp);<br>    return addr;<br>  }</p>
<p>  //homework10<br>  bn -= NINDIRECT;<br>  if(bn &lt; NDBINDIRECT){<br>    if((addr = ip-&gt;addrs[NINDIRECT+1]) == 0)<br>      ip-&gt;addrs[NINDIRECT+1] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    int first_block_index = bn/NINDIRECT;<br>    if((addr = a[first_block_index]) == 0){<br>      a[first_block_index] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    }<br>    brelse(bp);</p>
<pre><code>bp = bread(ip-&gt;dev, addr);
a = (uint*)bp-&gt;data;
int second_block_index = bn%NINDIRECT;
if((addr = a[second_block_index]) == 0){
  a[second_block_index] = addr = balloc(ip-&gt;dev);
  log_write(bp);
} 
brelse(bp);
return addr;
</code></pre><p>  }      </p>
<p>  panic(“bmap: out of range”);<br>}<br><code>`</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记018-HW9-Barriers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记018-HW9-Barriers/" itemprop="url">笔记018 - HW9: Barriers</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:18:38+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>启动多个进程，每个进程执行20000个循环。对于每一个循环周期，确保多个进程都执行到同一个点，然后继续下一次循环。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待“条件变量的条件成立”而挂起；另一个线程使“条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。</p>
<p>可参考的函数使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件变量的使用：</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br></pre></td></tr></table></figure></p>
<p><code>pthread_cond_wait</code>会先解除之前的<code>pthread_mutex_lock</code>锁定的mutex，然后阻塞在等待对列里休眠，直到再次被唤醒（大多数情况下是等待的条件成立而被唤醒，唤醒后，该进程会先锁定先<code>pthread_mutex_lock(&amp;mtx);</code>，再读取资源。</p>
<p>在barrier()函数中加入互斥锁和条件变量的控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    if(bstate.nthread != nthread)&#123;</span><br><span class="line">      pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">      pthread_mutex_unlock(&amp;bstate.barrier_mutex); </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">      bstate.round++;</span><br><span class="line">      bstate.nthread = 0;</span><br><span class="line">      pthread_mutex_unlock(&amp;bstate.barrier_mutex);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bstate.nthread变量的累加用于决定：由最后一个进入barrier()的线程来进行broadcast。注意到<code>pthread_cond_wait</code>函数本身先释放锁、休眠、被唤醒、加锁的流程；执行broadcast之后，该线程会累加周期数bstate.round并清空bstate.nthread，然后释放锁，只有当该线程释放锁，其他线程才真正能在<code>pthread_cond_wait</code>中加锁。</p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -O2 -pthread barrier.c</span><br><span class="line">$ ./a.out 2</span><br><span class="line">``` </span><br><span class="line">&#123;% asset_img 1.JPG 编译并运行 %&#125;</span><br><span class="line"></span><br><span class="line"># 源代码</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;assert.h&gt;</p>
<p>#include &lt;pthread.h&gt;</p>
<p>// #define SOL</p>
<p>static int nthread = 1;<br>static int round = 0;</p>
<p>struct barrier {<br>  pthread_mutex_t barrier_mutex;<br>  pthread_cond_t barrier_cond;<br>  int nthread;      // Number of threads that have reached this round of the barrier<br>  int round;     // Barrier round<br>} bstate;</p>
<p>static void<br>barrier_init(void)<br>{<br>  assert(pthread_mutex_init(&amp;bstate.barrier_mutex, NULL) == 0);<br>  assert(pthread_cond_init(&amp;bstate.barrier_cond, NULL) == 0);<br>  bstate.nthread = 0;<br>}</p>
<p>static void<br>barrier()<br>{<br>    pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>    bstate.nthread++;<br>    if(bstate.nthread != nthread){<br>      pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>      pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>    }else{<br>      pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>      bstate.round++;<br>      bstate.nthread = 0;<br>      pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>    }<br>}</p>
<p>static void <em><br>thread(void </em>xa)<br>{<br>  long n = (long) xa;<br>  long delay;<br>  int i;</p>
<p>  for (i = 0; i &lt; 20000; i++) {<br>    int t = bstate.round;<br>    assert (i == t);<br>    barrier();<br>    usleep(random() % 100);<br>  }<br>}</p>
<p>int<br>main(int argc, char <em>argv[])<br>{<br>  pthread_t </em>tha;<br>  void *value;<br>  long i;<br>  double t1, t0;</p>
<p>  if (argc &lt; 2) {<br>    fprintf(stderr, “%s: %s nthread\n”, argv[0], argv[0]);<br>    exit(-1);<br>  }<br>  nthread = atoi(argv[1]);<br>  tha = malloc(sizeof(pthread_t) * nthread);<br>  srandom(0);</p>
<p>  barrier_init();</p>
<p>  for(i = 0; i &lt; nthread; i++) {<br>    assert(pthread_create(&amp;tha[i], NULL, thread, (void *) i) == 0);<br>  }<br>  for(i = 0; i &lt; nthread; i++) {<br>    assert(pthread_join(tha[i], &amp;value) == 0);<br>  }<br>  printf(“OK; passed\n”);<br>}<br><code>`</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记017-HW8-User-level-threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记017-HW8-User-level-threads/" itemprop="url">笔记017 - HW8: User-level threads</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:18:14+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Switching-threads"><a href="#Switching-threads" class="headerlink" title="Switching threads"></a>Switching threads</h1><p>本次练习是在用户程序uthread.c中模拟进程之间的切换。<br>进程结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct thread &#123;</span><br><span class="line">  int        sp;                /* curent stack pointer */</span><br><span class="line">  char stack[STACK_SIZE];       /* the thread&apos;s stack */</span><br><span class="line">  int        state;             /* running, runnable, waiting */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static thread_t all_thread[MAX_THREAD];</span><br></pre></td></tr></table></figure></p>
<p>sp变量用于保存切换进程时“当前进程”的esp。初始化进程的时候，留出栈顶4字节空间保存函数mythread地址，如果进程切换时切换到的进程尚未执行过，则会执行该函数；然后留出32字节的空间，并更新sp变量指向距离栈顶36字节位置，如果进程切换时切换到的进程尚未执行过，则将这32字节弹出到通用寄存器。stack即为模拟的进程执行过程中所使用的栈。</p>
<p>uthread.c定义了进程树组<code>all_thread</code>，并在初始化过程中指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_thread = &amp;all_thread[0];</span><br><span class="line">current_thread-&gt;state = RUNNING;</span><br></pre></td></tr></table></figure></p>
<p>这样，第一个进程被假设为正在执行，它永远不会被真正执行，因为之后的进程切换都在其他RUNNABLE进程中选取。</p>
<p>本次作业主要要完成进程切换的工作，即完成<code>uthread_switch.S</code>。每次跳转到<code>thread_switch</code>执行进程切换时，由于是运行在“当前进程”<code>current_thread</code>栈上，所以直接在当前栈上保存通用寄存器（pushal），然后将esp保存到“当前进程”<code>current_thread</code>的sp上，这样下次切换为该进程时直接将sp赋值给esp之后就可以执行popal。之后跳转到<code>next_thread</code>的sp指向的位置（进程第一次被调用时，sp指向的是距离栈顶36字节位置），并将<code>current_thread</code>指向<code>next_thread</code>，将<code>next_thread</code>置0，然后弹出通用寄存器，执行ret。  </p>
<p>执行ret之后会有什么效果呢？分两种情况：1、进程未被执行过时，sp指向距离栈顶36字节位置，弹出32字节到通用寄存器之后，执行ret会执行绑定的函数mythread。2、此后，进程在“当前进程”栈上执行，当再次次跳转到<code>thread_switch</code>执行进程切换时，首先将下一条指令的eip进栈，然后再pushal保存通用寄存器，并将最新的esp保存到“当前进程”的sp变量中。这样后续切换到该进程时，则弹出通用寄存器后执行ret会执行保存eip，即恢复执行调用<code>thread_switch</code>的下一条指令。</p>
<p>需要注意的是：由于<code>current_thread</code>一开始被初始化为<code>all_thread[0]</code>，且没有被真正执行过，所以第一次跳转到<code>thread_switch</code>执行pushal的时候是保存通用寄存器到用户程序uthread的用户栈上的；后续进程切换的时候，跳转到<code>thread_switch</code>后执行pushal才真正地在“当前进程”栈上保存通用寄存器，但是这对于本程序的模拟没有影响。</p>
<p><code>uthread_switch.S</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line"></span><br><span class="line">/* Switch from current_thread to next_thread. Make next_thread</span><br><span class="line"> * the current_thread, and set next_thread to 0.</span><br><span class="line"> * Use eax as a temporary register, which should be caller saved.</span><br><span class="line"> */</span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	/* YOUR CODE HERE */</span><br><span class="line"></span><br><span class="line">	# We are running on current_thread&apos;s stack, push all registers to save</span><br><span class="line">	# attention: first time we call thread_switch, we actually do not run on current_thread&apos;s stack</span><br><span class="line">	# because current_thread point to all_thread[0], and we just fake it is running, but it does not matter</span><br><span class="line">	pushal</span><br><span class="line"></span><br><span class="line">	# Save current thread&apos;s stack pointer</span><br><span class="line">	movl current_thread, %eax</span><br><span class="line">	movl %esp, (%eax)</span><br><span class="line"></span><br><span class="line">	# Switch stacks to next thread</span><br><span class="line">	movl next_thread, %eax</span><br><span class="line">	movl (%eax), %esp #point to sp&apos;value, if is every thread&apos;s first-time-running, it already leaves the space to save registers</span><br><span class="line"></span><br><span class="line">	# Set current_thread to next_thread </span><br><span class="line">	movl %eax, current_thread </span><br><span class="line">	# Set next_thread to 0</span><br><span class="line">	movl $0, next_thread</span><br><span class="line"></span><br><span class="line">	# Pop next thread&apos;s registers from the stack into the appropriate registers</span><br><span class="line">	popal</span><br><span class="line"></span><br><span class="line">	// exec current_thread</span><br><span class="line">	ret				/* pop return address from stack */</span><br></pre></td></tr></table></figure></p>
<h1 id="调试内置用户程序技巧"><a href="#调试内置用户程序技巧" class="headerlink" title="调试内置用户程序技巧"></a>调试内置用户程序技巧</h1><p>启动qemu之后，可以使用以下方法调试内置的用户程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) symbol-file _uthread</span><br><span class="line">Load new symbol table from &quot;/Users/kaashoek/classes/6828/xv6/_uthread&quot;? (y or n) y</span><br><span class="line">Reading symbols from /Users/kaashoek/classes/6828/xv6/_uthread...done.</span><br><span class="line">(gdb) b thread_switch</span><br><span class="line">Breakpoint 1 at 0x204: file uthread_switch.S, line 9.</span><br><span class="line">(gdb) c</span><br><span class="line"></span><br><span class="line">(gdb) print /x *next_thread</span><br><span class="line">$1 = &#123;sp = 0x4d48, stack = &#123;0x0 , 0x61, 0x1, 0x0, 0x0&#125;, state = 0x1&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Challenge-exercises"><a href="#Challenge-exercises" class="headerlink" title="Challenge exercises"></a>Challenge exercises</h1><p>上述模拟的进程切换是通过进程主动调用<code>thread_switch</code>完成的，有以下缺点：<br>1、假如用户进程A阻塞等待系统调用结果，用户进程B不会被执行，因为xv6的调度器不知道用户进程A被取消执行。<br>2、不同进程不能在不同核上并发执行，因为xv6的调度器没有将多个进程并发执行的策略。在当前的实现下，进程不能被并发执行，例如不同处理器同时调用<code>thread_schedule</code>的话会导致错误。</p>
<p>有以下解决方法：<br>1、<a href="https://en.wikipedia.org/wiki/Scheduler_activations" target="_blank" rel="noopener">scheduler activations</a><br>2、one kernel thread per user-level thread (as Linux kernels do)<br>借助locks、condition variables、barriers等，尝试在xv6实现其中一种方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/" itemprop="url">笔记016 - Lab4: Preemptive Multitasking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:17:47+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h1><p>任务：扩展jos使之支持多处理器；添加系统调用支持用户进程创建新进程；实现协作性循环调度，当前进程自愿放弃cpu或exit的时候允许内核由一个进程切换到另一个进程。</p>
<h2 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h2><p>jos支持“对称多处理”(SMP：symmetric multiprocessing)，这是一种多处理器模型，所有cpu都能等价访问系统资源，如内存和I/O总线。在SMP中，尽管所有cpu在功能上是相同的，在引导过程中仍然可以将它们分为两类：1、引导处理器BSP（the bootstrap processor）：负责初始化系统和启动操作系统；2、应用程序处理器APs（the application processors）：在操作系统启动之后由BSP激活，然后开始运行。硬件和BIOS决定哪个处理器是BSP。<strong>到目前为止，所有jos代码都是运行在BSP上的。</strong></p>
<p>在SMP系统中，每个cpu都有一个附带的局部高级可编程中断处理器LAPIC（local APIC：Advanced Programmable Interrupt Controller）。LAPIC负责在整个系统中传递中断。LAPIC为其所连接的cpu提供一个唯一的标识符。在lab4中，我们使用LAPIC单元的三个基本功能：<br>1、读取LAPIC标识符APIC ID以识别我们的代码当前运行在哪个cpu上。（见cpunum()）<br>2、从BSP处发送STARTUP处理器间中断IPI（interprocessor interrupt）到APs，启动其他cpu。（见<code>lapic_startap()</code>）<br>3、part C将编程LAPIC的内置计时器，触发时钟中断以支持抢占式多任务调度。（见<code>apic_init()</code>）</p>
<p>处理器通过内存映射I/O MMIO（memory-mapped I/O）来访问附带的LAPIC。在MMIO中，一部分物理内存是硬连线到一些I/O设备的寄存器上的，所以可以通过使用相同的用以访问内存的load/store指令来访问设备寄存器。关于IO hole，我们已经使用了物理地址0xA0000来写VGA display缓存。LAPIC存放的IO hole起始物理地址是0xFE000000（4G空间中的32m），使用在KERNBASE的直接映射来访问的话，这个地址太高了。在jos中，虚拟内存映射在MMIOBASE位置留出了4MB空间以映射设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 1: 实现kern/pmap.c的mmio_map_region函数，在kern/lapic.c的lapic_init中查看mmio_map_region函数的使用情况。需要做完Exercise 2之后才能通过对于mmio_map_region的测试。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><br><span class="line">// location.  Return the base of the reserved region.  size does *not*</span><br><span class="line">// have to be multiple of PGSIZE.</span><br><span class="line">//</span><br><span class="line">// jianzzz: 我们可能会多次调用mmio_map_region()，每一次给出pa和size，将会将pa映射到递增的va，映射范围是size(以PGSIZE为大小向上对齐)。若映射地址超出MMIOLIM则越界。</span><br><span class="line">void *</span><br><span class="line">mmio_map_region(physaddr_t pa, size_t size)</span><br><span class="line">&#123; </span><br><span class="line">	static uintptr_t base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	// Reserve size bytes of virtual memory starting at base and</span><br><span class="line">	// map physical pages [pa,pa+size) to virtual addresses</span><br><span class="line">	// [base,base+size).  Since this is device memory and not</span><br><span class="line">	// regular DRAM, you&apos;ll have to tell the CPU that it isn&apos;t</span><br><span class="line">	// safe to cache access to this memory.  Luckily, the page</span><br><span class="line">	// tables provide bits for this purpose; simply create the</span><br><span class="line">	// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><br><span class="line">	// write-through) in addition to PTE_W.  (If you&apos;re interested</span><br><span class="line">	// in more details on this, see section 10.5 of IA32 volume</span><br><span class="line">	// 3A.)</span><br><span class="line">	//</span><br><span class="line">	// Be sure to round size up to a multiple of PGSIZE and to</span><br><span class="line">	// handle if this reservation would overflow MMIOLIM (it&apos;s</span><br><span class="line">	// okay to simply panic if this happens). </span><br><span class="line">	// Your code here:</span><br><span class="line">	uint32_t sizeup = (uint32_t)ROUNDUP((char *) size, PGSIZE);</span><br><span class="line">	if(base + sizeup &gt; MMIOLIM)&#123;</span><br><span class="line">		panic(&quot;mmio_map_region: requested size to map went over MMIOLIM&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	boot_map_region(kern_pgdir,base,sizeup,pa,PTE_PCD | PTE_PWT | PTE_W | PTE_P);</span><br><span class="line">	base += sizeup; </span><br><span class="line">	//panic(&quot;mmio_map_region not implemented&quot;);</span><br><span class="line">	return (void *)(base-sizeup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h2><p>在启动APs之前，BSP从BIOS的内存区域中读取MP配置表，收集多处理器系统的信息，比如CPUs数目、APIC IDs、LAPIC单元的MMIO地址。见kern/mpconfig.c的<code>mp_init()</code>。</p>
<p>kern/init.c的<code>boot_aps()</code>函数驱动AP启动程序的运行。APs在实模式下启动，与boot/boot.S的引导过程相似：<code>boot_aps()</code>将AP入口代码（kern/mpentry.S）拷贝到实模式下的一个可寻址的内存位置。与boot/boot.S的引导过程不同的是，jos会控制AP将会在哪里开始执行代码；jos将入口代码拷贝到0x7000（<code>MPENTRY_PADDR</code>），但640KB以下的任何unused、page-aligned的物理地址都被使用。</p>
<p>此后，<code>boot_aps()</code>逐一激活APs，通过给匹配AP的LAPIC发送STARTUP IPIs以及一个初始CS:IP地址，AP将在该地址上（即<code>MPENTRY_PADDR</code>）执行入口代码。kern/mpentry.S在简单设置之后将AP运行模式设为保护模式，开启分页，然后调用c函数<code>mp_main()</code>（also in kern/init.c）。<code>boot_aps()</code>等待AP发送<code>CPU_STARTED</code>信号（见struct CpuInfo的<code>cpu_status</code>域），然后激活下一个AP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 2. 阅读boot_aps()和mp_main()，以及kern/mpentry.S，了解APs启动过程的control flow transfer。修改kern/pmap.c的page_init()实现，避免在MPENTRY_PADDR分配页，保证APs启动代码的拷贝、运行安全。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4:</span><br><span class="line">	// Change your code to mark the physical page at MPENTRY_PADDR</span><br><span class="line">	// as in use</span><br><span class="line"></span><br><span class="line">	// The example code here marks all physical pages as free.</span><br><span class="line">	// However this is not truly the case.  What memory is free?</span><br><span class="line">	//  1) Mark physical page 0 as in use.</span><br><span class="line">	//     This way we preserve the real-mode IDT and BIOS structures</span><br><span class="line">	//     in case we ever need them.  (Currently we don&apos;t, but...)</span><br><span class="line">	//  第一页数据是被使用的，该页保存了实模式IDT和BIOS数据结构</span><br><span class="line">	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br><span class="line">	//     is free.</span><br><span class="line">	//  第二页至基本内存结束位置(640K)是可用的</span><br><span class="line">	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br><span class="line">	//     never be allocated.</span><br><span class="line">	//  [IOPHYSMEM, EXTPHYSMEM),即[0x0A0000,0x100000)--[640K,1MB)是被使用的</span><br><span class="line">	//  4) Then extended memory [EXTPHYSMEM, ...).</span><br><span class="line">	//     Some of it is in use, some is free. Where is the kernel</span><br><span class="line">	//     in physical memory?  Which pages are already in use for</span><br><span class="line">	//     page tables and other data structures?</span><br><span class="line">	//  扩展内存开始位置至当前pages数组存储的末端为不可使用的部分，其中包括页目录空间和映射内存的pages数组空间!!!</span><br><span class="line">	//  当前pages数组存储的末端开始至可用内存末端即为可用的</span><br><span class="line">	//</span><br><span class="line">	// Change the code to reflect this.</span><br><span class="line">	// NB: DO NOT actually touch the physical memory corresponding to</span><br><span class="line">	// free pages!</span><br><span class="line"></span><br><span class="line">	// uint32_t page_IOPHYSMEMBEGIN = npages_basemem;</span><br><span class="line">	uint32_t page_IOPHYSMEMBEGIN = (uint32_t)IOPHYSMEM / PGSIZE;</span><br><span class="line"></span><br><span class="line">	// uint32_t num_pages_io_hole = 96;</span><br><span class="line">	// uint32_t page_EXTPHYSMEMBEGIN = npages_basemem + num_pages_io_hole;</span><br><span class="line">	uint32_t page_EXTPHYSMEMBEGIN = (uint32_t)EXTPHYSMEM / PGSIZE;</span><br><span class="line">	</span><br><span class="line">	// 内核代码存放于0x100000处，即1M处，KERNBASE是内核代码存储起点的虚拟地址</span><br><span class="line">	// 对于存于物理地址1M后的数据，其虚拟地址减去KERNBASE的值相当于该处与内核代码存储起点虚拟地址位置的差，</span><br><span class="line">	// 而不是与0x0的差, 需要加上1M的空间</span><br><span class="line">	// 1M = 256 page </span><br><span class="line">	// uint32_t num_kernelpages = (((uint32_t) boot_alloc(0)) - KERNBASE) / PGSIZE;</span><br><span class="line">	//uint32_t page_KernelPageInfoEnd = npages_basemem + num_pages_io_hole + num_kernelpages; </span><br><span class="line">	uint32_t page_KernelPageInfoEnd = (((uint32_t) boot_alloc(0)) - KERNBASE) / PGSIZE + 256;    </span><br><span class="line">	 </span><br><span class="line">	page_free_list = NULL;</span><br><span class="line">	size_t i;</span><br><span class="line">	//pages数组与实际物理空间存在映射关系，但没有使用实际空间存储物理页位置</span><br><span class="line">	for (i = 0; i &lt; npages; i++) &#123;</span><br><span class="line">		if(i==0 ||</span><br><span class="line">			//Lab4 : page at MPRENTRY_PADDR, reserved for CPU startup code . e.g. 0x7000</span><br><span class="line">			i == PGNUM(MPENTRY_PADDR) ||</span><br><span class="line">			//(i&gt;=page_IOPHYSMEM &amp;&amp; i&lt;page_EXTPHYSMEMBEGIN) ||</span><br><span class="line">			//(i&gt;=page_EXTPHYSMEMBEGIN &amp;&amp; i&lt;page_KernelPageInfoEnd) ||</span><br><span class="line">			(i&gt;=page_IOPHYSMEMBEGIN &amp;&amp; i&lt;page_KernelPageInfoEnd)</span><br><span class="line">			)&#123;</span><br><span class="line">			pages[i].pp_ref = 1;</span><br><span class="line">			continue;	</span><br><span class="line">		&#125; </span><br><span class="line">		pages[i].pp_ref = 0;		</span><br><span class="line">		//往回指的指针pp_link要越过非空物理页,这样page_free_list才能通过pp_link往回获取空闲空间</span><br><span class="line">		//双向链表</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 1. 比较kern/mpentry.S和boot/boot.S。请记住：kern/mpentry.S被编译和链接后是运行在KERNBASE之上的，就像其他程序一样。设计MPBOOTPHYS宏的目的是什么？为什么boot/boot.S不需要它？</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kern/mpentry.S的内容原先是加载在内核程序的页空间中的，在BSP激活其他APs之前，BSP会将这部分内容移到MPENTRY_PADDR物理页中。所以AP在执行kern/mpentry.S时，kern/mpentry.S中的标记符物理地址需要以MPENTRY_PADDR为基础重新计算。MPBOOTPHYS宏就是用于确定kern/mpentry.S中的标识符物理地址。</span><br><span class="line">对于boot/boot.S来说，它是由bios加载到0x7c00的，然后开始执行这部分代码，由于当时尚未开启分页，链接地址即为物理地址，所以boot/boot.S中标识符的物理地址是直接由链接地址确定的。</span><br></pre></td></tr></table></figure>
<h2 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h2><p>多处理器操作系统很重要的一点是区分每个处理器私有的处理器状态和整个系统共享的全局状态。kern/cpu.h定义了per-CPU状态的大部分，包括struct CpuInfo（存储per-CPU变量）。cpunum()返回的是调用它的cpu的ID，该值可以索引cpus数组。thiscpu是个宏定义，指向当前cpu的struct CpuInfo。<br>以下是部分per-CPU状态：<br>1、<strong>Per-CPU kernel stack</strong>：多个cpu可以同时trap到内核中，为了防止干扰彼此的运行，需要为每个处理器设置单独的栈空间。内核物理空间中数组<code>percpu_kstacks[NCPU][KSTKSIZE]</code>保存了NCPU个栈空间。BSP的内核栈地址是bootstack，映射到虚拟地址KSTACKTOP之下的KSTKSIZE大小的空间。紧随着，越过KSTKGAP字节之后，映射CPU1栈空间，以此类推。<br>2、<strong>Per-CPU TSS and TSS descriptor</strong>：TSS任务状态段用于寻位每个cpu的内核栈。CPU i的TSS存于cpus[i].cpu_ts中，相关联的TSS描述符定义在GDT入口gdt[(GD_TSS0 &gt;&gt; 3) + i]。kern/trap.c定义的全局ts变量不再生效。<br>3、<strong>Per-CPU current environment pointer</strong>：因为每个cpu可以同时运行不同的用户进程，因此重新定义curenv指向<code>cpus[cpunum()].cpu_env</code>，它指向的是运行在当前cpu上的当前进程。<br>4、所有的寄存器，包括系统寄存器，对每个cpu来说都是私有的。因此，初始化这些寄存器的指令，比如lcr3(), ltr(), lgdt(), lidt()等，都必须在每个寄存器上执行一次。<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>正是用于这个目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 3. 修改kern/pmap.c的mem_init_mp()函数，将每个cpu的栈映射到KSTACKTOP以下部分，参考inc/memlayout.h。每个栈的大小是KSTKSIZE+KSTKGAP字节。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">mem_init_mp(void)</span><br><span class="line">&#123; </span><br><span class="line">	//     Permissions: kernel RW, user NONE</span><br><span class="line">	//</span><br><span class="line">	// LAB 4: Your code here:</span><br><span class="line">	int i=0;</span><br><span class="line">	uint32_t bottom_stack = KSTACKTOP - KSTKSIZE;</span><br><span class="line">	for (i = 0; i &lt; NCPU; i++) &#123;</span><br><span class="line">		boot_map_region(kern_pgdir, bottom_stack, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span><br><span class="line">		bottom_stack -= KSTKGAP; // guard</span><br><span class="line">		bottom_stack -= KSTKSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 4. kern/trap.c的trap_init_percpu()函数初始化了BSP的TSS和TSS描述符，修改这部分代码，使之支持所有cpu。提示：新代码将不会使用到全局变量ts。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">trap_init_percpu(void)</span><br><span class="line">&#123; </span><br><span class="line">	// ltr sets a &apos;busy&apos; flag in the TSS selector, so if you</span><br><span class="line">	// accidentally load the same TSS on more than one CPU, you&apos;ll</span><br><span class="line">	// get a triple fault.  If you set up an individual CPU&apos;s TSS</span><br><span class="line">	// wrong, you may not get a fault until you try to return from</span><br><span class="line">	// user space on that CPU.</span><br><span class="line">	//</span><br><span class="line">	// LAB 4: Your code here:</span><br><span class="line"></span><br><span class="line">	// Setup a TSS so that we get the right stack</span><br><span class="line">	// when we trap to the kernel.</span><br><span class="line">	//ts.ts_esp0 = KSTACKTOP;</span><br><span class="line">	//ts.ts_ss0 = GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = (uintptr_t) percpu_kstacks[thiscpu-&gt;cpu_id] + KSTKSIZE;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line"></span><br><span class="line">	// Initialize the TSS slot of the gdt.</span><br><span class="line">	//gdt[GD_TSS0 &gt;&gt; 3] = SEG16(STS_T32A, (uint32_t) (&amp;ts),</span><br><span class="line">	//				sizeof(struct Taskstate) - 1, 0);</span><br><span class="line">	//gdt[GD_TSS0 &gt;&gt; 3].sd_s = 0;</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (uint32_t) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">					sizeof(struct Taskstate) - 1, 0);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id].sd_s = 0;</span><br><span class="line"></span><br><span class="line">	// Load the TSS selector (like other segment selectors, the</span><br><span class="line">	// bottom three bits are special; we leave them 0)</span><br><span class="line">	//ltr(GD_TSS0);  </span><br><span class="line">        //ltr(((GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id) &lt;&lt; 3); </span><br><span class="line">	ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; 3)); </span><br><span class="line"></span><br><span class="line">	// Load the IDT</span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多处理器总结要点"><a href="#多处理器总结要点" class="headerlink" title="多处理器总结要点"></a>多处理器总结要点</h2><p>jos支持多处理器之后，大概的启动过程如下：<br>1、BSP调用<code>mem_init()</code>函数，主要完成创建页目录、pages数组、envs数组、映射pages数组/envs数组/BSP内核栈等到页目录中。<br>2、BSP调用<code>env_init()</code>函数，初始化envs数组；同时调用<code>env_init_percpu()</code>函数加载当前cpu的GDT和gs/fs/es/ds/ss段描述符。<br>3、BSP调用<code>trap_init()</code>函数，初始化IDT表；同时调用<code>trap_init_percpu()</code>函数初始化当前cpu的TSS和IDT。<br>4、BSP调用<code>mp_init()</code>函数，<code>mp_init()</code>函数通过调用<code>mpconfig()</code>从BIOS中读取浮动指针mp，从mp中找到struct mpconf多处理器配置表，然后根据这个结构体内的entries信息（processor table entry）对各个cpu结构体进行配置（主要是cpuid）。如果proc-&gt;flag是MPPROC_BOOT，说明这个入口对应的处理器是用于启动的处理器，我们把结构体数组cpus[ncpu]地址赋值给bootcpu指针。注意这里ncpu是个全局变量，那么这里实质上就是把cpus数组的第一个元素的地址给了bootcpu。如果出现任何entries匹配错误，则认为处理器的初始化失败了，不能用多核处理器进行机器的运行。<br>5、BSP调用<code>lapic_init()</code>函数，映射lapic物理地址到页目录（映射的虚拟地址递增），设置时钟，允许APIC接收中断。<br>6、BSP调用<code>pic_init()</code>函数，初始化8259A中断控制器，允许生成中断。<br>7、BSP调用<code>boot_aps()</code>函数，复制cpu启动代码到0x7000，然后对每个cpu分别确定内核栈地址后调用<code>lapic_startap()</code>函数。<code>lapic_startap()</code>函数命令对应cpu从加载代码处开始执行。BSP使用轮询等待目标cpu启动完成（目标cpu使用自旋锁通知），然后激活下一个cpu。<br>8、AP（cpu）从加载代码处启动，加载gdt表、手动设置初始页表、开启保护模式、分页等，然后跳转到<code>mp_main()</code>函数；<code>mp_main()</code>函数直接切换到页目录，然后调用<code>lapic_init()</code>函数映射lapic物理地址到页目录（映射的虚拟地址递增），并允许APIC接收中断；调用<code>env_init_percpu()</code>函数加载当前cpu的GDT和gs/fs/es/ds/ss段描述符；调用<code>trap_init_percpu()</code>函数初始化当前cpu的TSS和IDT，然后使用自旋锁设置启动完成标识，并调用<code>sched_yield()</code>函数尝试开始执行可执行进程。<br>9、BSP上自行创建进程，并调用<code>sched_yield()</code>函数尝试开始执行可执行进程。</p>
<p>需要注意到：<strong>每个cpu都有自己独立的寄存器和CPU栈、TSS，但是整个内核中只有一份envs数组、pages数组、内核页目录、idt、gdt、lapic物理地址。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题是：lapic物理地址只有一个，每次启动cpu的过程中是怎么改变lapic的呢？还有cpunum()的实现方式不明白。。。。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>启动APs之后，我们需要解决多处理器并发执行内核代码的竞争条件。实现这一点的最简单的方法是使用一个内核锁，该内核锁是一个全局锁，一旦某个进程进入内核模式则尝试获取该锁，当进程返回到用户模式时释放该锁。在这个模型中，在用户模式下的进程可以并发在任何可用cpu上运行，但至多一个进程可以运行在内核模式下，其他试图进入内核模式的进程被迫等待。<br>kern/spinlock.h定义了内核锁<code>kernel_lock</code>，并提供<code>lock_kernel()</code>和<code>unlock_kernel()</code>方法用于获取和释放锁。需要在以下四个地方设置内核锁：<br>1、<code>i386_init()</code>：在BSP激活其他cpu之前获取内核锁。<br>2、<code>mp_main()</code>：初始化AP之后获取内核锁，然后调用<code>sched_yield()</code>在该AP上运行进程。<br>3、<code>trap()</code>：如果是由用户模式trap到内核的，获取内核锁。通过<code>tf_cs</code>的低两位判断是用户模式还是内核模式。<br>4、<code>env_run()</code>：在切换为用户模式之前释放内核锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 5: 完成以上任务。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">i386_init():</span><br><span class="line">	// Acquire the big kernel lock before waking up APs</span><br><span class="line">	// Your code here:</span><br><span class="line">	lock_kernel();</span><br><span class="line">	// Starting non-boot CPUs</span><br><span class="line">	boot_aps(); </span><br><span class="line"></span><br><span class="line">mp_main():</span><br><span class="line">	// Now that we have finished some basic setup, call sched_yield()</span><br><span class="line">	// to start running processes on this CPU.  But make sure that</span><br><span class="line">	// only one CPU can enter the scheduler at a time!</span><br><span class="line">	//</span><br><span class="line">	// Your code here: </span><br><span class="line">	lock_kernel();</span><br><span class="line">	sched_yield(); </span><br><span class="line"></span><br><span class="line">trap():</span><br><span class="line">        if ((tf-&gt;tf_cs &amp; 3) == 3) &#123;</span><br><span class="line">		// Trapped from user mode.</span><br><span class="line">		// Acquire the big kernel lock before doing any</span><br><span class="line">		// serious kernel work.</span><br><span class="line">		// LAB 4: Your code here.</span><br><span class="line">		lock_kernel();</span><br><span class="line">		assert(curenv);</span><br><span class="line"></span><br><span class="line">env_run():</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); </span><br><span class="line">	//lab4</span><br><span class="line">	unlock_kernel(); </span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));//never return</span><br></pre></td></tr></table></figure>
<p>在<code>sched_yield()</code>中实现循环调度时会调用<code>env_run()</code>函数，进而释放内核锁。经过上述加锁、释放锁操作后，只有当BSP激活所有APs并且开始调用<code>sched_yield()</code>运行用户程序时，其他CPU才可能开始执行用户程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 2. 使用内核锁可以保证一次只有一个CPU可以运行内核代码。那么，为何还需要将每个cpu的CPU栈分开？请描述一个使用了内核锁和共享内核栈后出错的场景。</span><br></pre></td></tr></table></figure>
<p>如果使用共享的内核栈的话，当出现中断时，硬件会先自动将相关寄存器进栈，然后才执行锁的检查，共享内核栈可能会导致系统崩溃。<br>支持多个cpu的时候，只有一份内核页目录，所有cpu都会使用这个页目录映射CPU栈。不同的CPU栈映射到不同的虚拟地址上。<br>在此需要注意的是另一个现象：不同的用户进程是可以同时将用户栈物理地址映射到UXSTACKTOP上的。这是因为每一个用户进程都有一份独立的页目录，创建用户进程的时候会分配和映射一页用户栈物理页到UXSTACKTOP上，多个cpu同时运行多个用户进程的时候，实际上都是使用各自的页目录进行寻址和存储数据到各自的用户栈物理页上的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Challenge: 内核锁易于使用，但它消除了内核模式下的所有并发。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，使用的方法称为细粒度锁（fine-grained locking）。细粒度锁可以显著提高性能，但更难以实现且容易出错。</span><br><span class="line">若要在jos实现细粒度锁，可以自由决定锁的粒度（即每个锁保护的数据量大小）。可以使用自旋锁来实现互斥访问以下jos内容：</span><br><span class="line">The page allocator：页分配器</span><br><span class="line">The console driver：控制台驱动</span><br><span class="line">The scheduler：调度器</span><br><span class="line">The inter-process communication (IPC) state：进程间通信状态，将在part C实现。</span><br></pre></td></tr></table></figure>
<h2 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h2><p>此部分内容将修改jos内核使之可以以循环机制（round-robin）交替调度多个进程。jos的循环机制如下：<br>1、kern/sched.c的<code>sched_yield()</code>函数负责选择一个新的进程来执行。它从上一个运行进程之后开始，以循环方式顺序搜索envs[]数组，选择第一个状态为<code>ENV_RUNNABLE</code>的进程，并调用<code>env_run()</code>函数跳转到该进程。<br>2、<code>sched_yield()</code>不能同时在两个cpu上执行调度同一个进程。区分某个进程是否正在某个cpu上运行的方法是：该进程的状态是<code>ENV_RUNNING</code>。<br>3、用户进程可以调用<code>sys_yield()</code>系统调用（该函数调用<code>sched_yield()</code>函数），自愿放弃cpu资源给其他进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exercise 6. 在sched_yield()中实现循环调度。在syscall()中分发sys_yield()。确保在mp_main()中调用sched_yield()。在kern/init.c中创建三个或三个以上进程，执行user/yield.c。在yield程序退出之后，系统将不存在可执行进程，并陷入到monitor中。</span><br><span class="line">如果CPUS=1，所有进程将会成功执行。</span><br><span class="line">如果CPUS&gt;1，一旦没有更多可运行环境，由于未处理的定时器中断可能导致一般性保护异常或内核页错误。后面将解决该问题。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">sched_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct Env *idle;</span><br><span class="line">		 </span><br><span class="line">	// Implement simple round-robin scheduling.</span><br><span class="line">	//</span><br><span class="line">	// Search through &apos;envs&apos; for an ENV_RUNNABLE environment in</span><br><span class="line">	// circular fashion starting just after the env this CPU was</span><br><span class="line">	// last running.  Switch to the first such environment found.</span><br><span class="line">	//</span><br><span class="line">	// If no envs are runnable, but the environment previously</span><br><span class="line">	// running on this CPU is still ENV_RUNNING, it&apos;s okay to</span><br><span class="line">	// choose that environment.</span><br><span class="line">	//</span><br><span class="line">	// Never choose an environment that&apos;s currently running on</span><br><span class="line">	// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="line">	// no runnable environments, simply drop through to the code</span><br><span class="line">	// below to halt the cpu.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here. </span><br><span class="line">	int i;</span><br><span class="line">	int current_env_idx = curenv ? ENVX(curenv-&gt;env_id) : 0;</span><br><span class="line">	int idx = curenv ? (current_env_idx + 1) % NENV : 0; // start by looking at the next process</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; NENV; i++) &#123;</span><br><span class="line">		if (envs[idx].env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(&amp;envs[idx]);</span><br><span class="line">		idx = (idx + 1) % NENV;</span><br><span class="line">	&#125; </span><br><span class="line">	if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		env_run(curenv);</span><br><span class="line">  </span><br><span class="line">	// sched_halt never returns</span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 3.env_run()修改了参数e的成员状态之后就会调用lcr3切换到进程的页目录，这时候内存管理单元MMU所使用的寻址上下文立即发生了变化。在地址切换前后，为什么参数e仍能够被引用？</span><br></pre></td></tr></table></figure>
<p>因为对于所有env来说，内核空间的虚拟地址是相同的，这部分地址也被映射进env的页目录。参数e本身也是内核空间的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 4.每次内核从一个进程切换到另一个进程的时候，需要保存旧进程的寄存器以便后面恢复，怎么做？什么时候这样做？</span><br></pre></td></tr></table></figure>
<p>由内核模式进入trap()函数时，只管调用<code>trap_dispatch()</code>就行，就算调用之后会执行新的env，也不涉及旧env寄存器存储的问题。但如果是由用户模式进入trap()函数时（trapframe上的cs表明是否来自于用户模式），可能会导致进程切换，因此在调用<code>trap_dispatch()</code>之前需要保存旧env的寄存器。具体做法是：<strong>curenv-&gt;env_tf = *tf;</strong>。之后如果切换到另一个进程，则会调用<code>env_run()</code>函数，并更新curenv变量。为什么这样子就可以保存呢？看一下变量的定义：1、<strong>#define curenv (thiscpu-&gt;cpu_env)</strong>，2、<strong>#define thiscpu (&amp;cpus[cpunum()])</strong>、3、thiscpu的<code>cpu_env</code>定义是：<strong>struct Env *cpu_env;</strong>。由上可知，<code>cpu_env</code>是一个指针，始终指向envs数组的一员，而它的更新时机在于调用<code>env_run()</code>函数的时候，实际上就是更新当前cpu执行的进程env。所以在trap()函数中通过执行<strong>curenv-&gt;env_tf = *tf;</strong>就可以将旧进程保存在栈上的trapframe值复制到<code>cpu_env</code>所指向envs数组的一员上，下次若调用到该进程，又可以恢复寄存器环境了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 将调度方式扩展为固定优先级调度，优先级高的进程将先于优先级低的进程被调度。编写测试程序测试调用顺序是正确的。</span><br></pre></td></tr></table></figure>
<p>扩展Env数据结构，添加优先级变量，然后修改调度函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Choose a user environment to run and run it.</span><br><span class="line">void</span><br><span class="line">sched_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct Env *idle;</span><br><span class="line">		 </span><br><span class="line">	// Implement simple round-robin scheduling.</span><br><span class="line">	//</span><br><span class="line">	// Search through &apos;envs&apos; for an ENV_RUNNABLE environment in</span><br><span class="line">	// circular fashion starting just after the env this CPU was</span><br><span class="line">	// last running.  Switch to the first such environment found.</span><br><span class="line">	//</span><br><span class="line">	// If no envs are runnable, but the environment previously</span><br><span class="line">	// running on this CPU is still ENV_RUNNING, it&apos;s okay to</span><br><span class="line">	// choose that environment.</span><br><span class="line">	//</span><br><span class="line">	// Never choose an environment that&apos;s currently running on</span><br><span class="line">	// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="line">	// no runnable environments, simply drop through to the code</span><br><span class="line">	// below to halt the cpu.</span><br><span class="line">	// LAB 4: Your code here.  </span><br><span class="line">  	// use priority, lab4 challenge</span><br><span class="line">	enum EnvPriority priority;</span><br><span class="line">	int i = 0;;</span><br><span class="line">	int current_env_idx = curenv ? ENVX(curenv-&gt;env_id) : 0;</span><br><span class="line">	int idx = curenv ? (current_env_idx + 1) % NENV : 0; // start by looking at the next process</span><br><span class="line"> 	for (priority = ENV_PRIORITY_HIGH; priority &lt;= ENV_PRIORITY_LOW; priority++) &#123; </span><br><span class="line">		for (i = 0; i &lt; NENV; i++) &#123;</span><br><span class="line">			if (envs[idx].env_status == ENV_RUNNABLE &amp;&amp; envs[idx].priority == priority)&#123; </span><br><span class="line">				if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING &amp;&amp; curenv-&gt;priority &lt; envs[idx].priority)&#123; </span><br><span class="line">					env_run(curenv);</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					env_run(&amp;envs[idx]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			idx = (idx + 1) % NENV;</span><br><span class="line">		&#125; </span><br><span class="line"> 	&#125;</span><br><span class="line">	if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123; </span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// sched_halt never returns</span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试程序为user/envpriority.c，注意需要在kern/Makefrag中添加<strong>KERN_BINFILES += user/envpriority</strong>。测试程序使用到下面添加的系统调用，整体思路是由当前root进程fork多个子进程，每次fork之后设置子进程的优先级，然后调用<code>sys_yield()</code>系统调用放弃cpu，观察内核调度进程结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// test env priority</span><br><span class="line"></span><br><span class="line">#include &lt;inc/string.h&gt;</span><br><span class="line">#include &lt;inc/lib.h&gt;</span><br><span class="line"></span><br><span class="line">envid_t dumbfork_priority(uint32_t priority);</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	envid_t who,root;</span><br><span class="line">	int i,p;</span><br><span class="line">	root = sys_getenvid();</span><br><span class="line">	for (p = 1; p &lt;= 5; ++p) &#123;</span><br><span class="line">		// fork a child process</span><br><span class="line">		if(root == sys_getenvid())&#123;</span><br><span class="line">        	who = dumbfork_priority(p); </span><br><span class="line"></span><br><span class="line">			// print a message and yield to the other a few times</span><br><span class="line">			for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">				cprintf(&quot;%d: I am the %s! my env priority is %d\n&quot;, i, who ? &quot;parent&quot; : &quot;child&quot;, sys_env_get_priority());</span><br><span class="line">				sys_yield();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">duppage(envid_t dstenv, void *addr)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	// This is NOT what you should do in your fork.</span><br><span class="line">	//alloc a page mapping at child&apos;s addr</span><br><span class="line">	if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_alloc: %e&quot;, r);</span><br><span class="line">	//map child&apos;s new page(mapping at addr) at parent&apos;s UTEMP</span><br><span class="line">	if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line">	//copy page data mapping at parent&apos;s addr to page mapping at parent&apos;s UTEMP</span><br><span class="line">	//as a result, it fills in child&apos;s page</span><br><span class="line">	memmove(UTEMP, addr, PGSIZE);</span><br><span class="line">	if ((r = sys_page_unmap(0, UTEMP)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_unmap: %e&quot;, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">envid_t</span><br><span class="line">dumbfork_priority(uint32_t priority)</span><br><span class="line">&#123;</span><br><span class="line">	envid_t envid;</span><br><span class="line">	uint8_t *addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[];</span><br><span class="line"></span><br><span class="line">	// Allocate a new child environment.</span><br><span class="line">	// The kernel will initialize it with a copy of our register state,</span><br><span class="line">	// so that the child will appear to have called sys_exofork() too -</span><br><span class="line">	// except that in the child, this &quot;fake&quot; call to sys_exofork()</span><br><span class="line">	// will return 0 instead of the envid of the child.</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123;</span><br><span class="line">		// We&apos;re the child.</span><br><span class="line">		// The copied value of the global variable &apos;thisenv&apos;</span><br><span class="line">		// is no longer valid (it refers to the parent!).</span><br><span class="line">		// Fix it and return 0.</span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent.</span><br><span class="line">	//set child&apos;s prioroty</span><br><span class="line">	sys_env_set_priority(envid,priority);</span><br><span class="line">	// Eagerly copy our entire address space into the child.</span><br><span class="line">	// This is NOT what you should do in your fork implementation.</span><br><span class="line">	for (addr = (uint8_t*) UTEXT; addr &lt; end; addr += PGSIZE)</span><br><span class="line">		duppage(envid, addr);</span><br><span class="line"></span><br><span class="line">	// Also copy the stack we are currently running on.</span><br><span class="line">	duppage(envid, ROUNDDOWN((void*)USTACKTOP - PGSIZE, PGSIZE)); </span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"></span><br><span class="line">	return envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/1.PNG" title="进程优先级运行结果"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! jos当前不支持应用使用x86处理器的x87 floating-point单元(FPU)、MMX指令或Streaming SIMD Extensions(SSE)。扩展Env数据结构，添加浮点状态成员（floating point state），并在进程切换代码中保存和恢复浮点状态。可使用FXSAVE和FXRSTOR指令，它们在最近的处理器才被介绍，在旧的i386用户手册中没有介绍。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h2><p><code>sys_exofork</code>：创建一个进程，创建页目录（映射内核空间，UTOP以下部分在页目录中的映射为空）、填充trapframe（包括<code>env_alloc()</code>中用户栈指针指向<code>e-&gt;env_tf.tf_esp = USTACKTOP;</code>，请注意，子进程只有将esp指向USTACKTOP，并没有再次为栈分配空间，而根父进程的栈空间是在<code>env_create()</code>的时候通过调用<code>env_alloc()</code>之后调用<code>load_icode()</code>实现的）、复制父进程的trapframe…，没有用户程序地址映射到地址空间、状态为不可执行。新进程的寄存器状态与调用<code>sys_exofork</code>的进程一样。调用<code>sys_exofork</code>的父进程返回子进程id，子进程返回0（具体原因可参考x86的fork实现）。<br><code>sys_env_set_status</code>：设置进程状态为<code>ENV_RUNNABLE</code>或<code>ENV_NOT_RUNNABLE</code>，通常是进程的地址映射和寄存器状态设置完毕之后设置进程可被执行。<br><code>sys_page_alloc</code>：分配一页物理页，并在指定进程的地址空间上映射到给定的虚拟地址。<br><code>sys_page_map</code>：将A进程中映射到虚拟地址<code>va_a</code>的物理页映射到B进程的虚拟地址<code>va_b</code>，设置给出的权限。从而两个进程可以以不同的权限访问同一个物理页。<br><code>sys_page_unmap</code>：在指定进程的地址空间上解除给定的虚拟地址上的映射。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 7.完成以上内容。jos的envid2env()函数可以根据id获取对应的进程结构，并且传入0可以获取当前进程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a new environment.</span><br><span class="line">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_NO_FREE_ENV if no free environment is available.</span><br><span class="line">//	-E_NO_MEM on memory exhaustion.</span><br><span class="line">static envid_t</span><br><span class="line">sys_exofork(void)</span><br><span class="line">&#123;</span><br><span class="line">	// Create the new environment with env_alloc(), from kern/env.c.</span><br><span class="line">	// It should be left as env_alloc created it, except that</span><br><span class="line">	// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><br><span class="line">	// from the current environment -- but tweaked so sys_exofork</span><br><span class="line">	// will appear to return 0.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_exofork not implemented&quot;);</span><br><span class="line">	struct Env *newEnv; </span><br><span class="line">	//set kernal stack, page dir, trapframe...</span><br><span class="line">	int r = env_alloc(&amp;newEnv,curenv-&gt;env_id);</span><br><span class="line">	if(r&lt;0) return r;</span><br><span class="line">	newEnv-&gt;env_status = ENV_NOT_RUNNABLE; </span><br><span class="line">	newEnv-&gt;env_tf = curenv-&gt;env_tf; </span><br><span class="line">	//or : memmove((void *) &amp;newEnv-&gt;env_tf, (void *) &amp;curenv-&gt;env_tf, sizeof(struct Trapframe));</span><br><span class="line">	//clear child&apos;s eax,so it will return pid 0</span><br><span class="line">	newEnv-&gt;env_tf.tf_regs.reg_eax = 0;</span><br><span class="line">	return newEnv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Set envid&apos;s env_status to status, which must be ENV_RUNNABLE</span><br><span class="line">// or ENV_NOT_RUNNABLE.</span><br><span class="line">//</span><br><span class="line">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if status is not a valid status for an environment.</span><br><span class="line">static int</span><br><span class="line">sys_env_set_status(envid_t envid, int status)</span><br><span class="line">&#123;</span><br><span class="line">	// Hint: You should set envid2env&apos;s third argument to 1, which will</span><br><span class="line">	// check whether the current environment has permission to set</span><br><span class="line">	// envid&apos;s status.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_env_set_status not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to set envid&apos;s status. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	if(status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) return -E_INVAL;</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a page of memory and map it at &apos;va&apos; with permission</span><br><span class="line">// &apos;perm&apos; in the address space of &apos;envid&apos;.</span><br><span class="line">// The page&apos;s contents are set to 0.</span><br><span class="line">// If a page is already mapped at &apos;va&apos;, that page is unmapped as a</span><br><span class="line">// side effect.</span><br><span class="line">//</span><br><span class="line">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span><br><span class="line">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span><br><span class="line">//	-E_INVAL if perm is inappropriate (see above).</span><br><span class="line">//	-E_NO_MEM if there&apos;s no memory to allocate the new page,</span><br><span class="line">//		or to allocate any necessary page tables.</span><br><span class="line">static int</span><br><span class="line">sys_page_alloc(envid_t envid, void *va, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_alloc not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true); </span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)va &gt;= UTOP || (uint32_t)va%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">	//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">	if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">		return -E_INVAL;</span><br><span class="line"></span><br><span class="line">	struct PageInfo *page = page_alloc(ALLOC_ZERO);</span><br><span class="line">	if(page == NULL) return -E_NO_MEM;</span><br><span class="line">	</span><br><span class="line">	//store page&apos;s mapping physical address and perm in va&apos;s mapping page table entry</span><br><span class="line">	r = page_insert(e-&gt;env_pgdir, page, va, perm);</span><br><span class="line">	if(r&lt;0) &#123;</span><br><span class="line">		page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">		return r;//-E_NO_MEM</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// Map the page of memory at &apos;srcva&apos; in srcenvid&apos;s address space</span><br><span class="line">// at &apos;dstva&apos; in dstenvid&apos;s address space with permission &apos;perm&apos;.</span><br><span class="line">// Perm has the same restrictions as in sys_page_alloc, except</span><br><span class="line">// that it also must not grant write access to a read-only</span><br><span class="line">// page.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change one of them.</span><br><span class="line">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span><br><span class="line">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span><br><span class="line">//	-E_INVAL is srcva is not mapped in srcenvid&apos;s address space.</span><br><span class="line">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span><br><span class="line">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&apos;s</span><br><span class="line">//		address space.</span><br><span class="line">//	-E_NO_MEM if there&apos;s no memory to allocate any necessary page tables.</span><br><span class="line">static int</span><br><span class="line">sys_page_map(envid_t srcenvid, void *srcva,</span><br><span class="line">	     envid_t dstenvid, void *dstva, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_map not implemented&quot;);</span><br><span class="line">	struct Env *srce,*dste; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(srcenvid,&amp;srce,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	r = envid2env(dstenvid,&amp;dste,true);//envid 0 means &quot;the current environment.&quot;</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)srcva &gt;= UTOP || (uint32_t)srcva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	if((uint32_t)dstva &gt;= UTOP || (uint32_t)dstva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	//return the page mapped at virtual address &apos;va&apos;</span><br><span class="line">	//pte_store stores the address of the page table entry for this page</span><br><span class="line">	pte_t *pte_store;</span><br><span class="line">	struct PageInfo *page = page_lookup(srce-&gt;env_pgdir, srcva, &amp;pte_store);</span><br><span class="line">	if(page == NULL) return -E_INVAL;//no page mapped at srcva</span><br><span class="line"></span><br><span class="line">	if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">	//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">	if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">		return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	if((*pte_store &amp; PTE_W) != PTE_W &amp;&amp; ((perm &amp; PTE_W) == PTE_W)) return -E_INVAL;//srcva is read-only but perm is writable</span><br><span class="line"></span><br><span class="line">	//store page&apos;s mapping physical address and perm in dstva&apos;s mapping page table entry</span><br><span class="line">	r = page_insert(dste-&gt;env_pgdir, page, dstva, perm);// allow to create page table</span><br><span class="line">	if(r&lt;0) &#123;</span><br><span class="line">		page_remove(dste-&gt;env_pgdir,dstva);</span><br><span class="line">		return r;//-E_NO_MEM</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Unmap the page of memory at &apos;va&apos; in the address space of &apos;envid&apos;.</span><br><span class="line">// If no page is mapped, the function silently succeeds.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span><br><span class="line">static int</span><br><span class="line">sys_page_unmap(envid_t envid, void *va)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_unmap not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)va &gt;= UTOP || (uint32_t)va%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 添加系统调用以读取某个进程的所有重要状态。实现一个用户程序，该程序fork一个子进程，运行该程序（即循环迭代sys_yield()），然后获取子进程的完整snapshot或checkpoint，然后执行子程序一段时间。最后，恢复子进程在检查点的状态，然后继续执行子进程。这相当于从某个中间状态replaying子进程的执行。使用sys_cgetc()或readline()函数保证子进程与用户之间进行交互，以便用户可以查看和改变其内部状态。确保子进程在检查点处恢复执行时，子进程&quot;forget&quot;了之前任何发生在检查点之后的内容。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h1><p>xv6实现的fork()将父进程所有物理页的内容拷贝给了分配给子进程的新物理页，类似于jos的dumbfork()函数。fork()过程中最“昂贵”的操作就是将父进程的地址空间拷贝给子进程。然而在子进程中，通常是紧接着就执行exec()，以新程序替代子进程执行。在这种情况下，父进程拷贝地址空间给子进程所花时间将被大大浪费了，因为子进程在执行exec()之前只使用了一小部分内存。鉴于此，更新版本的unix利用虚拟内存硬件允许父子进程共享分别映射到它们各自地址空间的物理内存，直至其中一方修改物理内存，这种技术称为“写时复制”。fork()将父进程地址空间的映射情况复制到子进程中，而不是复制父进程映射的物理页内容，并将共享的物理页标记为“只读”。当父子进程其中一方尝试写入到任一页共享的内存页，该进程将触发页错误。在这种情况下，内核识别出该页是“写时复制”副本，并为触发页错误的进程创建新的私有的可写入页。</p>
<h2 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h2><p>将Copy-on-Write Fork实现为一个用户空间库例程有以下优点：1、内核更为简单，更为正确；2、允许用户进程定义fork()的语义，用户程序可以很容易地提供一个稍有不同的实现版本，例如dumbfork()这种昂贵的always-copy版本，或者父子进程共享内存的版本。用户级别的Copy-on-Write Fork需要能够识别出在写保护页上触发的页错误。</p>
<p>典型的unix内核需要知道在进程地址空间的每一个区域上触发页错误时应该采取什么方法，例如：栈空间触发页错误时应该分配和映射新的物理页，在大多数unix内核中，一开始只给新进程分配一页的栈空间，用户程序在栈空间不足的情况下访问未映射的栈地址会触发页错误，从而导致内核分配并映射新物理页到栈空间；BSS空间触发页错误时应该分配新的一页、填充0并映射到地址空间；如果系统支持按需分配物理页的可执行文件，text region触发页错误时将从磁盘读取相应二进制页并映射到地址空间。</p>
<p>上述情况中内核需要跟踪许多信息。我们不采取传统的unix方法，而是在用户空间中决定对每个页错误所采取的行动。这种设计的好处是用户程序在定义内存区域时有极大的灵活性，我们将在后续使用用户级页错误处理程序来映射和访问基于硬盘的文件系统上的文件。</p>
<h2 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 8. 实现sys_env_set_pgfault_upcall系统调用，该系统调用用于注册用户程序触发页错误时的处理函数入口。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Set the page fault upcall for &apos;envid&apos; by modifying the corresponding struct</span><br><span class="line">// Env&apos;s &apos;env_pgfault_upcall&apos; field.  When &apos;envid&apos; causes a page fault, the</span><br><span class="line">// kernel will push a fault record onto the exception stack, then branch to</span><br><span class="line">// &apos;func&apos;.</span><br><span class="line">//</span><br><span class="line">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">static int</span><br><span class="line">sys_env_set_pgfault_upcall(envid_t envid, void *func)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;); </span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	e-&gt;env_pgfault_upcall = func;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h2><p>jos正常执行进程过程中，用户进程所使用的用户栈是[USTACKTOP-PGSIZE,USTACKTOP-1]。然而，当用户程序触发页错误时，内核将在另一个栈[UXSTACKTOP-PGSIZE,UXSTACKTOP-1]上执行设计好的页错误处理函数，这个栈称为user exception stack。类似于x86为jos设计的由用户模式切换到内核模式时的栈切换，我们将在jos内核为用户程序设计自动栈切换。<br>当执行用户设计的页错误处理函数时，可以根据页错误原因使用jos的系统调用来映射新物理页或调整映射情况。之后页错误处理函数返回，通过汇编语言返回到原先触发页错误的代码。<br>每一个需要使用用户级别页错误处理流程的用户程序需要自行为user exception stack申请内存空间。</p>
<h2 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h2><p>用户程序触发页错误时，用户进程的状态称为“the trap-time state”。如果没有注册页错误处理程序，内核将销毁进程。否则，内核在异常栈上设置struct UTrapframe（见inc/trap.h），UTrapframe的值主要来源于内核栈的trap frame。之后，内核安排用户级页错误处理程序在异常栈上执行。<br>如果发生页错误的时候用户进程已经在异常栈上执行（<code>tf-&gt;tf_esp</code>在[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]内），说明页错误处理程序本身触发了页错误。这种时候应该在<code>tf-&gt;tf_esp</code>而不是<code>UXSTACKTOP</code>的以下部分存储UTrapframe，而且需要先留空4个字节，再存储UTrapframe，具体原因下面讲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 9. 完成kern/trap.c的page_fault_handler函数，该函数主要负责处理页错误，如果触发页错误的是用户进程，则检查页错误处理程序是否已设置、页错误处理程序地址是否合法、异常栈指针是否越界、是否递归触发页错误、是否已为异常栈分配物理页，然后在异常栈上存储UTrapframe，将栈指针指向异常栈，并跳转执行用户级页错误处理程序入口。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">    // Read processor&apos;s CR2 register to find the faulting address</span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    // Handle kernel-mode page faults.</span><br><span class="line"></span><br><span class="line">    // LAB 3: Your code here.</span><br><span class="line">    if ((tf-&gt;tf_cs&amp;3) == 0)</span><br><span class="line">        panic(&quot;Kernel page fault!&quot;);</span><br><span class="line">    // We&apos;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="line">    // the page fault happened in user mode.</span><br><span class="line"> </span><br><span class="line">    // LAB 4: Your code here. </span><br><span class="line">    //1. test if has page fault upcall</span><br><span class="line">    if (curenv-&gt;env_pgfault_upcall == NULL ||</span><br><span class="line">        //2. test if the exception stack overflows</span><br><span class="line">        tf-&gt;tf_esp &gt; UXSTACKTOP || (tf-&gt;tf_esp &gt; USTACKTOP &amp;&amp; tf-&gt;tf_esp &lt; (UXSTACKTOP - PGSIZE)))&#123;</span><br><span class="line">        // Destroy the environment that caused the fault.</span><br><span class="line">        cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">            curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        env_destroy(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. test if page fault upcall valid</span><br><span class="line">    user_mem_assert(curenv, (void *)curenv-&gt;env_pgfault_upcall, 1, 0);</span><br><span class="line">	</span><br><span class="line">    //determine user exception stack pointer</span><br><span class="line">    uint32_t exception_stack_top = 0;</span><br><span class="line">    if(tf-&gt;tf_esp &lt;= USTACKTOP)&#123;</span><br><span class="line">        exception_stack_top = UXSTACKTOP - sizeof(struct UTrapframe);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //+4 : leave an extra word between the current top of the exception stack</span><br><span class="line">        exception_stack_top = tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2. test if the exception stack overflows</span><br><span class="line">    if(exception_stack_top &lt; (UXSTACKTOP - PGSIZE))&#123;</span><br><span class="line">        // Destroy the environment that caused the fault.</span><br><span class="line">        cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">            curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        env_destroy(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3. test if allocate a page for its exception stack or if can write to it</span><br><span class="line">    user_mem_assert(curenv, (void *) exception_stack_top, 1, PTE_W | PTE_U);//1 is enough, may not return</span><br><span class="line">	 </span><br><span class="line">    //write UTrapframe in the stack</span><br><span class="line">    struct UTrapframe* utf = (struct UTrapframe*)exception_stack_top;</span><br><span class="line">    utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">    utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">    utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">    utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">    utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">    utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">    //branch to curenv-&gt;env_pgfault_upcall, that means we should change trapframe&apos;s esp and eip</span><br><span class="line">    tf-&gt;tf_esp = (uintptr_t) exception_stack_top;</span><br><span class="line">    tf-&gt;tf_eip = (uintptr_t) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">    env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h2><p>xv6的定时函数是在内核trap时将esp所指单元向下移动一个单元，然后存储tf的eip（触发中断的下一条指令），然后将tf的eip指向处理函数，然后弹出tf寄存器执行定时函数，定时函数返回时弹出trap设置的eip，进而执行用户函数。这种情况下esp仍然指向用户栈。<br>jos的用户级页错误处理程序入口是<code>_pgfault_upcall</code>，包括调用执行真正的处理程序和恢复执行用户函数。<code>_pgfault_upcall</code>将通过系统调用设置为页错误处理程序入口，内核trap时将tf的相关值复制到异常栈上，将tf的esp指向异常栈，然后弹出tf寄存器执行页错误处理程序入口。这种情况下执行处理函数的时候esp指向的是异常栈，设置异常栈可以方便传递参数。<br>用户级页错误处理程序执行完后，将返回执行原先触发页错误的用户代码（如果是页错误处理程序触发页错误，则应返回执行原先触发页错误的页错误处理程序）。lib/pfentry.S完成这个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 10. 完成lib/pfentry.S。触发页错误时内核实际上是跳转执行该文件声明的入口_pgfault_upcall。pfentry.S主要是在用户态的page_fault_handler结束后如何恢复现场并跳回原程序执行。</span><br></pre></td></tr></table></figure></p>
<p>内核在异常栈上存储UTrapframe之后安排用户级页错误处理程序在异常栈上执行。异常栈上的UTrapframe布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP or tf-&gt;tf_esp</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time oesp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure></p>
<p>分两种情况分析：<br>1、非递归触发页错误。由于此时是在异常栈上，想要恢复执行触发页错误的用户代码时，需要弹出通用寄存器，并由异常栈跳转到用户栈，最后执行ret恢复执行。因此，关键点是如何在弹出通用寄存器和eflags之前将eip存储到用户栈上。需要借助通用寄存器存储PushRegs的位置和eip的值，再跳到用户栈，存储eip，然后再跳回PushRegs位置，弹出通用寄存器和eflags，最后跳回用户栈执行ret（实验发现最后跳回用户栈之后，此时已经存了eip，如果执行subl向下跳到存eip的位置会改变eflags，因此在跳到用户栈存储eip之后，将最新的esp位置存到异常栈上，最后由异常栈直接跳到用户栈执行ret）。<br>2、递归触发页错误。与情况1不同的是，“用户栈”其实就是异常栈本身。因此，在跳到“用户栈”存储eip的时候，由于弹出的trap-time esp值恰好就是存储trap-time esp所在的位置（trap的时候esp指向异常栈该位置，然后跳到内核栈，内核再从异常栈该位置开始存储UTrapframe），存储eip会将trap-time esp覆盖，从而导致最后不能成功再跳回用户栈。这就是为什么如果是递归触发页错误的话，需要先留空4个字节，再存储UTrapframe，主要是为了防止存储eip的时候覆盖了原先的esp值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line">#include &lt;inc/memlayout.h&gt;</span><br><span class="line"></span><br><span class="line">// Page fault upcall entrypoint.</span><br><span class="line"> </span><br><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp           // pop function argument</span><br><span class="line">    </span><br><span class="line">    // Now the C page fault handler has returned and you must return</span><br><span class="line">    // to the trap time state.</span><br><span class="line">    // Push trap-time %eip onto the trap-time stack.</span><br><span class="line">    //</span><br><span class="line">    // Explanation:</span><br><span class="line">    //   We must prepare the trap-time stack for our eventual return to</span><br><span class="line">    //   re-execute the instruction that faulted.</span><br><span class="line">    //   Unfortunately, we can&apos;t return directly from the exception stack:</span><br><span class="line">    //   We can&apos;t call &apos;jmp&apos;, since that requires that we load the address</span><br><span class="line">    //   into a register, and all registers must have their trap-time</span><br><span class="line">    //   values after the return.</span><br><span class="line">    //   We can&apos;t call &apos;ret&apos; from the exception stack either, since if we</span><br><span class="line">    //   did, %esp would have the wrong value.</span><br><span class="line">    //   So instead, we push the trap-time %eip onto the *trap-time* stack!</span><br><span class="line">    //   Below we&apos;ll switch to that stack and call &apos;ret&apos;, which will</span><br><span class="line">    //   restore %eip to its pre-fault value.</span><br><span class="line">    //</span><br><span class="line">    //   In the case of a recursive fault on the exception stack,</span><br><span class="line">    //   note that the word we&apos;re pushing now will fit in the</span><br><span class="line">    //   blank word that the kernel reserved for us.</span><br><span class="line">    //</span><br><span class="line">    // Throughout the remaining code, think carefully about what</span><br><span class="line">    // registers are available for intermediate calculations.  You</span><br><span class="line">    // may find that you have to rearrange your code in non-obvious</span><br><span class="line">    // ways as registers become unavailable as scratch space.</span><br><span class="line">    //</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Restore the trap-time registers.  After you do this, you</span><br><span class="line">    // can no longer modify any general-purpose registers.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Restore eflags from the stack.  After you do this, you can</span><br><span class="line">    // no longer use arithmetic operations or anything else that</span><br><span class="line">    // modifies eflags.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Switch back to the adjusted trap-time stack.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Return to re-execute the instruction that faulted.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"> </span><br><span class="line">    addl $8, %esp  </span><br><span class="line">    movl %esp,%eax  </span><br><span class="line">    addl $32,%esp  </span><br><span class="line">    popl %ebx  </span><br><span class="line">    addl $4,%esp  </span><br><span class="line">    movl %esp, %ebp </span><br><span class="line">    popl %esp  </span><br><span class="line">    pushl %ebx  </span><br><span class="line">    movl %esp, 0x0(%ebp) </span><br><span class="line">    movl %eax,%esp  </span><br><span class="line">    popal  </span><br><span class="line">    addl $4,%esp  </span><br><span class="line">    popf  </span><br><span class="line">    popl %esp  </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">//  do not use the following, cause I find that &apos;subl $4,%esp&apos; will change eflags!</span><br><span class="line"></span><br><span class="line">//	addl $8, %esp  </span><br><span class="line">//	movl %esp,%eax  </span><br><span class="line">//	addl $32,%esp  </span><br><span class="line">//	popl %ebx  </span><br><span class="line">//	addl $4,%esp  </span><br><span class="line">//	popl %esp  </span><br><span class="line">//	pushl %ebx  </span><br><span class="line">//	movl %eax,%esp  </span><br><span class="line">//	popal  </span><br><span class="line">//	addl $4,%esp  </span><br><span class="line">//	popf  </span><br><span class="line">//	popl %esp  </span><br><span class="line">//	subl $4,%esp  </span><br><span class="line">//	ret</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 11. 完成lib/pgfault.c的set_pgfault_handler()。该函数主要完成页错误处理程序的注册工作。如果是第一次注册，则申请分配并映射异常栈。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">set_pgfault_handler(void (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	if (_pgfault_handler == 0) &#123;</span><br><span class="line">		// First time through!</span><br><span class="line">		// LAB 4: Your code here.</span><br><span class="line">		//panic(&quot;set_pgfault_handler not implemented&quot;);</span><br><span class="line">		if (sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">			panic(&quot;in set_pgfault_handler, sys_page_alloc failed&quot;);</span><br><span class="line">		sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Save handler pointer for assembly to call.</span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，用户级别的页错误处理流程如下：<br>1、用户程序通过<code>lib/pgfault.c</code>的<code>set_pgfault_handler()</code>函数注册页错误处理函数入口<code>_pgfault_upcall</code>（见lib/pfentry.S），并指定页错误处理函数<code>_pgfault_handler</code>，该函数指针将在<code>_pgfault_upcall</code>中被使用。第一次注册<code>_pgfault_upcall</code>时将申请分配并映射异常栈。<br>2、用户程序触发页错误，切换到内核模式。<br>3、内核检查页错误处理程序是否已设置、异常栈指针是否越界、是否递归触发页错误、是否已为异常栈分配物理页，然后在异常栈上存储UTrapframe，将栈指针指向异常栈，并跳转执行当前进程的<code>env_pgfault_upcall</code>（被设为用户级页错误处理程序入口<code>_pgfault_upcall</code>）。<br>4、用户模式下<code>_pgfault_upcall</code>调用<code>_pgfault_upcall</code>，执行用户级别页错误处理函数，在用户态的<code>page_fault_handler</code>结束后恢复现场并跳回原程序执行。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>user/faultalloc.c涉及了递归触发页错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// test user-level fault handler -- alloc pages to fix faults</span><br><span class="line"></span><br><span class="line">#include &lt;inc/lib.h&gt;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">handler(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line">	void *addr = (void*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(&quot;fault %x\n&quot;, addr);</span><br><span class="line">	if ((r = sys_page_alloc(0, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;allocating at %x in page fault handler: %e&quot;, addr, r);</span><br><span class="line">	snprintf((char*) addr, 100, &quot;this string was faulted in at %x&quot;, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	cprintf(&quot;%s\n&quot;, (char*)0xDeadBeef);</span><br><span class="line">	cprintf(&quot;%s\n&quot;, (char*)0xCafeBffe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/2.PNG" title="user/faultalloc.c递归触发页错误">
<p>首先，snprintf的定义是<code>int snprintf(char *buf, int n, const char *fmt, ...)</code>，向buf缓存区中按照格式填充字符串。<br>出错的原因是：当执行<code>cprintf(&quot;%s\n&quot;, (char*)0xCafeBffe);</code>时，触发了页错误。页错误处理函数在虚拟地址<code>ROUNDDOWN(addr, PGSIZE)</code>即cafeb000上分配和映射物理页，此时可访问的虚拟地址空间为[0xcafeb000,0xcafec000-1]。之后，调用snprintf向0xCafeBffe内存地址上填充字符串，由于字符串过长，导致越界访问0xcafec000，再次触发页错误。第二次页错误处理程序往0xcafec000填充字符串，返回到第一次页错误处理程序，第一次页错误处理程序往0xCafeBffe填充字符串，返回到用户程序，执行cprintf进行输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 扩展jos内核，对运行用户程序代码时能触发的所有类型的处理器异常，都能重定向到用户模式的异常处理程序。编写用户模式的测试程序，测试divide-by-zero、general protection fault、illegal opcode等。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h2><p>jos使用Copy-on-Write Fork时，将会扫描父进程的整个地址空间，并设置子进程的相关页映射，但不会复制页内容（dumpfork()复制页内容）。当父/子进程尝试写入某一页时，将申请新的一页并拷贝页内容到该页上。<br>fork()的基本流程如下：<br>1、父进程调用<code>set_pgfault_handler()</code>注册页错误处理函数<code>pgfault()</code>。<br>2、父进程调用<code>sys_exofork()</code>创建子进程。<br>3、对于[UTEXT,UTOP)每一个可写或写时复制的页，父进程调用duppage分别在子进程和自身的地址空间内映射该页为写时复制<code>PTE_COW</code>。<br>注意：不能将user exception stack映射为写时复制，而是应该为父子进程分别映射对应的物理页。这是因为页错误处理程序将在user exception stack上执行，当将user exception stack设为写时复制时，一旦发生页错误，内核将尝试往user exception stack写数据，由于user exception stack不可写而导致失败。<br>4、父进程为子进程注册页错误处理函数。<br>注意：我们不在子进程中注册页错误处理函数。首先，我们不在子进程中调用<code>set_pgfault_handler()</code>（该函数注册页错误处理函数，并在页错误处理函数未注册的情况下申请user exception stack），因为子进程是由父进程fork而来的，而父进程已经注册过页错误处理函数，所以在子进程中注册页错误处理函数的话子进程不会再申请user exception stack（<code>if (_pgfault_handler == 0)</code>条件判断失败）。其次，我们不在子进程中调用<code>sys_page_alloc()</code>和<code>sys_env_set_pgfault_upcall()</code>申请user exception stack，这是因为这涉及了函数调用，而父进程将子进程的用户栈映射为写时复制了，所以会触发页错误，但是此时还没有分配user exception stack，因此出错。<br>5、设置子进程状态为runnable。</p>
<p>页错误处理函数的处理流程如下：<br>1、内核跳转执行<code>_pgfault_upcall</code>，<code>_pgfault_upcall</code>将调用页错误处理函数pgfault()。<br>2、pgfault()确认fault是可写的（错误码的FEC_WR），并且引起页错误的虚拟地址对应的页表项权限为<code>PTE_COW</code>。<br>3、pgfault()为申请新的一页，映射到一个临时地址，将faulting page的内容复制到该新页，调用<code>sys_page_map</code>将映射到临时地址的物理页映射到引起页错误的虚拟地址，设置权限为可写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 12.实现lib/fork.c的fork、duppage、pgfault。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">// PTE_COW marks copy-on-write page table entries.</span><br><span class="line">// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).</span><br><span class="line">#define PTE_COW		0x800</span><br><span class="line">extern void _pgfault_upcall(void);</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Custom page fault handler - if faulting page is copy-on-write,</span><br><span class="line">// map in our own private writable copy.</span><br><span class="line">//</span><br><span class="line">static void</span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	void *addr = (void *) utf-&gt;utf_fault_va;</span><br><span class="line">	uint32_t err = utf-&gt;utf_err;</span><br><span class="line">	int r;</span><br><span class="line">	// Check that the faulting access was (1) a write, and (2) to a</span><br><span class="line">	// copy-on-write page.  If not, panic.</span><br><span class="line">	// Hint:</span><br><span class="line">	//   Use the read-only page table mappings at uvpt</span><br><span class="line">	//   (see &lt;inc/memlayout.h&gt;).</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	if ((err &amp; FEC_WR) == 0)</span><br><span class="line">		panic(&quot;pgfault: faulting address [%08x] not a write\n&quot;, addr);</span><br><span class="line"></span><br><span class="line">	if( (uvpd[PDX(addr)] &amp; PTE_P) != PTE_P || </span><br><span class="line">	    (uvpt[PGNUM(addr)] &amp; PTE_P) != PTE_P || </span><br><span class="line">	    (uvpt[PGNUM(addr)] &amp; PTE_COW) != PTE_COW)&#123; </span><br><span class="line">		//cprintf(&quot;(uvpt[PTX(addr)] &amp; PTE_P)=%x,PTE_P=%x\n&quot;,(uvpt[PGNUM(addr)] &amp; PTE_P),PTE_P);</span><br><span class="line">		panic(&quot;not copy-on-write&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// Allocate a new page, map it at a temporary location (PFTEMP),</span><br><span class="line">	// copy the data from the old page to the new page, then move the new</span><br><span class="line">	// page to the old page&apos;s address.</span><br><span class="line">	// Hint:</span><br><span class="line">	//   You should make three system calls.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">	//panic(&quot;pgfault not implemented&quot;);</span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	if ((r = sys_page_alloc(0, PFTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;allocating at %x in page fault handler: %e&quot;, addr, r);</span><br><span class="line">	memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">	//cprintf(&quot;in user pgfault,envid = %x\n&quot;,thisenv-&gt;env_id);</span><br><span class="line">	if ((r = sys_page_map(0, PFTEMP, 0, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line">	if ((r = sys_page_unmap(0, PFTEMP)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_unmap: %e&quot;, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span><br><span class="line">// at the same virtual address.  If the page is writable or copy-on-write,</span><br><span class="line">// the new mapping must be created copy-on-write, and then our mapping must be</span><br><span class="line">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span><br><span class="line">// copy-on-write again if it was already copy-on-write at the beginning of</span><br><span class="line">// this function?)</span><br><span class="line">//</span><br><span class="line">// Returns: 0 on success, &lt; 0 on error.</span><br><span class="line">// It is also OK to panic on error.</span><br><span class="line">//</span><br><span class="line">static int</span><br><span class="line">duppage(envid_t envid, unsigned pn)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;duppage not implemented&quot;); </span><br><span class="line">	void *addr = (void *)(pn*PGSIZE);</span><br><span class="line">	if( (uvpt[pn] &amp; PTE_W) == PTE_W || </span><br><span class="line">	    (uvpt[pn] &amp; PTE_COW) == PTE_COW)&#123; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, 0, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// User-level fork with copy-on-write.</span><br><span class="line">// Set up our page fault handler appropriately.</span><br><span class="line">// Create a child.</span><br><span class="line">// Copy our address space and page fault handler setup to the child.</span><br><span class="line">// Then mark the child as runnable and return.</span><br><span class="line">//</span><br><span class="line">// Returns: child&apos;s envid to the parent, 0 to the child, &lt; 0 on error.</span><br><span class="line">// It is also OK to panic on error.</span><br><span class="line">//</span><br><span class="line">// Hint:</span><br><span class="line">//   Use uvpd, uvpt, and duppage.</span><br><span class="line">//   Remember to fix &quot;thisenv&quot; in the child process.</span><br><span class="line">//   Neither user exception stack should ever be marked copy-on-write,</span><br><span class="line">//   so you must allocate a new page for the child&apos;s user exception stack.</span><br><span class="line">//</span><br><span class="line">envid_t</span><br><span class="line">fork(void)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;fork not implemented&quot;);</span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	envid_t envid;</span><br><span class="line">	unsigned addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[]; </span><br><span class="line"></span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123;</span><br><span class="line">		// We&apos;re the child. </span><br><span class="line">		// DO NOT CALL set_pgfault_handler DIRECTLY! Cause we are forked from parent who has</span><br><span class="line">		// called &quot;set_pgfault_handler&quot;, so the variable named &quot;_pgfault_handler&quot; in pgfault.c has been set,</span><br><span class="line">		// and child-env will not call &quot;sys_page_alloc&quot; and &quot;sys_env_set_pgfault_upcall&quot;</span><br><span class="line">		// do not call: set_pgfault_handler(pgfault); </span><br><span class="line">		</span><br><span class="line">		// DO NOT SET USER EXCEPTION STACK IN CHILD! Cause we set COW on user stack(not user exception stack), so function call</span><br><span class="line">		// like &quot;sys_page_alloc&quot; and &quot;sys_env_set_pgfault_upcall&quot;(which want to stack user excettion stack) </span><br><span class="line">		// will cause page fault, and kern will use user excettion stack, but it has not been set!!</span><br><span class="line">		// do not call:</span><br><span class="line">	  	// if (sys_page_alloc(0, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		//	 panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">		// if (sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall) &lt; 0) </span><br><span class="line">		// 	 panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line">		//  </span><br><span class="line"></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent. </span><br><span class="line">	// map the page copy-on-write into the address space of the child </span><br><span class="line">	// and then remap the page copy-on-write in its own address space</span><br><span class="line">	for (addr = UTEXT; addr &lt; (unsigned)end; addr += PGSIZE)&#123;</span><br><span class="line">		duppage(envid, PGNUM(addr)); </span><br><span class="line">	&#125; </span><br><span class="line">	// map the stack we are currently running on.</span><br><span class="line">	duppage(envid, PGNUM(USTACKTOP - PGSIZE));    </span><br><span class="line">    // also can:</span><br><span class="line">  	/*</span><br><span class="line">	for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE)</span><br><span class="line">		if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P)</span><br><span class="line">		    &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">		    duppage(envid, PGNUM(addr)); </span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">	if (sys_env_set_pgfault_upcall(envid, (void*) _pgfault_upcall) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line"></span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"> </span><br><span class="line">	return envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于uvpd和uvpt数组"><a href="#关于uvpd和uvpt数组" class="headerlink" title="关于uvpd和uvpt数组"></a>关于uvpd和uvpt数组</h2><p>为了能通过虚拟地址访问到页表和页目录，jos设计了UVPT和UVPD（见Lab3笔记）。一旦设置uvpt数组并指向UVPT，uvpt相当于包含1M个页表项的数组。对于[0, 4G)的线性地址，其在通过地址转换过程中找到的页表项，刚好是以线性地址前20位为索引在uvpt中的项，即uvpt[PGNUM(线性地址)]。对于[UVPT, UVPT+4M)的线性地址，其在uvpt数组中索引到的刚好是页目录这张页表中的项。<br>一旦设置uvpd数组并指向(UVPT+(UVPT&gt;&gt;12)*4)，则uvpd相当于包含1K个页目录项的数组。<br><img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/3.png" title="关于uvpd和uvpt数组"><br>另外，注意到每个进程访问uvpt[]和uvpd[]时，都是彼此独立的。这是因为：如访问uvpt[i]，最终是访问uvpt[i]相关联的UVPT之上的一个虚拟地址，每个进程的页目录和页表都是根据自身情况请求分配页之后的映射结果，如果进程A在该虚拟地址上没有映射页，则uvpt[i]为空，而如果进程B在该虚拟地址上有映射页，则uvpt[i]不为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 完成sfork，使父子进程能共享内存，除了用户栈和用户异常栈。</span><br></pre></td></tr></table></figure>
<p>请注意，<code>sys_exofork</code>创建的子进程页目录只映射了内核空间，我们需要自行映射子进程的地址空间。另一方面，页表项低12位表示权限，但是<code>sys_page_map</code>中不支持设置<code>PTE_AVAIL | PTE_P | PTE_W | PTE_U</code>以外的权限位，因此需要对页表项权限提取进行&amp;处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">sfork(void)</span><br><span class="line">&#123; </span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	envid_t envid;</span><br><span class="line">	unsigned addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[]; </span><br><span class="line"></span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123; </span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent. </span><br><span class="line">	// share memory</span><br><span class="line">	for (addr = UTEXT; addr &lt; (unsigned)end; addr += PGSIZE)&#123;</span><br><span class="line">		// pte&apos;s low 12 bits,that means perm,</span><br><span class="line">		// however, in sys_page_map, no other bits may be set except PTE_SYSCALL</span><br><span class="line">		// #define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">		int perm = uvpt[PGNUM(addr)] &amp; PTE_SYSCALL;</span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, perm)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	// map the stack we are currently running on, set copy-on-write.</span><br><span class="line">	duppage(envid, PGNUM(USTACKTOP - PGSIZE));   </span><br><span class="line"></span><br><span class="line">	if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">	if (sys_env_set_pgfault_upcall(envid, (void*) _pgfault_upcall) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line"></span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"> </span><br><span class="line">	return envid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! fork()使用了大量的系统调用接口。为了降低成本，扩展jos的系统调用接口，使之支持批量调用系统调用，并让fork使用该接口。可参考IA32的RDTSC指令。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h1><h2 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h2><p>user/spin程序中子进程一旦获取CPU将永远嵌入循环。为了保证内核能够抢占正在运行的进程，需要扩展内核以支持时钟硬件的外部硬件中断。</p>
<h2 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h2><p>外部中断被称为IRQs，共有16个，编号为0-15。IRQs到IDT表项的映射不是固定的，<code>picirq.c</code>的<code>pic_init</code>通过<code>IRQ_OFFSET</code>-<code>IRQ_OFFSET+15</code>将IRQs 0-15映射到IDT项中。在inc/trap.h，<code>IRQ_OFFSET</code>被定义为32，所以IDT的32-47项映射到IRQs 0-15。<br>在jos中，一个关键的简化是一旦处于内核模式就禁用了外部设备中断。外部中断由eflags的<code>FL_IF</code>位控制。虽然有多种方式可以修改该位，但由于jos的简化处理，我们仅需要在进入和退出用户模式的时候通过保存和恢复eflags寄存器来处理它即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 13. 修改kern/trapentry.S和kern/trap.c，初始化相关的IDT项，并提供IRQs 0-15的处理函数。然后修改kern/env.c的env_alloc()，在允许外部中断的情况下执行用户进程。当调用硬件中断处理函数的时候，处理器不会将错误码进栈，也不会检查IDT项的DPL。</span><br></pre></td></tr></table></figure></p>
<p>相关资料可查询 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/toc.htm" target="_blank" rel="noopener">section 9.2 of the 80386 Reference Manual</a> 或 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/IA32-3A.pdf" target="_blank" rel="noopener">section 5.8 of the IA-32 Intel Architecture Software Developer’s Manual, Volume 3</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// kern/trapentry.S</span><br><span class="line">// 处理器不会将错误码进栈</span><br><span class="line"># IRQs 0    </span><br><span class="line">TRAPHANDLER_NOEC(entry_point32,IRQ_OFFSET+IRQ_TIMER) </span><br><span class="line"># IRQs 1</span><br><span class="line">TRAPHANDLER_NOEC(entry_point33,IRQ_OFFSET+IRQ_KBD) </span><br><span class="line"># IRQs 4</span><br><span class="line">TRAPHANDLER_NOEC(entry_point36,IRQ_OFFSET+IRQ_SERIAL) </span><br><span class="line"># IRQs 7</span><br><span class="line">TRAPHANDLER_NOEC(entry_point39,IRQ_OFFSET+IRQ_SPURIOUS) </span><br><span class="line"># IRQs 14</span><br><span class="line">TRAPHANDLER_NOEC(entry_point46,IRQ_OFFSET+IRQ_IDE) </span><br><span class="line"></span><br><span class="line">// kern/trap.c, trap_init()</span><br><span class="line">for (i = 0; i &lt; 16; ++i)&#123;</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+i], 0, GD_KT, entry_points[IRQ_OFFSET+i], 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// kern/env.c, env_alloc()</span><br><span class="line">// 创建用户进程的时候设置允许中断标志，这样就可以在运行用户进程的时候通过中断来控制进程。</span><br><span class="line">	e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h2 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h2><p><code>lapic_init</code>和<code>pic_init</code>进行了时钟和中断的相关设置，以生成中断。需要对中断进行相关处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 14. 修改trap_dispatch()函数，在每次触发时间中断的时候调用sched_yield()函数切换执行其他进程。测试案例为user/spin。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// trap_dispatch() </span><br><span class="line">	switch(tf-&gt;tf_trapno) &#123;</span><br><span class="line">	... </span><br><span class="line">	// Handle clock interrupts. Don&apos;t forget to acknowledge the</span><br><span class="line">	// interrupt using lapic_eoi() before calling the scheduler!</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line"> 	case (IRQ_OFFSET + IRQ_TIMER):</span><br><span class="line"> 		lapic_eoi();</span><br><span class="line"> 		sched_yield();</span><br><span class="line">		break;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h2><p>进程隔离和进程通信是两个重要课题，Unix的管道模型是典型的进程通信例子。进程间有许多通信模型，jos将实现一种简单的IPC机制。</p>
<h2 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h2><p>jos实现的IPC机制是扩展系统调用接口<code>sys_ipc_recv</code>和<code>sys_ipc_try_send</code>，并实现库函数<code>ipc_recv</code>和<code>ipc_send</code>。jos的进程间通信信息包括两个部分：一个32位数和一个可选的页面映射。允许传递页面映射的做法一方面可以传递更多数据，一方面进程可以更方便地设置和安排内存共享。</p>
<h2 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h2><p>进程希望接收消息时，调用<code>sys_ipc_recv</code>。该系统调用取消进程的执行，直到接收到消息。如果一个进行在等待接收消息，任何进程都可以发消息给它，而不局限于特定进程或有父子关系的进程。因此，Part A的权限检查不适用于IPC，因为IPC的设计确保进程A发送消息给进程B不能导致进程B发生故障。<br>进程希望发送消息时，调用<code>sys_ipc_try_send</code>，并传递目标进程号和参数。如果目标进程调用了<code>sys_ipc_recv</code>并且还没收到消息，系统调用将递交消息并返回0，否则返回<code>-E_IPC_NOT_RECV</code>。<br>库函数<code>ipc_recv</code>主要负责调用<code>sys_ipc_recv</code>和查找接收到的信息中所需要的部分。<br>库函数<code>ipc_send</code>主要负责重复调用<code>sys_ipc_try_send</code>，直至发送成功。</p>
<h2 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h2><p>当进程携带<code>dstva</code>参数调用<code>sys_ipc_recv</code>时，表明它希望收到一个页映射。这样当发送者发送一个页时，接收者需要将<code>dstva</code>映射到自己的地址空间（如果原来已经有了页映射，则解除原来的映射）。<br>当进程携带<code>srcva</code>参数调用<code>sys_ipc_try_send</code>时，表明它希望将当前映射到<code>srcva</code>的页发送出去，权限是<code>perm</code>。发送成功后，发送者保持<code>srcva</code>的原有映射，接收者则有了新的页映射。从而达到共享页的目的。<br>如果发送者和接收者都没有指明要传递页，则没有页被传递。对于任何一个IPC，内核都会在接收者的Env结构体中的<code>env_ipc_perm</code>上设置接收页的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 15. 实现kern/syscall.c的sys_ipc_recv和sys_ipc_try_send。调用envid2env的时候将checkperm设为0，表示任何进程都可以发送IPC消息。实现lib/ipc.c的ipc_recv和ipc_send。测试案例为user/pingpong和user/primes。</span><br></pre></td></tr></table></figure></p>
<p>大体上的思路是：<code>ipc_send</code>负责调用<code>sys_ipc_try_send</code>，如果调用失败（如目标进程尚未准备好接收）则循环尝试，但为了不霸占资源，在循环体内调用<code>sys_yield</code>由内核选择进程的执行。目标进程尚未准备好接收的情况下尝试循环send，对其他返回的错误直接panic。原型为<code>void ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)</code>，表示发送参数val，并将映射到pg的物理页映射到目标进程地址空间上，权限设为perm。<br><code>sys_ipc_try_send</code>负责检查目标进程是否存在、目标进程是否准备好接收信息、目标进程是否要求接收页映射。如果目标进程要求接收页映射，则检查发送者提供的虚拟地址是否有效并页对齐、发送者提供的映射权限是否合理、发送者提供的虚拟地址是否有映射页、是否尝试将只读页映射为可写、是否尚有物理页可供接收者分配和映射，检查通过后将物理页映射到目标进程指定的虚拟地址上。最后设置目标进程env结构体相关参数，以说明由谁发送、接收的值是什么，更改目标进程接收信息标识为已接收，将目标进程设为可执行，解除其阻塞状态。原型为<code>static int sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</code>。<br><code>ipc_recv</code>负责调用<code>sys_ipc_recv</code>，原型为<code>int32_t ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)</code>，如果pg为空，代表接收者不希望接收页映射，否则表示希望发送者将页映射到pg上。调用<code>sys_ipc_recv</code>之后进程状态被更改为不可执行、阻塞，直至有进程发送消息给它并将其状态更改为可执行。接收到消息之后，存储发送者进程id以及映射权限，然后返回接收到的32位的ipc值。<br><code>sys_ipc_recv</code>负责将给定的虚拟地址设置到env结构体的<code>env_ipc_dstva</code>上，表示希望发送者将页映射到其上，然后更改接收信息标识为等待接收，并更改进程的运行状态为不可执行。该系统调用将不会返回到用户模式，直至有发送者发送消息给它并解除其阻塞状态。</p>
<p>如果接收者要求接收页映射而发送者没有发送页映射，则出错；如果接收者不要求接收页映射而发送者发送页映射，不会出错。<br>接收者期望映射的虚拟地址不必与发送者发送的虚拟地址一致。<br>无需指定<code>ipc_recv</code>和<code>ipc_send</code>的先后调用顺序，因为即使接收者未准备好接收，发送者仍会判断<code>sys_ipc_recv</code>的返回结果，一旦是由于接收者未准备好接收而引起的错误，发送者会循环尝试发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;ipc_send not implemented&quot;); </span><br><span class="line">	int r; </span><br><span class="line">	if (!pg)&#123;</span><br><span class="line">		pg = (void *)IPC_NOPAGE;</span><br><span class="line">	&#125;</span><br><span class="line">	while((r = sys_ipc_try_send(to_env, val, pg, perm)))&#123; </span><br><span class="line">		if(r == 0)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r != -E_IPC_NOT_RECV)&#123;</span><br><span class="line">			panic(&quot;sys_ipc_try_send error, not -E_IPC_NOT_RECV, result: %d&quot;,r);</span><br><span class="line">		&#125;</span><br><span class="line">		sys_yield();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	// panic(&quot;sys_ipc_try_send not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	int r = envid2env(envid,&amp;e, 0);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	// target is not blocked, waiting for an IPC.</span><br><span class="line">	if(!e-&gt;env_ipc_recving) return -E_IPC_NOT_RECV;</span><br><span class="line">	// if receiver asking for one page</span><br><span class="line">	if ((uint32_t)e-&gt;env_ipc_dstva != IPC_NOPAGE &amp;&amp; (uint32_t)e-&gt;env_ipc_dstva &lt; UTOP) &#123; </span><br><span class="line">		// if srcva &lt; UTOP but srcva is not page-aligned.</span><br><span class="line">		if((uint32_t)srcva &gt;= UTOP || (uint32_t)srcva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">		// if srcva &lt; UTOP and perm is inappropriate</span><br><span class="line">		if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">		//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">		if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">			return -E_INVAL;</span><br><span class="line">		// if srcva &lt; UTOP but srcva is not mapped in the caller&apos;s address space</span><br><span class="line">		pte_t *pte_store;</span><br><span class="line">		struct PageInfo *page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte_store);</span><br><span class="line">		if(page == NULL) return -E_INVAL;//no page mapped at srcva </span><br><span class="line">		// if (perm &amp; PTE_W), but srcva is read-only in the current environment&apos;s address space</span><br><span class="line">		if((perm &amp; PTE_W) == PTE_W &amp;&amp; (*pte_store &amp; PTE_W) == 0) return -E_INVAL;</span><br><span class="line"></span><br><span class="line">		// if there&apos;s not enough memory to map srcva in envid&apos;s address space</span><br><span class="line">		// or if e-&gt;env_ipc_dstva invalid</span><br><span class="line">        r = page_insert(e-&gt;env_pgdir, page, e-&gt;env_ipc_dstva, perm);</span><br><span class="line">        if (r &lt; 0) return r;// -E_NO_MEM</span><br><span class="line">        e-&gt;env_ipc_perm = perm;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	e-&gt;env_ipc_perm = 0;</span><br><span class="line">    &#125; </span><br><span class="line">    e-&gt;env_ipc_recving = 0;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;ipc_recv not implemented&quot;); </span><br><span class="line">	if(!pg) pg = (void *)IPC_NOPAGE;</span><br><span class="line">	int r = sys_ipc_recv(pg);</span><br><span class="line">	if(r &lt; 0) return r;</span><br><span class="line">	if(from_env_store) *from_env_store = thisenv-&gt;env_ipc_from; </span><br><span class="line">	if(perm_store) *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">	return thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_ipc_recv(void *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_ipc_recv not implemented&quot;);</span><br><span class="line">	// if dstva &lt; UTOP but dstva is not page-aligned.</span><br><span class="line">	if((uint32_t)dstva == IPC_NOPAGE)&#123;</span><br><span class="line">		curenv-&gt;env_ipc_dstva = (void*)IPC_NOPAGE; </span><br><span class="line">	&#125;else if((uint32_t)dstva &gt;= UTOP || (uint32_t)dstva%PGSIZE != 0) &#123;</span><br><span class="line">		return -E_INVAL;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = 1;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 为何ipc_send需要循环尝试发送?</span><br></pre></td></tr></table></figure>
<p>原因见上分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! prime sieve只是大量并发程序之间消息传递的一种灵巧应用。阅读 C. A. R. Hoare, ``Communicating Sequential Processes,&apos;&apos; Communications of the ACM 21(8) (August 1978), 666-667 ，实现矩阵乘法的例子。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! Doug McIlroy开发的幂级数计算器是典型的消息传递例子，阅读  M. Douglas McIlroy, ``Squinting at Power Series,&apos;&apos; Software--Practice and Experience, 20(7) (July 1990), 661-683 (http://plan9.bell-labs.com/who/rsc/thread/squint.pdf)，实现该计算器并计算sin(x+x^3)的幂级数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 阅读 Improving IPC by Kernel Design (http://dl.acm.org/citation.cfm?id=168633)，改进jos的IPC效率。可扩展系统调用接口。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
