<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="tWqzAeLYHxufjgoQXpm3qh6YTje2bah03cY7dTfBvWw">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝色步行者">
<meta property="og:url" content="http://www.jianzzz.com/page/5/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓝色步行者">
<meta name="twitter:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/page/5/">





  <title>蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/" itemprop="url">笔记016 - Lab4: Preemptive Multitasking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:17:47+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h1><p>任务：扩展jos使之支持多处理器；添加系统调用支持用户进程创建新进程；实现协作性循环调度，当前进程自愿放弃cpu或exit的时候允许内核由一个进程切换到另一个进程。</p>
<h2 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h2><p>jos支持“对称多处理”(SMP：symmetric multiprocessing)，这是一种多处理器模型，所有cpu都能等价访问系统资源，如内存和I/O总线。在SMP中，尽管所有cpu在功能上是相同的，在引导过程中仍然可以将它们分为两类：1、引导处理器BSP（the bootstrap processor）：负责初始化系统和启动操作系统；2、应用程序处理器APs（the application processors）：在操作系统启动之后由BSP激活，然后开始运行。硬件和BIOS决定哪个处理器是BSP。<strong>到目前为止，所有jos代码都是运行在BSP上的。</strong></p>
<p>在SMP系统中，每个cpu都有一个附带的局部高级可编程中断处理器LAPIC（local APIC：Advanced Programmable Interrupt Controller）。LAPIC负责在整个系统中传递中断。LAPIC为其所连接的cpu提供一个唯一的标识符。在lab4中，我们使用LAPIC单元的三个基本功能：<br>1、读取LAPIC标识符APIC ID以识别我们的代码当前运行在哪个cpu上。（见cpunum()）<br>2、从BSP处发送STARTUP处理器间中断IPI（interprocessor interrupt）到APs，启动其他cpu。（见<code>lapic_startap()</code>）<br>3、part C将编程LAPIC的内置计时器，触发时钟中断以支持抢占式多任务调度。（见<code>apic_init()</code>）</p>
<p>处理器通过内存映射I/O MMIO（memory-mapped I/O）来访问附带的LAPIC。在MMIO中，一部分物理内存是硬连线到一些I/O设备的寄存器上的，所以可以通过使用相同的用以访问内存的load/store指令来访问设备寄存器。关于IO hole，我们已经使用了物理地址0xA0000来写VGA display缓存。LAPIC存放的IO hole起始物理地址是0xFE000000（4G空间中的32m），使用在KERNBASE的直接映射来访问的话，这个地址太高了。在jos中，虚拟内存映射在MMIOBASE位置留出了4MB空间以映射设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 1: 实现kern/pmap.c的mmio_map_region函数，在kern/lapic.c的lapic_init中查看mmio_map_region函数的使用情况。需要做完Exercise 2之后才能通过对于mmio_map_region的测试。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span><br><span class="line">// location.  Return the base of the reserved region.  size does *not*</span><br><span class="line">// have to be multiple of PGSIZE.</span><br><span class="line">//</span><br><span class="line">// jianzzz: 我们可能会多次调用mmio_map_region()，每一次给出pa和size，将会将pa映射到递增的va，映射范围是size(以PGSIZE为大小向上对齐)。若映射地址超出MMIOLIM则越界。</span><br><span class="line">void *</span><br><span class="line">mmio_map_region(physaddr_t pa, size_t size)</span><br><span class="line">&#123; </span><br><span class="line">	static uintptr_t base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	// Reserve size bytes of virtual memory starting at base and</span><br><span class="line">	// map physical pages [pa,pa+size) to virtual addresses</span><br><span class="line">	// [base,base+size).  Since this is device memory and not</span><br><span class="line">	// regular DRAM, you&apos;ll have to tell the CPU that it isn&apos;t</span><br><span class="line">	// safe to cache access to this memory.  Luckily, the page</span><br><span class="line">	// tables provide bits for this purpose; simply create the</span><br><span class="line">	// mapping with PTE_PCD|PTE_PWT (cache-disable and</span><br><span class="line">	// write-through) in addition to PTE_W.  (If you&apos;re interested</span><br><span class="line">	// in more details on this, see section 10.5 of IA32 volume</span><br><span class="line">	// 3A.)</span><br><span class="line">	//</span><br><span class="line">	// Be sure to round size up to a multiple of PGSIZE and to</span><br><span class="line">	// handle if this reservation would overflow MMIOLIM (it&apos;s</span><br><span class="line">	// okay to simply panic if this happens). </span><br><span class="line">	// Your code here:</span><br><span class="line">	uint32_t sizeup = (uint32_t)ROUNDUP((char *) size, PGSIZE);</span><br><span class="line">	if(base + sizeup &gt; MMIOLIM)&#123;</span><br><span class="line">		panic(&quot;mmio_map_region: requested size to map went over MMIOLIM&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	boot_map_region(kern_pgdir,base,sizeup,pa,PTE_PCD | PTE_PWT | PTE_W | PTE_P);</span><br><span class="line">	base += sizeup; </span><br><span class="line">	//panic(&quot;mmio_map_region not implemented&quot;);</span><br><span class="line">	return (void *)(base-sizeup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h2><p>在启动APs之前，BSP从BIOS的内存区域中读取MP配置表，收集多处理器系统的信息，比如CPUs数目、APIC IDs、LAPIC单元的MMIO地址。见kern/mpconfig.c的<code>mp_init()</code>。</p>
<p>kern/init.c的<code>boot_aps()</code>函数驱动AP启动程序的运行。APs在实模式下启动，与boot/boot.S的引导过程相似：<code>boot_aps()</code>将AP入口代码（kern/mpentry.S）拷贝到实模式下的一个可寻址的内存位置。与boot/boot.S的引导过程不同的是，jos会控制AP将会在哪里开始执行代码；jos将入口代码拷贝到0x7000（<code>MPENTRY_PADDR</code>），但640KB以下的任何unused、page-aligned的物理地址都被使用。</p>
<p>此后，<code>boot_aps()</code>逐一激活APs，通过给匹配AP的LAPIC发送STARTUP IPIs以及一个初始CS:IP地址，AP将在该地址上（即<code>MPENTRY_PADDR</code>）执行入口代码。kern/mpentry.S在简单设置之后将AP运行模式设为保护模式，开启分页，然后调用c函数<code>mp_main()</code>（also in kern/init.c）。<code>boot_aps()</code>等待AP发送<code>CPU_STARTED</code>信号（见struct CpuInfo的<code>cpu_status</code>域），然后激活下一个AP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 2. 阅读boot_aps()和mp_main()，以及kern/mpentry.S，了解APs启动过程的control flow transfer。修改kern/pmap.c的page_init()实现，避免在MPENTRY_PADDR分配页，保证APs启动代码的拷贝、运行安全。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4:</span><br><span class="line">	// Change your code to mark the physical page at MPENTRY_PADDR</span><br><span class="line">	// as in use</span><br><span class="line"></span><br><span class="line">	// The example code here marks all physical pages as free.</span><br><span class="line">	// However this is not truly the case.  What memory is free?</span><br><span class="line">	//  1) Mark physical page 0 as in use.</span><br><span class="line">	//     This way we preserve the real-mode IDT and BIOS structures</span><br><span class="line">	//     in case we ever need them.  (Currently we don&apos;t, but...)</span><br><span class="line">	//  第一页数据是被使用的，该页保存了实模式IDT和BIOS数据结构</span><br><span class="line">	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br><span class="line">	//     is free.</span><br><span class="line">	//  第二页至基本内存结束位置(640K)是可用的</span><br><span class="line">	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br><span class="line">	//     never be allocated.</span><br><span class="line">	//  [IOPHYSMEM, EXTPHYSMEM),即[0x0A0000,0x100000)--[640K,1MB)是被使用的</span><br><span class="line">	//  4) Then extended memory [EXTPHYSMEM, ...).</span><br><span class="line">	//     Some of it is in use, some is free. Where is the kernel</span><br><span class="line">	//     in physical memory?  Which pages are already in use for</span><br><span class="line">	//     page tables and other data structures?</span><br><span class="line">	//  扩展内存开始位置至当前pages数组存储的末端为不可使用的部分，其中包括页目录空间和映射内存的pages数组空间!!!</span><br><span class="line">	//  当前pages数组存储的末端开始至可用内存末端即为可用的</span><br><span class="line">	//</span><br><span class="line">	// Change the code to reflect this.</span><br><span class="line">	// NB: DO NOT actually touch the physical memory corresponding to</span><br><span class="line">	// free pages!</span><br><span class="line"></span><br><span class="line">	// uint32_t page_IOPHYSMEMBEGIN = npages_basemem;</span><br><span class="line">	uint32_t page_IOPHYSMEMBEGIN = (uint32_t)IOPHYSMEM / PGSIZE;</span><br><span class="line"></span><br><span class="line">	// uint32_t num_pages_io_hole = 96;</span><br><span class="line">	// uint32_t page_EXTPHYSMEMBEGIN = npages_basemem + num_pages_io_hole;</span><br><span class="line">	uint32_t page_EXTPHYSMEMBEGIN = (uint32_t)EXTPHYSMEM / PGSIZE;</span><br><span class="line">	</span><br><span class="line">	// 内核代码存放于0x100000处，即1M处，KERNBASE是内核代码存储起点的虚拟地址</span><br><span class="line">	// 对于存于物理地址1M后的数据，其虚拟地址减去KERNBASE的值相当于该处与内核代码存储起点虚拟地址位置的差，</span><br><span class="line">	// 而不是与0x0的差, 需要加上1M的空间</span><br><span class="line">	// 1M = 256 page </span><br><span class="line">	// uint32_t num_kernelpages = (((uint32_t) boot_alloc(0)) - KERNBASE) / PGSIZE;</span><br><span class="line">	//uint32_t page_KernelPageInfoEnd = npages_basemem + num_pages_io_hole + num_kernelpages; </span><br><span class="line">	uint32_t page_KernelPageInfoEnd = (((uint32_t) boot_alloc(0)) - KERNBASE) / PGSIZE + 256;    </span><br><span class="line">	 </span><br><span class="line">	page_free_list = NULL;</span><br><span class="line">	size_t i;</span><br><span class="line">	//pages数组与实际物理空间存在映射关系，但没有使用实际空间存储物理页位置</span><br><span class="line">	for (i = 0; i &lt; npages; i++) &#123;</span><br><span class="line">		if(i==0 ||</span><br><span class="line">			//Lab4 : page at MPRENTRY_PADDR, reserved for CPU startup code . e.g. 0x7000</span><br><span class="line">			i == PGNUM(MPENTRY_PADDR) ||</span><br><span class="line">			//(i&gt;=page_IOPHYSMEM &amp;&amp; i&lt;page_EXTPHYSMEMBEGIN) ||</span><br><span class="line">			//(i&gt;=page_EXTPHYSMEMBEGIN &amp;&amp; i&lt;page_KernelPageInfoEnd) ||</span><br><span class="line">			(i&gt;=page_IOPHYSMEMBEGIN &amp;&amp; i&lt;page_KernelPageInfoEnd)</span><br><span class="line">			)&#123;</span><br><span class="line">			pages[i].pp_ref = 1;</span><br><span class="line">			continue;	</span><br><span class="line">		&#125; </span><br><span class="line">		pages[i].pp_ref = 0;		</span><br><span class="line">		//往回指的指针pp_link要越过非空物理页,这样page_free_list才能通过pp_link往回获取空闲空间</span><br><span class="line">		//双向链表</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 1. 比较kern/mpentry.S和boot/boot.S。请记住：kern/mpentry.S被编译和链接后是运行在KERNBASE之上的，就像其他程序一样。设计MPBOOTPHYS宏的目的是什么？为什么boot/boot.S不需要它？</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kern/mpentry.S的内容原先是加载在内核程序的页空间中的，在BSP激活其他APs之前，BSP会将这部分内容移到MPENTRY_PADDR物理页中。所以AP在执行kern/mpentry.S时，kern/mpentry.S中的标记符物理地址需要以MPENTRY_PADDR为基础重新计算。MPBOOTPHYS宏就是用于确定kern/mpentry.S中的标识符物理地址。</span><br><span class="line">对于boot/boot.S来说，它是由bios加载到0x7c00的，然后开始执行这部分代码，由于当时尚未开启分页，链接地址即为物理地址，所以boot/boot.S中标识符的物理地址是直接由链接地址确定的。</span><br></pre></td></tr></table></figure>
<h2 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h2><p>多处理器操作系统很重要的一点是区分每个处理器私有的处理器状态和整个系统共享的全局状态。kern/cpu.h定义了per-CPU状态的大部分，包括struct CpuInfo（存储per-CPU变量）。cpunum()返回的是调用它的cpu的ID，该值可以索引cpus数组。thiscpu是个宏定义，指向当前cpu的struct CpuInfo。<br>以下是部分per-CPU状态：<br>1、<strong>Per-CPU kernel stack</strong>：多个cpu可以同时trap到内核中，为了防止干扰彼此的运行，需要为每个处理器设置单独的栈空间。内核物理空间中数组<code>percpu_kstacks[NCPU][KSTKSIZE]</code>保存了NCPU个栈空间。BSP的内核栈地址是bootstack，映射到虚拟地址KSTACKTOP之下的KSTKSIZE大小的空间。紧随着，越过KSTKGAP字节之后，映射CPU1栈空间，以此类推。<br>2、<strong>Per-CPU TSS and TSS descriptor</strong>：TSS任务状态段用于寻位每个cpu的内核栈。CPU i的TSS存于cpus[i].cpu_ts中，相关联的TSS描述符定义在GDT入口gdt[(GD_TSS0 &gt;&gt; 3) + i]。kern/trap.c定义的全局ts变量不再生效。<br>3、<strong>Per-CPU current environment pointer</strong>：因为每个cpu可以同时运行不同的用户进程，因此重新定义curenv指向<code>cpus[cpunum()].cpu_env</code>，它指向的是运行在当前cpu上的当前进程。<br>4、所有的寄存器，包括系统寄存器，对每个cpu来说都是私有的。因此，初始化这些寄存器的指令，比如lcr3(), ltr(), lgdt(), lidt()等，都必须在每个寄存器上执行一次。<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>正是用于这个目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 3. 修改kern/pmap.c的mem_init_mp()函数，将每个cpu的栈映射到KSTACKTOP以下部分，参考inc/memlayout.h。每个栈的大小是KSTKSIZE+KSTKGAP字节。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">mem_init_mp(void)</span><br><span class="line">&#123; </span><br><span class="line">	//     Permissions: kernel RW, user NONE</span><br><span class="line">	//</span><br><span class="line">	// LAB 4: Your code here:</span><br><span class="line">	int i=0;</span><br><span class="line">	uint32_t bottom_stack = KSTACKTOP - KSTKSIZE;</span><br><span class="line">	for (i = 0; i &lt; NCPU; i++) &#123;</span><br><span class="line">		boot_map_region(kern_pgdir, bottom_stack, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span><br><span class="line">		bottom_stack -= KSTKGAP; // guard</span><br><span class="line">		bottom_stack -= KSTKSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 4. kern/trap.c的trap_init_percpu()函数初始化了BSP的TSS和TSS描述符，修改这部分代码，使之支持所有cpu。提示：新代码将不会使用到全局变量ts。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">trap_init_percpu(void)</span><br><span class="line">&#123; </span><br><span class="line">	// ltr sets a &apos;busy&apos; flag in the TSS selector, so if you</span><br><span class="line">	// accidentally load the same TSS on more than one CPU, you&apos;ll</span><br><span class="line">	// get a triple fault.  If you set up an individual CPU&apos;s TSS</span><br><span class="line">	// wrong, you may not get a fault until you try to return from</span><br><span class="line">	// user space on that CPU.</span><br><span class="line">	//</span><br><span class="line">	// LAB 4: Your code here:</span><br><span class="line"></span><br><span class="line">	// Setup a TSS so that we get the right stack</span><br><span class="line">	// when we trap to the kernel.</span><br><span class="line">	//ts.ts_esp0 = KSTACKTOP;</span><br><span class="line">	//ts.ts_ss0 = GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = (uintptr_t) percpu_kstacks[thiscpu-&gt;cpu_id] + KSTKSIZE;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line"></span><br><span class="line">	// Initialize the TSS slot of the gdt.</span><br><span class="line">	//gdt[GD_TSS0 &gt;&gt; 3] = SEG16(STS_T32A, (uint32_t) (&amp;ts),</span><br><span class="line">	//				sizeof(struct Taskstate) - 1, 0);</span><br><span class="line">	//gdt[GD_TSS0 &gt;&gt; 3].sd_s = 0;</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (uint32_t) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line">					sizeof(struct Taskstate) - 1, 0);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id].sd_s = 0;</span><br><span class="line"></span><br><span class="line">	// Load the TSS selector (like other segment selectors, the</span><br><span class="line">	// bottom three bits are special; we leave them 0)</span><br><span class="line">	//ltr(GD_TSS0);  </span><br><span class="line">        //ltr(((GD_TSS0 &gt;&gt; 3) + thiscpu-&gt;cpu_id) &lt;&lt; 3); </span><br><span class="line">	ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; 3)); </span><br><span class="line"></span><br><span class="line">	// Load the IDT</span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多处理器总结要点"><a href="#多处理器总结要点" class="headerlink" title="多处理器总结要点"></a>多处理器总结要点</h2><p>jos支持多处理器之后，大概的启动过程如下：<br>1、BSP调用<code>mem_init()</code>函数，主要完成创建页目录、pages数组、envs数组、映射pages数组/envs数组/BSP内核栈等到页目录中。<br>2、BSP调用<code>env_init()</code>函数，初始化envs数组；同时调用<code>env_init_percpu()</code>函数加载当前cpu的GDT和gs/fs/es/ds/ss段描述符。<br>3、BSP调用<code>trap_init()</code>函数，初始化IDT表；同时调用<code>trap_init_percpu()</code>函数初始化当前cpu的TSS和IDT。<br>4、BSP调用<code>mp_init()</code>函数，<code>mp_init()</code>函数通过调用<code>mpconfig()</code>从BIOS中读取浮动指针mp，从mp中找到struct mpconf多处理器配置表，然后根据这个结构体内的entries信息（processor table entry）对各个cpu结构体进行配置（主要是cpuid）。如果proc-&gt;flag是MPPROC_BOOT，说明这个入口对应的处理器是用于启动的处理器，我们把结构体数组cpus[ncpu]地址赋值给bootcpu指针。注意这里ncpu是个全局变量，那么这里实质上就是把cpus数组的第一个元素的地址给了bootcpu。如果出现任何entries匹配错误，则认为处理器的初始化失败了，不能用多核处理器进行机器的运行。<br>5、BSP调用<code>lapic_init()</code>函数，映射lapic物理地址到页目录（映射的虚拟地址递增），设置时钟，允许APIC接收中断。<br>6、BSP调用<code>pic_init()</code>函数，初始化8259A中断控制器，允许生成中断。<br>7、BSP调用<code>boot_aps()</code>函数，复制cpu启动代码到0x7000，然后对每个cpu分别确定内核栈地址后调用<code>lapic_startap()</code>函数。<code>lapic_startap()</code>函数命令对应cpu从加载代码处开始执行。BSP使用轮询等待目标cpu启动完成（目标cpu使用自旋锁通知），然后激活下一个cpu。<br>8、AP（cpu）从加载代码处启动，加载gdt表、手动设置初始页表、开启保护模式、分页等，然后跳转到<code>mp_main()</code>函数；<code>mp_main()</code>函数直接切换到页目录，然后调用<code>lapic_init()</code>函数映射lapic物理地址到页目录（映射的虚拟地址递增），并允许APIC接收中断；调用<code>env_init_percpu()</code>函数加载当前cpu的GDT和gs/fs/es/ds/ss段描述符；调用<code>trap_init_percpu()</code>函数初始化当前cpu的TSS和IDT，然后使用自旋锁设置启动完成标识，并调用<code>sched_yield()</code>函数尝试开始执行可执行进程。<br>9、BSP上自行创建进程，并调用<code>sched_yield()</code>函数尝试开始执行可执行进程。</p>
<p>需要注意到：<strong>每个cpu都有自己独立的寄存器和CPU栈、TSS，但是整个内核中只有一份envs数组、pages数组、内核页目录、idt、gdt、lapic物理地址。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题是：lapic物理地址只有一个，每次启动cpu的过程中是怎么改变lapic的呢？还有cpunum()的实现方式不明白。。。。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>启动APs之后，我们需要解决多处理器并发执行内核代码的竞争条件。实现这一点的最简单的方法是使用一个内核锁，该内核锁是一个全局锁，一旦某个进程进入内核模式则尝试获取该锁，当进程返回到用户模式时释放该锁。在这个模型中，在用户模式下的进程可以并发在任何可用cpu上运行，但至多一个进程可以运行在内核模式下，其他试图进入内核模式的进程被迫等待。<br>kern/spinlock.h定义了内核锁<code>kernel_lock</code>，并提供<code>lock_kernel()</code>和<code>unlock_kernel()</code>方法用于获取和释放锁。需要在以下四个地方设置内核锁：<br>1、<code>i386_init()</code>：在BSP激活其他cpu之前获取内核锁。<br>2、<code>mp_main()</code>：初始化AP之后获取内核锁，然后调用<code>sched_yield()</code>在该AP上运行进程。<br>3、<code>trap()</code>：如果是由用户模式trap到内核的，获取内核锁。通过<code>tf_cs</code>的低两位判断是用户模式还是内核模式。<br>4、<code>env_run()</code>：在切换为用户模式之前释放内核锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 5: 完成以上任务。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">i386_init():</span><br><span class="line">	// Acquire the big kernel lock before waking up APs</span><br><span class="line">	// Your code here:</span><br><span class="line">	lock_kernel();</span><br><span class="line">	// Starting non-boot CPUs</span><br><span class="line">	boot_aps(); </span><br><span class="line"></span><br><span class="line">mp_main():</span><br><span class="line">	// Now that we have finished some basic setup, call sched_yield()</span><br><span class="line">	// to start running processes on this CPU.  But make sure that</span><br><span class="line">	// only one CPU can enter the scheduler at a time!</span><br><span class="line">	//</span><br><span class="line">	// Your code here: </span><br><span class="line">	lock_kernel();</span><br><span class="line">	sched_yield(); </span><br><span class="line"></span><br><span class="line">trap():</span><br><span class="line">        if ((tf-&gt;tf_cs &amp; 3) == 3) &#123;</span><br><span class="line">		// Trapped from user mode.</span><br><span class="line">		// Acquire the big kernel lock before doing any</span><br><span class="line">		// serious kernel work.</span><br><span class="line">		// LAB 4: Your code here.</span><br><span class="line">		lock_kernel();</span><br><span class="line">		assert(curenv);</span><br><span class="line"></span><br><span class="line">env_run():</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); </span><br><span class="line">	//lab4</span><br><span class="line">	unlock_kernel(); </span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));//never return</span><br></pre></td></tr></table></figure>
<p>在<code>sched_yield()</code>中实现循环调度时会调用<code>env_run()</code>函数，进而释放内核锁。经过上述加锁、释放锁操作后，只有当BSP激活所有APs并且开始调用<code>sched_yield()</code>运行用户程序时，其他CPU才可能开始执行用户程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 2. 使用内核锁可以保证一次只有一个CPU可以运行内核代码。那么，为何还需要将每个cpu的CPU栈分开？请描述一个使用了内核锁和共享内核栈后出错的场景。</span><br></pre></td></tr></table></figure>
<p>如果使用共享的内核栈的话，当出现中断时，硬件会先自动将相关寄存器进栈，然后才执行锁的检查，共享内核栈可能会导致系统崩溃。<br>支持多个cpu的时候，只有一份内核页目录，所有cpu都会使用这个页目录映射CPU栈。不同的CPU栈映射到不同的虚拟地址上。<br>在此需要注意的是另一个现象：不同的用户进程是可以同时将用户栈物理地址映射到UXSTACKTOP上的。这是因为每一个用户进程都有一份独立的页目录，创建用户进程的时候会分配和映射一页用户栈物理页到UXSTACKTOP上，多个cpu同时运行多个用户进程的时候，实际上都是使用各自的页目录进行寻址和存储数据到各自的用户栈物理页上的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Challenge: 内核锁易于使用，但它消除了内核模式下的所有并发。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，使用的方法称为细粒度锁（fine-grained locking）。细粒度锁可以显著提高性能，但更难以实现且容易出错。</span><br><span class="line">若要在jos实现细粒度锁，可以自由决定锁的粒度（即每个锁保护的数据量大小）。可以使用自旋锁来实现互斥访问以下jos内容：</span><br><span class="line">The page allocator：页分配器</span><br><span class="line">The console driver：控制台驱动</span><br><span class="line">The scheduler：调度器</span><br><span class="line">The inter-process communication (IPC) state：进程间通信状态，将在part C实现。</span><br></pre></td></tr></table></figure>
<h2 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h2><p>此部分内容将修改jos内核使之可以以循环机制（round-robin）交替调度多个进程。jos的循环机制如下：<br>1、kern/sched.c的<code>sched_yield()</code>函数负责选择一个新的进程来执行。它从上一个运行进程之后开始，以循环方式顺序搜索envs[]数组，选择第一个状态为<code>ENV_RUNNABLE</code>的进程，并调用<code>env_run()</code>函数跳转到该进程。<br>2、<code>sched_yield()</code>不能同时在两个cpu上执行调度同一个进程。区分某个进程是否正在某个cpu上运行的方法是：该进程的状态是<code>ENV_RUNNING</code>。<br>3、用户进程可以调用<code>sys_yield()</code>系统调用（该函数调用<code>sched_yield()</code>函数），自愿放弃cpu资源给其他进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exercise 6. 在sched_yield()中实现循环调度。在syscall()中分发sys_yield()。确保在mp_main()中调用sched_yield()。在kern/init.c中创建三个或三个以上进程，执行user/yield.c。在yield程序退出之后，系统将不存在可执行进程，并陷入到monitor中。</span><br><span class="line">如果CPUS=1，所有进程将会成功执行。</span><br><span class="line">如果CPUS&gt;1，一旦没有更多可运行环境，由于未处理的定时器中断可能导致一般性保护异常或内核页错误。后面将解决该问题。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">sched_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct Env *idle;</span><br><span class="line">		 </span><br><span class="line">	// Implement simple round-robin scheduling.</span><br><span class="line">	//</span><br><span class="line">	// Search through &apos;envs&apos; for an ENV_RUNNABLE environment in</span><br><span class="line">	// circular fashion starting just after the env this CPU was</span><br><span class="line">	// last running.  Switch to the first such environment found.</span><br><span class="line">	//</span><br><span class="line">	// If no envs are runnable, but the environment previously</span><br><span class="line">	// running on this CPU is still ENV_RUNNING, it&apos;s okay to</span><br><span class="line">	// choose that environment.</span><br><span class="line">	//</span><br><span class="line">	// Never choose an environment that&apos;s currently running on</span><br><span class="line">	// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="line">	// no runnable environments, simply drop through to the code</span><br><span class="line">	// below to halt the cpu.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here. </span><br><span class="line">	int i;</span><br><span class="line">	int current_env_idx = curenv ? ENVX(curenv-&gt;env_id) : 0;</span><br><span class="line">	int idx = curenv ? (current_env_idx + 1) % NENV : 0; // start by looking at the next process</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; NENV; i++) &#123;</span><br><span class="line">		if (envs[idx].env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(&amp;envs[idx]);</span><br><span class="line">		idx = (idx + 1) % NENV;</span><br><span class="line">	&#125; </span><br><span class="line">	if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		env_run(curenv);</span><br><span class="line">  </span><br><span class="line">	// sched_halt never returns</span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 3.env_run()修改了参数e的成员状态之后就会调用lcr3切换到进程的页目录，这时候内存管理单元MMU所使用的寻址上下文立即发生了变化。在地址切换前后，为什么参数e仍能够被引用？</span><br></pre></td></tr></table></figure>
<p>因为对于所有env来说，内核空间的虚拟地址是相同的，这部分地址也被映射进env的页目录。参数e本身也是内核空间的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Question 4.每次内核从一个进程切换到另一个进程的时候，需要保存旧进程的寄存器以便后面恢复，怎么做？什么时候这样做？</span><br></pre></td></tr></table></figure>
<p>由内核模式进入trap()函数时，只管调用<code>trap_dispatch()</code>就行，就算调用之后会执行新的env，也不涉及旧env寄存器存储的问题。但如果是由用户模式进入trap()函数时（trapframe上的cs表明是否来自于用户模式），可能会导致进程切换，因此在调用<code>trap_dispatch()</code>之前需要保存旧env的寄存器。具体做法是：<strong>curenv-&gt;env_tf = *tf;</strong>。之后如果切换到另一个进程，则会调用<code>env_run()</code>函数，并更新curenv变量。为什么这样子就可以保存呢？看一下变量的定义：1、<strong>#define curenv (thiscpu-&gt;cpu_env)</strong>，2、<strong>#define thiscpu (&amp;cpus[cpunum()])</strong>、3、thiscpu的<code>cpu_env</code>定义是：<strong>struct Env *cpu_env;</strong>。由上可知，<code>cpu_env</code>是一个指针，始终指向envs数组的一员，而它的更新时机在于调用<code>env_run()</code>函数的时候，实际上就是更新当前cpu执行的进程env。所以在trap()函数中通过执行<strong>curenv-&gt;env_tf = *tf;</strong>就可以将旧进程保存在栈上的trapframe值复制到<code>cpu_env</code>所指向envs数组的一员上，下次若调用到该进程，又可以恢复寄存器环境了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 将调度方式扩展为固定优先级调度，优先级高的进程将先于优先级低的进程被调度。编写测试程序测试调用顺序是正确的。</span><br></pre></td></tr></table></figure>
<p>扩展Env数据结构，添加优先级变量，然后修改调度函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Choose a user environment to run and run it.</span><br><span class="line">void</span><br><span class="line">sched_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct Env *idle;</span><br><span class="line">		 </span><br><span class="line">	// Implement simple round-robin scheduling.</span><br><span class="line">	//</span><br><span class="line">	// Search through &apos;envs&apos; for an ENV_RUNNABLE environment in</span><br><span class="line">	// circular fashion starting just after the env this CPU was</span><br><span class="line">	// last running.  Switch to the first such environment found.</span><br><span class="line">	//</span><br><span class="line">	// If no envs are runnable, but the environment previously</span><br><span class="line">	// running on this CPU is still ENV_RUNNING, it&apos;s okay to</span><br><span class="line">	// choose that environment.</span><br><span class="line">	//</span><br><span class="line">	// Never choose an environment that&apos;s currently running on</span><br><span class="line">	// another CPU (env_status == ENV_RUNNING). If there are</span><br><span class="line">	// no runnable environments, simply drop through to the code</span><br><span class="line">	// below to halt the cpu.</span><br><span class="line">	// LAB 4: Your code here.  </span><br><span class="line">  	// use priority, lab4 challenge</span><br><span class="line">	enum EnvPriority priority;</span><br><span class="line">	int i = 0;;</span><br><span class="line">	int current_env_idx = curenv ? ENVX(curenv-&gt;env_id) : 0;</span><br><span class="line">	int idx = curenv ? (current_env_idx + 1) % NENV : 0; // start by looking at the next process</span><br><span class="line"> 	for (priority = ENV_PRIORITY_HIGH; priority &lt;= ENV_PRIORITY_LOW; priority++) &#123; </span><br><span class="line">		for (i = 0; i &lt; NENV; i++) &#123;</span><br><span class="line">			if (envs[idx].env_status == ENV_RUNNABLE &amp;&amp; envs[idx].priority == priority)&#123; </span><br><span class="line">				if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING &amp;&amp; curenv-&gt;priority &lt; envs[idx].priority)&#123; </span><br><span class="line">					env_run(curenv);</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					env_run(&amp;envs[idx]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			idx = (idx + 1) % NENV;</span><br><span class="line">		&#125; </span><br><span class="line"> 	&#125;</span><br><span class="line">	if (curenv != NULL &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123; </span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// sched_halt never returns</span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试程序为user/envpriority.c，注意需要在kern/Makefrag中添加<strong>KERN_BINFILES += user/envpriority</strong>。测试程序使用到下面添加的系统调用，整体思路是由当前root进程fork多个子进程，每次fork之后设置子进程的优先级，然后调用<code>sys_yield()</code>系统调用放弃cpu，观察内核调度进程结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// test env priority</span><br><span class="line"></span><br><span class="line">#include &lt;inc/string.h&gt;</span><br><span class="line">#include &lt;inc/lib.h&gt;</span><br><span class="line"></span><br><span class="line">envid_t dumbfork_priority(uint32_t priority);</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	envid_t who,root;</span><br><span class="line">	int i,p;</span><br><span class="line">	root = sys_getenvid();</span><br><span class="line">	for (p = 1; p &lt;= 5; ++p) &#123;</span><br><span class="line">		// fork a child process</span><br><span class="line">		if(root == sys_getenvid())&#123;</span><br><span class="line">        	who = dumbfork_priority(p); </span><br><span class="line"></span><br><span class="line">			// print a message and yield to the other a few times</span><br><span class="line">			for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">				cprintf(&quot;%d: I am the %s! my env priority is %d\n&quot;, i, who ? &quot;parent&quot; : &quot;child&quot;, sys_env_get_priority());</span><br><span class="line">				sys_yield();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">duppage(envid_t dstenv, void *addr)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	// This is NOT what you should do in your fork.</span><br><span class="line">	//alloc a page mapping at child&apos;s addr</span><br><span class="line">	if ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_alloc: %e&quot;, r);</span><br><span class="line">	//map child&apos;s new page(mapping at addr) at parent&apos;s UTEMP</span><br><span class="line">	if ((r = sys_page_map(dstenv, addr, 0, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line">	//copy page data mapping at parent&apos;s addr to page mapping at parent&apos;s UTEMP</span><br><span class="line">	//as a result, it fills in child&apos;s page</span><br><span class="line">	memmove(UTEMP, addr, PGSIZE);</span><br><span class="line">	if ((r = sys_page_unmap(0, UTEMP)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_unmap: %e&quot;, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">envid_t</span><br><span class="line">dumbfork_priority(uint32_t priority)</span><br><span class="line">&#123;</span><br><span class="line">	envid_t envid;</span><br><span class="line">	uint8_t *addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[];</span><br><span class="line"></span><br><span class="line">	// Allocate a new child environment.</span><br><span class="line">	// The kernel will initialize it with a copy of our register state,</span><br><span class="line">	// so that the child will appear to have called sys_exofork() too -</span><br><span class="line">	// except that in the child, this &quot;fake&quot; call to sys_exofork()</span><br><span class="line">	// will return 0 instead of the envid of the child.</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123;</span><br><span class="line">		// We&apos;re the child.</span><br><span class="line">		// The copied value of the global variable &apos;thisenv&apos;</span><br><span class="line">		// is no longer valid (it refers to the parent!).</span><br><span class="line">		// Fix it and return 0.</span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent.</span><br><span class="line">	//set child&apos;s prioroty</span><br><span class="line">	sys_env_set_priority(envid,priority);</span><br><span class="line">	// Eagerly copy our entire address space into the child.</span><br><span class="line">	// This is NOT what you should do in your fork implementation.</span><br><span class="line">	for (addr = (uint8_t*) UTEXT; addr &lt; end; addr += PGSIZE)</span><br><span class="line">		duppage(envid, addr);</span><br><span class="line"></span><br><span class="line">	// Also copy the stack we are currently running on.</span><br><span class="line">	duppage(envid, ROUNDDOWN((void*)USTACKTOP - PGSIZE, PGSIZE)); </span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"></span><br><span class="line">	return envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/1.PNG" title="进程优先级运行结果"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! jos当前不支持应用使用x86处理器的x87 floating-point单元(FPU)、MMX指令或Streaming SIMD Extensions(SSE)。扩展Env数据结构，添加浮点状态成员（floating point state），并在进程切换代码中保存和恢复浮点状态。可使用FXSAVE和FXRSTOR指令，它们在最近的处理器才被介绍，在旧的i386用户手册中没有介绍。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h2><p><code>sys_exofork</code>：创建一个进程，创建页目录（映射内核空间，UTOP以下部分在页目录中的映射为空）、填充trapframe（包括<code>env_alloc()</code>中用户栈指针指向<code>e-&gt;env_tf.tf_esp = USTACKTOP;</code>，请注意，子进程只有将esp指向USTACKTOP，并没有再次为栈分配空间，而根父进程的栈空间是在<code>env_create()</code>的时候通过调用<code>env_alloc()</code>之后调用<code>load_icode()</code>实现的）、复制父进程的trapframe…，没有用户程序地址映射到地址空间、状态为不可执行。新进程的寄存器状态与调用<code>sys_exofork</code>的进程一样。调用<code>sys_exofork</code>的父进程返回子进程id，子进程返回0（具体原因可参考x86的fork实现）。<br><code>sys_env_set_status</code>：设置进程状态为<code>ENV_RUNNABLE</code>或<code>ENV_NOT_RUNNABLE</code>，通常是进程的地址映射和寄存器状态设置完毕之后设置进程可被执行。<br><code>sys_page_alloc</code>：分配一页物理页，并在指定进程的地址空间上映射到给定的虚拟地址。<br><code>sys_page_map</code>：将A进程中映射到虚拟地址<code>va_a</code>的物理页映射到B进程的虚拟地址<code>va_b</code>，设置给出的权限。从而两个进程可以以不同的权限访问同一个物理页。<br><code>sys_page_unmap</code>：在指定进程的地址空间上解除给定的虚拟地址上的映射。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 7.完成以上内容。jos的envid2env()函数可以根据id获取对应的进程结构，并且传入0可以获取当前进程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a new environment.</span><br><span class="line">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_NO_FREE_ENV if no free environment is available.</span><br><span class="line">//	-E_NO_MEM on memory exhaustion.</span><br><span class="line">static envid_t</span><br><span class="line">sys_exofork(void)</span><br><span class="line">&#123;</span><br><span class="line">	// Create the new environment with env_alloc(), from kern/env.c.</span><br><span class="line">	// It should be left as env_alloc created it, except that</span><br><span class="line">	// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><br><span class="line">	// from the current environment -- but tweaked so sys_exofork</span><br><span class="line">	// will appear to return 0.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_exofork not implemented&quot;);</span><br><span class="line">	struct Env *newEnv; </span><br><span class="line">	//set kernal stack, page dir, trapframe...</span><br><span class="line">	int r = env_alloc(&amp;newEnv,curenv-&gt;env_id);</span><br><span class="line">	if(r&lt;0) return r;</span><br><span class="line">	newEnv-&gt;env_status = ENV_NOT_RUNNABLE; </span><br><span class="line">	newEnv-&gt;env_tf = curenv-&gt;env_tf; </span><br><span class="line">	//or : memmove((void *) &amp;newEnv-&gt;env_tf, (void *) &amp;curenv-&gt;env_tf, sizeof(struct Trapframe));</span><br><span class="line">	//clear child&apos;s eax,so it will return pid 0</span><br><span class="line">	newEnv-&gt;env_tf.tf_regs.reg_eax = 0;</span><br><span class="line">	return newEnv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Set envid&apos;s env_status to status, which must be ENV_RUNNABLE</span><br><span class="line">// or ENV_NOT_RUNNABLE.</span><br><span class="line">//</span><br><span class="line">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if status is not a valid status for an environment.</span><br><span class="line">static int</span><br><span class="line">sys_env_set_status(envid_t envid, int status)</span><br><span class="line">&#123;</span><br><span class="line">	// Hint: You should set envid2env&apos;s third argument to 1, which will</span><br><span class="line">	// check whether the current environment has permission to set</span><br><span class="line">	// envid&apos;s status.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_env_set_status not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to set envid&apos;s status. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	if(status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) return -E_INVAL;</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Allocate a page of memory and map it at &apos;va&apos; with permission</span><br><span class="line">// &apos;perm&apos; in the address space of &apos;envid&apos;.</span><br><span class="line">// The page&apos;s contents are set to 0.</span><br><span class="line">// If a page is already mapped at &apos;va&apos;, that page is unmapped as a</span><br><span class="line">// side effect.</span><br><span class="line">//</span><br><span class="line">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span><br><span class="line">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span><br><span class="line">//	-E_INVAL if perm is inappropriate (see above).</span><br><span class="line">//	-E_NO_MEM if there&apos;s no memory to allocate the new page,</span><br><span class="line">//		or to allocate any necessary page tables.</span><br><span class="line">static int</span><br><span class="line">sys_page_alloc(envid_t envid, void *va, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_alloc not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true); </span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)va &gt;= UTOP || (uint32_t)va%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">	//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">	if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">		return -E_INVAL;</span><br><span class="line"></span><br><span class="line">	struct PageInfo *page = page_alloc(ALLOC_ZERO);</span><br><span class="line">	if(page == NULL) return -E_NO_MEM;</span><br><span class="line">	</span><br><span class="line">	//store page&apos;s mapping physical address and perm in va&apos;s mapping page table entry</span><br><span class="line">	r = page_insert(e-&gt;env_pgdir, page, va, perm);</span><br><span class="line">	if(r&lt;0) &#123;</span><br><span class="line">		page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">		return r;//-E_NO_MEM</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// Map the page of memory at &apos;srcva&apos; in srcenvid&apos;s address space</span><br><span class="line">// at &apos;dstva&apos; in dstenvid&apos;s address space with permission &apos;perm&apos;.</span><br><span class="line">// Perm has the same restrictions as in sys_page_alloc, except</span><br><span class="line">// that it also must not grant write access to a read-only</span><br><span class="line">// page.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change one of them.</span><br><span class="line">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span><br><span class="line">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span><br><span class="line">//	-E_INVAL is srcva is not mapped in srcenvid&apos;s address space.</span><br><span class="line">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span><br><span class="line">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&apos;s</span><br><span class="line">//		address space.</span><br><span class="line">//	-E_NO_MEM if there&apos;s no memory to allocate any necessary page tables.</span><br><span class="line">static int</span><br><span class="line">sys_page_map(envid_t srcenvid, void *srcva,</span><br><span class="line">	     envid_t dstenvid, void *dstva, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_map not implemented&quot;);</span><br><span class="line">	struct Env *srce,*dste; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(srcenvid,&amp;srce,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	r = envid2env(dstenvid,&amp;dste,true);//envid 0 means &quot;the current environment.&quot;</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)srcva &gt;= UTOP || (uint32_t)srcva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	if((uint32_t)dstva &gt;= UTOP || (uint32_t)dstva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	//return the page mapped at virtual address &apos;va&apos;</span><br><span class="line">	//pte_store stores the address of the page table entry for this page</span><br><span class="line">	pte_t *pte_store;</span><br><span class="line">	struct PageInfo *page = page_lookup(srce-&gt;env_pgdir, srcva, &amp;pte_store);</span><br><span class="line">	if(page == NULL) return -E_INVAL;//no page mapped at srcva</span><br><span class="line"></span><br><span class="line">	if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">	//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">	if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">		return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	if((*pte_store &amp; PTE_W) != PTE_W &amp;&amp; ((perm &amp; PTE_W) == PTE_W)) return -E_INVAL;//srcva is read-only but perm is writable</span><br><span class="line"></span><br><span class="line">	//store page&apos;s mapping physical address and perm in dstva&apos;s mapping page table entry</span><br><span class="line">	r = page_insert(dste-&gt;env_pgdir, page, dstva, perm);// allow to create page table</span><br><span class="line">	if(r&lt;0) &#123;</span><br><span class="line">		page_remove(dste-&gt;env_pgdir,dstva);</span><br><span class="line">		return r;//-E_NO_MEM</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Unmap the page of memory at &apos;va&apos; in the address space of &apos;envid&apos;.</span><br><span class="line">// If no page is mapped, the function silently succeeds.</span><br><span class="line">//</span><br><span class="line">// Return 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span><br><span class="line">static int</span><br><span class="line">sys_page_unmap(envid_t envid, void *va)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_page_unmap not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	</span><br><span class="line">	if((uint32_t)va &gt;= UTOP || (uint32_t)va%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 添加系统调用以读取某个进程的所有重要状态。实现一个用户程序，该程序fork一个子进程，运行该程序（即循环迭代sys_yield()），然后获取子进程的完整snapshot或checkpoint，然后执行子程序一段时间。最后，恢复子进程在检查点的状态，然后继续执行子进程。这相当于从某个中间状态replaying子进程的执行。使用sys_cgetc()或readline()函数保证子进程与用户之间进行交互，以便用户可以查看和改变其内部状态。确保子进程在检查点处恢复执行时，子进程&quot;forget&quot;了之前任何发生在检查点之后的内容。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h1><p>xv6实现的fork()将父进程所有物理页的内容拷贝给了分配给子进程的新物理页，类似于jos的dumbfork()函数。fork()过程中最“昂贵”的操作就是将父进程的地址空间拷贝给子进程。然而在子进程中，通常是紧接着就执行exec()，以新程序替代子进程执行。在这种情况下，父进程拷贝地址空间给子进程所花时间将被大大浪费了，因为子进程在执行exec()之前只使用了一小部分内存。鉴于此，更新版本的unix利用虚拟内存硬件允许父子进程共享分别映射到它们各自地址空间的物理内存，直至其中一方修改物理内存，这种技术称为“写时复制”。fork()将父进程地址空间的映射情况复制到子进程中，而不是复制父进程映射的物理页内容，并将共享的物理页标记为“只读”。当父子进程其中一方尝试写入到任一页共享的内存页，该进程将触发页错误。在这种情况下，内核识别出该页是“写时复制”副本，并为触发页错误的进程创建新的私有的可写入页。</p>
<h2 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h2><p>将Copy-on-Write Fork实现为一个用户空间库例程有以下优点：1、内核更为简单，更为正确；2、允许用户进程定义fork()的语义，用户程序可以很容易地提供一个稍有不同的实现版本，例如dumbfork()这种昂贵的always-copy版本，或者父子进程共享内存的版本。用户级别的Copy-on-Write Fork需要能够识别出在写保护页上触发的页错误。</p>
<p>典型的unix内核需要知道在进程地址空间的每一个区域上触发页错误时应该采取什么方法，例如：栈空间触发页错误时应该分配和映射新的物理页，在大多数unix内核中，一开始只给新进程分配一页的栈空间，用户程序在栈空间不足的情况下访问未映射的栈地址会触发页错误，从而导致内核分配并映射新物理页到栈空间；BSS空间触发页错误时应该分配新的一页、填充0并映射到地址空间；如果系统支持按需分配物理页的可执行文件，text region触发页错误时将从磁盘读取相应二进制页并映射到地址空间。</p>
<p>上述情况中内核需要跟踪许多信息。我们不采取传统的unix方法，而是在用户空间中决定对每个页错误所采取的行动。这种设计的好处是用户程序在定义内存区域时有极大的灵活性，我们将在后续使用用户级页错误处理程序来映射和访问基于硬盘的文件系统上的文件。</p>
<h2 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 8. 实现sys_env_set_pgfault_upcall系统调用，该系统调用用于注册用户程序触发页错误时的处理函数入口。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Set the page fault upcall for &apos;envid&apos; by modifying the corresponding struct</span><br><span class="line">// Env&apos;s &apos;env_pgfault_upcall&apos; field.  When &apos;envid&apos; causes a page fault, the</span><br><span class="line">// kernel will push a fault record onto the exception stack, then branch to</span><br><span class="line">// &apos;func&apos;.</span><br><span class="line">//</span><br><span class="line">// Returns 0 on success, &lt; 0 on error.  Errors are:</span><br><span class="line">//	-E_BAD_ENV if environment envid doesn&apos;t currently exist,</span><br><span class="line">//		or the caller doesn&apos;t have permission to change envid.</span><br><span class="line">static int</span><br><span class="line">sys_env_set_pgfault_upcall(envid_t envid, void *func)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;); </span><br><span class="line">	struct Env *e; </span><br><span class="line">	// check whether the current environment has permission to change envid. </span><br><span class="line">	// i.e.,the specified environment must be either the</span><br><span class="line">	// current environment or an immediate child of the current environment.</span><br><span class="line">	int r = envid2env(envid,&amp;e,true);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	e-&gt;env_pgfault_upcall = func;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h2><p>jos正常执行进程过程中，用户进程所使用的用户栈是[USTACKTOP-PGSIZE,USTACKTOP-1]。然而，当用户程序触发页错误时，内核将在另一个栈[UXSTACKTOP-PGSIZE,UXSTACKTOP-1]上执行设计好的页错误处理函数，这个栈称为user exception stack。类似于x86为jos设计的由用户模式切换到内核模式时的栈切换，我们将在jos内核为用户程序设计自动栈切换。<br>当执行用户设计的页错误处理函数时，可以根据页错误原因使用jos的系统调用来映射新物理页或调整映射情况。之后页错误处理函数返回，通过汇编语言返回到原先触发页错误的代码。<br>每一个需要使用用户级别页错误处理流程的用户程序需要自行为user exception stack申请内存空间。</p>
<h2 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h2><p>用户程序触发页错误时，用户进程的状态称为“the trap-time state”。如果没有注册页错误处理程序，内核将销毁进程。否则，内核在异常栈上设置struct UTrapframe（见inc/trap.h），UTrapframe的值主要来源于内核栈的trap frame。之后，内核安排用户级页错误处理程序在异常栈上执行。<br>如果发生页错误的时候用户进程已经在异常栈上执行（<code>tf-&gt;tf_esp</code>在[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]内），说明页错误处理程序本身触发了页错误。这种时候应该在<code>tf-&gt;tf_esp</code>而不是<code>UXSTACKTOP</code>的以下部分存储UTrapframe，而且需要先留空4个字节，再存储UTrapframe，具体原因下面讲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 9. 完成kern/trap.c的page_fault_handler函数，该函数主要负责处理页错误，如果触发页错误的是用户进程，则检查页错误处理程序是否已设置、页错误处理程序地址是否合法、异常栈指针是否越界、是否递归触发页错误、是否已为异常栈分配物理页，然后在异常栈上存储UTrapframe，将栈指针指向异常栈，并跳转执行用户级页错误处理程序入口。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">    // Read processor&apos;s CR2 register to find the faulting address</span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    // Handle kernel-mode page faults.</span><br><span class="line"></span><br><span class="line">    // LAB 3: Your code here.</span><br><span class="line">    if ((tf-&gt;tf_cs&amp;3) == 0)</span><br><span class="line">        panic(&quot;Kernel page fault!&quot;);</span><br><span class="line">    // We&apos;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="line">    // the page fault happened in user mode.</span><br><span class="line"> </span><br><span class="line">    // LAB 4: Your code here. </span><br><span class="line">    //1. test if has page fault upcall</span><br><span class="line">    if (curenv-&gt;env_pgfault_upcall == NULL ||</span><br><span class="line">        //2. test if the exception stack overflows</span><br><span class="line">        tf-&gt;tf_esp &gt; UXSTACKTOP || (tf-&gt;tf_esp &gt; USTACKTOP &amp;&amp; tf-&gt;tf_esp &lt; (UXSTACKTOP - PGSIZE)))&#123;</span><br><span class="line">        // Destroy the environment that caused the fault.</span><br><span class="line">        cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">            curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        env_destroy(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. test if page fault upcall valid</span><br><span class="line">    user_mem_assert(curenv, (void *)curenv-&gt;env_pgfault_upcall, 1, 0);</span><br><span class="line">	</span><br><span class="line">    //determine user exception stack pointer</span><br><span class="line">    uint32_t exception_stack_top = 0;</span><br><span class="line">    if(tf-&gt;tf_esp &lt;= USTACKTOP)&#123;</span><br><span class="line">        exception_stack_top = UXSTACKTOP - sizeof(struct UTrapframe);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //+4 : leave an extra word between the current top of the exception stack</span><br><span class="line">        exception_stack_top = tf-&gt;tf_esp - sizeof(struct UTrapframe) - 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2. test if the exception stack overflows</span><br><span class="line">    if(exception_stack_top &lt; (UXSTACKTOP - PGSIZE))&#123;</span><br><span class="line">        // Destroy the environment that caused the fault.</span><br><span class="line">        cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">            curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        env_destroy(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3. test if allocate a page for its exception stack or if can write to it</span><br><span class="line">    user_mem_assert(curenv, (void *) exception_stack_top, 1, PTE_W | PTE_U);//1 is enough, may not return</span><br><span class="line">	 </span><br><span class="line">    //write UTrapframe in the stack</span><br><span class="line">    struct UTrapframe* utf = (struct UTrapframe*)exception_stack_top;</span><br><span class="line">    utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">    utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">    utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">    utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">    utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">    utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">    //branch to curenv-&gt;env_pgfault_upcall, that means we should change trapframe&apos;s esp and eip</span><br><span class="line">    tf-&gt;tf_esp = (uintptr_t) exception_stack_top;</span><br><span class="line">    tf-&gt;tf_eip = (uintptr_t) curenv-&gt;env_pgfault_upcall;</span><br><span class="line">    env_run(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h2><p>xv6的定时函数是在内核trap时将esp所指单元向下移动一个单元，然后存储tf的eip（触发中断的下一条指令），然后将tf的eip指向处理函数，然后弹出tf寄存器执行定时函数，定时函数返回时弹出trap设置的eip，进而执行用户函数。这种情况下esp仍然指向用户栈。<br>jos的用户级页错误处理程序入口是<code>_pgfault_upcall</code>，包括调用执行真正的处理程序和恢复执行用户函数。<code>_pgfault_upcall</code>将通过系统调用设置为页错误处理程序入口，内核trap时将tf的相关值复制到异常栈上，将tf的esp指向异常栈，然后弹出tf寄存器执行页错误处理程序入口。这种情况下执行处理函数的时候esp指向的是异常栈，设置异常栈可以方便传递参数。<br>用户级页错误处理程序执行完后，将返回执行原先触发页错误的用户代码（如果是页错误处理程序触发页错误，则应返回执行原先触发页错误的页错误处理程序）。lib/pfentry.S完成这个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 10. 完成lib/pfentry.S。触发页错误时内核实际上是跳转执行该文件声明的入口_pgfault_upcall。pfentry.S主要是在用户态的page_fault_handler结束后如何恢复现场并跳回原程序执行。</span><br></pre></td></tr></table></figure></p>
<p>内核在异常栈上存储UTrapframe之后安排用户级页错误处理程序在异常栈上执行。异常栈上的UTrapframe布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP or tf-&gt;tf_esp</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time oesp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure></p>
<p>分两种情况分析：<br>1、非递归触发页错误。由于此时是在异常栈上，想要恢复执行触发页错误的用户代码时，需要弹出通用寄存器，并由异常栈跳转到用户栈，最后执行ret恢复执行。因此，关键点是如何在弹出通用寄存器和eflags之前将eip存储到用户栈上。需要借助通用寄存器存储PushRegs的位置和eip的值，再跳到用户栈，存储eip，然后再跳回PushRegs位置，弹出通用寄存器和eflags，最后跳回用户栈执行ret（实验发现最后跳回用户栈之后，此时已经存了eip，如果执行subl向下跳到存eip的位置会改变eflags，因此在跳到用户栈存储eip之后，将最新的esp位置存到异常栈上，最后由异常栈直接跳到用户栈执行ret）。<br>2、递归触发页错误。与情况1不同的是，“用户栈”其实就是异常栈本身。因此，在跳到“用户栈”存储eip的时候，由于弹出的trap-time esp值恰好就是存储trap-time esp所在的位置（trap的时候esp指向异常栈该位置，然后跳到内核栈，内核再从异常栈该位置开始存储UTrapframe），存储eip会将trap-time esp覆盖，从而导致最后不能成功再跳回用户栈。这就是为什么如果是递归触发页错误的话，需要先留空4个字节，再存储UTrapframe，主要是为了防止存储eip的时候覆盖了原先的esp值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line">#include &lt;inc/memlayout.h&gt;</span><br><span class="line"></span><br><span class="line">// Page fault upcall entrypoint.</span><br><span class="line"> </span><br><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp           // pop function argument</span><br><span class="line">    </span><br><span class="line">    // Now the C page fault handler has returned and you must return</span><br><span class="line">    // to the trap time state.</span><br><span class="line">    // Push trap-time %eip onto the trap-time stack.</span><br><span class="line">    //</span><br><span class="line">    // Explanation:</span><br><span class="line">    //   We must prepare the trap-time stack for our eventual return to</span><br><span class="line">    //   re-execute the instruction that faulted.</span><br><span class="line">    //   Unfortunately, we can&apos;t return directly from the exception stack:</span><br><span class="line">    //   We can&apos;t call &apos;jmp&apos;, since that requires that we load the address</span><br><span class="line">    //   into a register, and all registers must have their trap-time</span><br><span class="line">    //   values after the return.</span><br><span class="line">    //   We can&apos;t call &apos;ret&apos; from the exception stack either, since if we</span><br><span class="line">    //   did, %esp would have the wrong value.</span><br><span class="line">    //   So instead, we push the trap-time %eip onto the *trap-time* stack!</span><br><span class="line">    //   Below we&apos;ll switch to that stack and call &apos;ret&apos;, which will</span><br><span class="line">    //   restore %eip to its pre-fault value.</span><br><span class="line">    //</span><br><span class="line">    //   In the case of a recursive fault on the exception stack,</span><br><span class="line">    //   note that the word we&apos;re pushing now will fit in the</span><br><span class="line">    //   blank word that the kernel reserved for us.</span><br><span class="line">    //</span><br><span class="line">    // Throughout the remaining code, think carefully about what</span><br><span class="line">    // registers are available for intermediate calculations.  You</span><br><span class="line">    // may find that you have to rearrange your code in non-obvious</span><br><span class="line">    // ways as registers become unavailable as scratch space.</span><br><span class="line">    //</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Restore the trap-time registers.  After you do this, you</span><br><span class="line">    // can no longer modify any general-purpose registers.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Restore eflags from the stack.  After you do this, you can</span><br><span class="line">    // no longer use arithmetic operations or anything else that</span><br><span class="line">    // modifies eflags.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Switch back to the adjusted trap-time stack.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">    // Return to re-execute the instruction that faulted.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line"> </span><br><span class="line">    addl $8, %esp  </span><br><span class="line">    movl %esp,%eax  </span><br><span class="line">    addl $32,%esp  </span><br><span class="line">    popl %ebx  </span><br><span class="line">    addl $4,%esp  </span><br><span class="line">    movl %esp, %ebp </span><br><span class="line">    popl %esp  </span><br><span class="line">    pushl %ebx  </span><br><span class="line">    movl %esp, 0x0(%ebp) </span><br><span class="line">    movl %eax,%esp  </span><br><span class="line">    popal  </span><br><span class="line">    addl $4,%esp  </span><br><span class="line">    popf  </span><br><span class="line">    popl %esp  </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">//  do not use the following, cause I find that &apos;subl $4,%esp&apos; will change eflags!</span><br><span class="line"></span><br><span class="line">//	addl $8, %esp  </span><br><span class="line">//	movl %esp,%eax  </span><br><span class="line">//	addl $32,%esp  </span><br><span class="line">//	popl %ebx  </span><br><span class="line">//	addl $4,%esp  </span><br><span class="line">//	popl %esp  </span><br><span class="line">//	pushl %ebx  </span><br><span class="line">//	movl %eax,%esp  </span><br><span class="line">//	popal  </span><br><span class="line">//	addl $4,%esp  </span><br><span class="line">//	popf  </span><br><span class="line">//	popl %esp  </span><br><span class="line">//	subl $4,%esp  </span><br><span class="line">//	ret</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 11. 完成lib/pgfault.c的set_pgfault_handler()。该函数主要完成页错误处理程序的注册工作。如果是第一次注册，则申请分配并映射异常栈。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">set_pgfault_handler(void (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	if (_pgfault_handler == 0) &#123;</span><br><span class="line">		// First time through!</span><br><span class="line">		// LAB 4: Your code here.</span><br><span class="line">		//panic(&quot;set_pgfault_handler not implemented&quot;);</span><br><span class="line">		if (sys_page_alloc(sys_getenvid(), (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">			panic(&quot;in set_pgfault_handler, sys_page_alloc failed&quot;);</span><br><span class="line">		sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Save handler pointer for assembly to call.</span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，用户级别的页错误处理流程如下：<br>1、用户程序通过<code>lib/pgfault.c</code>的<code>set_pgfault_handler()</code>函数注册页错误处理函数入口<code>_pgfault_upcall</code>（见lib/pfentry.S），并指定页错误处理函数<code>_pgfault_handler</code>，该函数指针将在<code>_pgfault_upcall</code>中被使用。第一次注册<code>_pgfault_upcall</code>时将申请分配并映射异常栈。<br>2、用户程序触发页错误，切换到内核模式。<br>3、内核检查页错误处理程序是否已设置、异常栈指针是否越界、是否递归触发页错误、是否已为异常栈分配物理页，然后在异常栈上存储UTrapframe，将栈指针指向异常栈，并跳转执行当前进程的<code>env_pgfault_upcall</code>（被设为用户级页错误处理程序入口<code>_pgfault_upcall</code>）。<br>4、用户模式下<code>_pgfault_upcall</code>调用<code>_pgfault_upcall</code>，执行用户级别页错误处理函数，在用户态的<code>page_fault_handler</code>结束后恢复现场并跳回原程序执行。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>user/faultalloc.c涉及了递归触发页错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// test user-level fault handler -- alloc pages to fix faults</span><br><span class="line"></span><br><span class="line">#include &lt;inc/lib.h&gt;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">handler(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line">	void *addr = (void*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(&quot;fault %x\n&quot;, addr);</span><br><span class="line">	if ((r = sys_page_alloc(0, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;allocating at %x in page fault handler: %e&quot;, addr, r);</span><br><span class="line">	snprintf((char*) addr, 100, &quot;this string was faulted in at %x&quot;, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">umain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	cprintf(&quot;%s\n&quot;, (char*)0xDeadBeef);</span><br><span class="line">	cprintf(&quot;%s\n&quot;, (char*)0xCafeBffe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/2.PNG" title="user/faultalloc.c递归触发页错误">
<p>首先，snprintf的定义是<code>int snprintf(char *buf, int n, const char *fmt, ...)</code>，向buf缓存区中按照格式填充字符串。<br>出错的原因是：当执行<code>cprintf(&quot;%s\n&quot;, (char*)0xCafeBffe);</code>时，触发了页错误。页错误处理函数在虚拟地址<code>ROUNDDOWN(addr, PGSIZE)</code>即cafeb000上分配和映射物理页，此时可访问的虚拟地址空间为[0xcafeb000,0xcafec000-1]。之后，调用snprintf向0xCafeBffe内存地址上填充字符串，由于字符串过长，导致越界访问0xcafec000，再次触发页错误。第二次页错误处理程序往0xcafec000填充字符串，返回到第一次页错误处理程序，第一次页错误处理程序往0xCafeBffe填充字符串，返回到用户程序，执行cprintf进行输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 扩展jos内核，对运行用户程序代码时能触发的所有类型的处理器异常，都能重定向到用户模式的异常处理程序。编写用户模式的测试程序，测试divide-by-zero、general protection fault、illegal opcode等。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h2><p>jos使用Copy-on-Write Fork时，将会扫描父进程的整个地址空间，并设置子进程的相关页映射，但不会复制页内容（dumpfork()复制页内容）。当父/子进程尝试写入某一页时，将申请新的一页并拷贝页内容到该页上。<br>fork()的基本流程如下：<br>1、父进程调用<code>set_pgfault_handler()</code>注册页错误处理函数<code>pgfault()</code>。<br>2、父进程调用<code>sys_exofork()</code>创建子进程。<br>3、对于[UTEXT,UTOP)每一个可写或写时复制的页，父进程调用duppage分别在子进程和自身的地址空间内映射该页为写时复制<code>PTE_COW</code>。<br>注意：不能将user exception stack映射为写时复制，而是应该为父子进程分别映射对应的物理页。这是因为页错误处理程序将在user exception stack上执行，当将user exception stack设为写时复制时，一旦发生页错误，内核将尝试往user exception stack写数据，由于user exception stack不可写而导致失败。<br>4、父进程为子进程注册页错误处理函数。<br>注意：我们不在子进程中注册页错误处理函数。首先，我们不在子进程中调用<code>set_pgfault_handler()</code>（该函数注册页错误处理函数，并在页错误处理函数未注册的情况下申请user exception stack），因为子进程是由父进程fork而来的，而父进程已经注册过页错误处理函数，所以在子进程中注册页错误处理函数的话子进程不会再申请user exception stack（<code>if (_pgfault_handler == 0)</code>条件判断失败）。其次，我们不在子进程中调用<code>sys_page_alloc()</code>和<code>sys_env_set_pgfault_upcall()</code>申请user exception stack，这是因为这涉及了函数调用，而父进程将子进程的用户栈映射为写时复制了，所以会触发页错误，但是此时还没有分配user exception stack，因此出错。<br>5、设置子进程状态为runnable。</p>
<p>页错误处理函数的处理流程如下：<br>1、内核跳转执行<code>_pgfault_upcall</code>，<code>_pgfault_upcall</code>将调用页错误处理函数pgfault()。<br>2、pgfault()确认fault是可写的（错误码的FEC_WR），并且引起页错误的虚拟地址对应的页表项权限为<code>PTE_COW</code>。<br>3、pgfault()为申请新的一页，映射到一个临时地址，将faulting page的内容复制到该新页，调用<code>sys_page_map</code>将映射到临时地址的物理页映射到引起页错误的虚拟地址，设置权限为可写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 12.实现lib/fork.c的fork、duppage、pgfault。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">// PTE_COW marks copy-on-write page table entries.</span><br><span class="line">// It is one of the bits explicitly allocated to user processes (PTE_AVAIL).</span><br><span class="line">#define PTE_COW		0x800</span><br><span class="line">extern void _pgfault_upcall(void);</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Custom page fault handler - if faulting page is copy-on-write,</span><br><span class="line">// map in our own private writable copy.</span><br><span class="line">//</span><br><span class="line">static void</span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	void *addr = (void *) utf-&gt;utf_fault_va;</span><br><span class="line">	uint32_t err = utf-&gt;utf_err;</span><br><span class="line">	int r;</span><br><span class="line">	// Check that the faulting access was (1) a write, and (2) to a</span><br><span class="line">	// copy-on-write page.  If not, panic.</span><br><span class="line">	// Hint:</span><br><span class="line">	//   Use the read-only page table mappings at uvpt</span><br><span class="line">	//   (see &lt;inc/memlayout.h&gt;).</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	if ((err &amp; FEC_WR) == 0)</span><br><span class="line">		panic(&quot;pgfault: faulting address [%08x] not a write\n&quot;, addr);</span><br><span class="line"></span><br><span class="line">	if( (uvpd[PDX(addr)] &amp; PTE_P) != PTE_P || </span><br><span class="line">	    (uvpt[PGNUM(addr)] &amp; PTE_P) != PTE_P || </span><br><span class="line">	    (uvpt[PGNUM(addr)] &amp; PTE_COW) != PTE_COW)&#123; </span><br><span class="line">		//cprintf(&quot;(uvpt[PTX(addr)] &amp; PTE_P)=%x,PTE_P=%x\n&quot;,(uvpt[PGNUM(addr)] &amp; PTE_P),PTE_P);</span><br><span class="line">		panic(&quot;not copy-on-write&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// Allocate a new page, map it at a temporary location (PFTEMP),</span><br><span class="line">	// copy the data from the old page to the new page, then move the new</span><br><span class="line">	// page to the old page&apos;s address.</span><br><span class="line">	// Hint:</span><br><span class="line">	//   You should make three system calls.</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">	//panic(&quot;pgfault not implemented&quot;);</span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	if ((r = sys_page_alloc(0, PFTEMP, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;allocating at %x in page fault handler: %e&quot;, addr, r);</span><br><span class="line">	memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">	//cprintf(&quot;in user pgfault,envid = %x\n&quot;,thisenv-&gt;env_id);</span><br><span class="line">	if ((r = sys_page_map(0, PFTEMP, 0, addr, PTE_P|PTE_U|PTE_W)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line">	if ((r = sys_page_unmap(0, PFTEMP)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_page_unmap: %e&quot;, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span><br><span class="line">// at the same virtual address.  If the page is writable or copy-on-write,</span><br><span class="line">// the new mapping must be created copy-on-write, and then our mapping must be</span><br><span class="line">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span><br><span class="line">// copy-on-write again if it was already copy-on-write at the beginning of</span><br><span class="line">// this function?)</span><br><span class="line">//</span><br><span class="line">// Returns: 0 on success, &lt; 0 on error.</span><br><span class="line">// It is also OK to panic on error.</span><br><span class="line">//</span><br><span class="line">static int</span><br><span class="line">duppage(envid_t envid, unsigned pn)</span><br><span class="line">&#123;</span><br><span class="line">	int r;</span><br><span class="line"></span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;duppage not implemented&quot;); </span><br><span class="line">	void *addr = (void *)(pn*PGSIZE);</span><br><span class="line">	if( (uvpt[pn] &amp; PTE_W) == PTE_W || </span><br><span class="line">	    (uvpt[pn] &amp; PTE_COW) == PTE_COW)&#123; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line"> 		if ((r = sys_page_map(0, (void *)addr, 0, (void *)addr, PTE_P|PTE_U|PTE_COW)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, PTE_P|PTE_U)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// User-level fork with copy-on-write.</span><br><span class="line">// Set up our page fault handler appropriately.</span><br><span class="line">// Create a child.</span><br><span class="line">// Copy our address space and page fault handler setup to the child.</span><br><span class="line">// Then mark the child as runnable and return.</span><br><span class="line">//</span><br><span class="line">// Returns: child&apos;s envid to the parent, 0 to the child, &lt; 0 on error.</span><br><span class="line">// It is also OK to panic on error.</span><br><span class="line">//</span><br><span class="line">// Hint:</span><br><span class="line">//   Use uvpd, uvpt, and duppage.</span><br><span class="line">//   Remember to fix &quot;thisenv&quot; in the child process.</span><br><span class="line">//   Neither user exception stack should ever be marked copy-on-write,</span><br><span class="line">//   so you must allocate a new page for the child&apos;s user exception stack.</span><br><span class="line">//</span><br><span class="line">envid_t</span><br><span class="line">fork(void)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;fork not implemented&quot;);</span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	envid_t envid;</span><br><span class="line">	unsigned addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[]; </span><br><span class="line"></span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123;</span><br><span class="line">		// We&apos;re the child. </span><br><span class="line">		// DO NOT CALL set_pgfault_handler DIRECTLY! Cause we are forked from parent who has</span><br><span class="line">		// called &quot;set_pgfault_handler&quot;, so the variable named &quot;_pgfault_handler&quot; in pgfault.c has been set,</span><br><span class="line">		// and child-env will not call &quot;sys_page_alloc&quot; and &quot;sys_env_set_pgfault_upcall&quot;</span><br><span class="line">		// do not call: set_pgfault_handler(pgfault); </span><br><span class="line">		</span><br><span class="line">		// DO NOT SET USER EXCEPTION STACK IN CHILD! Cause we set COW on user stack(not user exception stack), so function call</span><br><span class="line">		// like &quot;sys_page_alloc&quot; and &quot;sys_env_set_pgfault_upcall&quot;(which want to stack user excettion stack) </span><br><span class="line">		// will cause page fault, and kern will use user excettion stack, but it has not been set!!</span><br><span class="line">		// do not call:</span><br><span class="line">	  	// if (sys_page_alloc(0, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		//	 panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">		// if (sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall) &lt; 0) </span><br><span class="line">		// 	 panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line">		//  </span><br><span class="line"></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent. </span><br><span class="line">	// map the page copy-on-write into the address space of the child </span><br><span class="line">	// and then remap the page copy-on-write in its own address space</span><br><span class="line">	for (addr = UTEXT; addr &lt; (unsigned)end; addr += PGSIZE)&#123;</span><br><span class="line">		duppage(envid, PGNUM(addr)); </span><br><span class="line">	&#125; </span><br><span class="line">	// map the stack we are currently running on.</span><br><span class="line">	duppage(envid, PGNUM(USTACKTOP - PGSIZE));    </span><br><span class="line">    // also can:</span><br><span class="line">  	/*</span><br><span class="line">	for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE)</span><br><span class="line">		if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P)</span><br><span class="line">		    &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">		    duppage(envid, PGNUM(addr)); </span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">	if (sys_env_set_pgfault_upcall(envid, (void*) _pgfault_upcall) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line"></span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"> </span><br><span class="line">	return envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于uvpd和uvpt数组"><a href="#关于uvpd和uvpt数组" class="headerlink" title="关于uvpd和uvpt数组"></a>关于uvpd和uvpt数组</h2><p>为了能通过虚拟地址访问到页表和页目录，jos设计了UVPT和UVPD（见Lab3笔记）。一旦设置uvpt数组并指向UVPT，uvpt相当于包含1M个页表项的数组。对于[0, 4G)的线性地址，其在通过地址转换过程中找到的页表项，刚好是以线性地址前20位为索引在uvpt中的项，即uvpt[PGNUM(线性地址)]。对于[UVPT, UVPT+4M)的线性地址，其在uvpt数组中索引到的刚好是页目录这张页表中的项。<br>一旦设置uvpd数组并指向(UVPT+(UVPT&gt;&gt;12)*4)，则uvpd相当于包含1K个页目录项的数组。<br><img src="/2017/08/20/笔记016-Lab4-Preemptive-Multitasking/3.png" title="关于uvpd和uvpt数组"><br>另外，注意到每个进程访问uvpt[]和uvpd[]时，都是彼此独立的。这是因为：如访问uvpt[i]，最终是访问uvpt[i]相关联的UVPT之上的一个虚拟地址，每个进程的页目录和页表都是根据自身情况请求分配页之后的映射结果，如果进程A在该虚拟地址上没有映射页，则uvpt[i]为空，而如果进程B在该虚拟地址上有映射页，则uvpt[i]不为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 完成sfork，使父子进程能共享内存，除了用户栈和用户异常栈。</span><br></pre></td></tr></table></figure>
<p>请注意，<code>sys_exofork</code>创建的子进程页目录只映射了内核空间，我们需要自行映射子进程的地址空间。另一方面，页表项低12位表示权限，但是<code>sys_page_map</code>中不支持设置<code>PTE_AVAIL | PTE_P | PTE_W | PTE_U</code>以外的权限位，因此需要对页表项权限提取进行&amp;处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">sfork(void)</span><br><span class="line">&#123; </span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	envid_t envid;</span><br><span class="line">	unsigned addr;</span><br><span class="line">	int r;</span><br><span class="line">	extern unsigned char end[]; </span><br><span class="line"></span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	if (envid &lt; 0)</span><br><span class="line">		panic(&quot;sys_exofork: %e&quot;, envid);</span><br><span class="line">	if (envid == 0) &#123; </span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// We&apos;re the parent. </span><br><span class="line">	// share memory</span><br><span class="line">	for (addr = UTEXT; addr &lt; (unsigned)end; addr += PGSIZE)&#123;</span><br><span class="line">		// pte&apos;s low 12 bits,that means perm,</span><br><span class="line">		// however, in sys_page_map, no other bits may be set except PTE_SYSCALL</span><br><span class="line">		// #define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">		int perm = uvpt[PGNUM(addr)] &amp; PTE_SYSCALL;</span><br><span class="line">		if ((r = sys_page_map(0, (void *)addr, envid, (void *)addr, perm)) &lt; 0)&#123;</span><br><span class="line">			panic(&quot;sys_page_map: %e&quot;, r);</span><br><span class="line"> 		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	// map the stack we are currently running on, set copy-on-write.</span><br><span class="line">	duppage(envid, PGNUM(USTACKTOP - PGSIZE));   </span><br><span class="line"></span><br><span class="line">	if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P|PTE_U|PTE_W) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_page_alloc failed&quot;);</span><br><span class="line">	if (sys_env_set_pgfault_upcall(envid, (void*) _pgfault_upcall) &lt; 0)</span><br><span class="line">		panic(&quot;in fork, sys_env_set_pgfault_upcall failed&quot;);</span><br><span class="line"></span><br><span class="line">	// Start the child environment running</span><br><span class="line">	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0)</span><br><span class="line">		panic(&quot;sys_env_set_status: %e&quot;, r);</span><br><span class="line"> </span><br><span class="line">	return envid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! fork()使用了大量的系统调用接口。为了降低成本，扩展jos的系统调用接口，使之支持批量调用系统调用，并让fork使用该接口。可参考IA32的RDTSC指令。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h1 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h1><h2 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h2><p>user/spin程序中子进程一旦获取CPU将永远嵌入循环。为了保证内核能够抢占正在运行的进程，需要扩展内核以支持时钟硬件的外部硬件中断。</p>
<h2 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h2><p>外部中断被称为IRQs，共有16个，编号为0-15。IRQs到IDT表项的映射不是固定的，<code>picirq.c</code>的<code>pic_init</code>通过<code>IRQ_OFFSET</code>-<code>IRQ_OFFSET+15</code>将IRQs 0-15映射到IDT项中。在inc/trap.h，<code>IRQ_OFFSET</code>被定义为32，所以IDT的32-47项映射到IRQs 0-15。<br>在jos中，一个关键的简化是一旦处于内核模式就禁用了外部设备中断。外部中断由eflags的<code>FL_IF</code>位控制。虽然有多种方式可以修改该位，但由于jos的简化处理，我们仅需要在进入和退出用户模式的时候通过保存和恢复eflags寄存器来处理它即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 13. 修改kern/trapentry.S和kern/trap.c，初始化相关的IDT项，并提供IRQs 0-15的处理函数。然后修改kern/env.c的env_alloc()，在允许外部中断的情况下执行用户进程。当调用硬件中断处理函数的时候，处理器不会将错误码进栈，也不会检查IDT项的DPL。</span><br></pre></td></tr></table></figure></p>
<p>相关资料可查询 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/toc.htm" target="_blank" rel="noopener">section 9.2 of the 80386 Reference Manual</a> 或 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/IA32-3A.pdf" target="_blank" rel="noopener">section 5.8 of the IA-32 Intel Architecture Software Developer’s Manual, Volume 3</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// kern/trapentry.S</span><br><span class="line">// 处理器不会将错误码进栈</span><br><span class="line"># IRQs 0    </span><br><span class="line">TRAPHANDLER_NOEC(entry_point32,IRQ_OFFSET+IRQ_TIMER) </span><br><span class="line"># IRQs 1</span><br><span class="line">TRAPHANDLER_NOEC(entry_point33,IRQ_OFFSET+IRQ_KBD) </span><br><span class="line"># IRQs 4</span><br><span class="line">TRAPHANDLER_NOEC(entry_point36,IRQ_OFFSET+IRQ_SERIAL) </span><br><span class="line"># IRQs 7</span><br><span class="line">TRAPHANDLER_NOEC(entry_point39,IRQ_OFFSET+IRQ_SPURIOUS) </span><br><span class="line"># IRQs 14</span><br><span class="line">TRAPHANDLER_NOEC(entry_point46,IRQ_OFFSET+IRQ_IDE) </span><br><span class="line"></span><br><span class="line">// kern/trap.c, trap_init()</span><br><span class="line">for (i = 0; i &lt; 16; ++i)&#123;</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET+i], 0, GD_KT, entry_points[IRQ_OFFSET+i], 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// kern/env.c, env_alloc()</span><br><span class="line">// 创建用户进程的时候设置允许中断标志，这样就可以在运行用户进程的时候通过中断来控制进程。</span><br><span class="line">	e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h2 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h2><p><code>lapic_init</code>和<code>pic_init</code>进行了时钟和中断的相关设置，以生成中断。需要对中断进行相关处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 14. 修改trap_dispatch()函数，在每次触发时间中断的时候调用sched_yield()函数切换执行其他进程。测试案例为user/spin。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// trap_dispatch() </span><br><span class="line">	switch(tf-&gt;tf_trapno) &#123;</span><br><span class="line">	... </span><br><span class="line">	// Handle clock interrupts. Don&apos;t forget to acknowledge the</span><br><span class="line">	// interrupt using lapic_eoi() before calling the scheduler!</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line"> 	case (IRQ_OFFSET + IRQ_TIMER):</span><br><span class="line"> 		lapic_eoi();</span><br><span class="line"> 		sched_yield();</span><br><span class="line">		break;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h2><p>进程隔离和进程通信是两个重要课题，Unix的管道模型是典型的进程通信例子。进程间有许多通信模型，jos将实现一种简单的IPC机制。</p>
<h2 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h2><p>jos实现的IPC机制是扩展系统调用接口<code>sys_ipc_recv</code>和<code>sys_ipc_try_send</code>，并实现库函数<code>ipc_recv</code>和<code>ipc_send</code>。jos的进程间通信信息包括两个部分：一个32位数和一个可选的页面映射。允许传递页面映射的做法一方面可以传递更多数据，一方面进程可以更方便地设置和安排内存共享。</p>
<h2 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h2><p>进程希望接收消息时，调用<code>sys_ipc_recv</code>。该系统调用取消进程的执行，直到接收到消息。如果一个进行在等待接收消息，任何进程都可以发消息给它，而不局限于特定进程或有父子关系的进程。因此，Part A的权限检查不适用于IPC，因为IPC的设计确保进程A发送消息给进程B不能导致进程B发生故障。<br>进程希望发送消息时，调用<code>sys_ipc_try_send</code>，并传递目标进程号和参数。如果目标进程调用了<code>sys_ipc_recv</code>并且还没收到消息，系统调用将递交消息并返回0，否则返回<code>-E_IPC_NOT_RECV</code>。<br>库函数<code>ipc_recv</code>主要负责调用<code>sys_ipc_recv</code>和查找接收到的信息中所需要的部分。<br>库函数<code>ipc_send</code>主要负责重复调用<code>sys_ipc_try_send</code>，直至发送成功。</p>
<h2 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h2><p>当进程携带<code>dstva</code>参数调用<code>sys_ipc_recv</code>时，表明它希望收到一个页映射。这样当发送者发送一个页时，接收者需要将<code>dstva</code>映射到自己的地址空间（如果原来已经有了页映射，则解除原来的映射）。<br>当进程携带<code>srcva</code>参数调用<code>sys_ipc_try_send</code>时，表明它希望将当前映射到<code>srcva</code>的页发送出去，权限是<code>perm</code>。发送成功后，发送者保持<code>srcva</code>的原有映射，接收者则有了新的页映射。从而达到共享页的目的。<br>如果发送者和接收者都没有指明要传递页，则没有页被传递。对于任何一个IPC，内核都会在接收者的Env结构体中的<code>env_ipc_perm</code>上设置接收页的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 15. 实现kern/syscall.c的sys_ipc_recv和sys_ipc_try_send。调用envid2env的时候将checkperm设为0，表示任何进程都可以发送IPC消息。实现lib/ipc.c的ipc_recv和ipc_send。测试案例为user/pingpong和user/primes。</span><br></pre></td></tr></table></figure></p>
<p>大体上的思路是：<code>ipc_send</code>负责调用<code>sys_ipc_try_send</code>，如果调用失败（如目标进程尚未准备好接收）则循环尝试，但为了不霸占资源，在循环体内调用<code>sys_yield</code>由内核选择进程的执行。目标进程尚未准备好接收的情况下尝试循环send，对其他返回的错误直接panic。原型为<code>void ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)</code>，表示发送参数val，并将映射到pg的物理页映射到目标进程地址空间上，权限设为perm。<br><code>sys_ipc_try_send</code>负责检查目标进程是否存在、目标进程是否准备好接收信息、目标进程是否要求接收页映射。如果目标进程要求接收页映射，则检查发送者提供的虚拟地址是否有效并页对齐、发送者提供的映射权限是否合理、发送者提供的虚拟地址是否有映射页、是否尝试将只读页映射为可写、是否尚有物理页可供接收者分配和映射，检查通过后将物理页映射到目标进程指定的虚拟地址上。最后设置目标进程env结构体相关参数，以说明由谁发送、接收的值是什么，更改目标进程接收信息标识为已接收，将目标进程设为可执行，解除其阻塞状态。原型为<code>static int sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</code>。<br><code>ipc_recv</code>负责调用<code>sys_ipc_recv</code>，原型为<code>int32_t ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)</code>，如果pg为空，代表接收者不希望接收页映射，否则表示希望发送者将页映射到pg上。调用<code>sys_ipc_recv</code>之后进程状态被更改为不可执行、阻塞，直至有进程发送消息给它并将其状态更改为可执行。接收到消息之后，存储发送者进程id以及映射权限，然后返回接收到的32位的ipc值。<br><code>sys_ipc_recv</code>负责将给定的虚拟地址设置到env结构体的<code>env_ipc_dstva</code>上，表示希望发送者将页映射到其上，然后更改接收信息标识为等待接收，并更改进程的运行状态为不可执行。该系统调用将不会返回到用户模式，直至有发送者发送消息给它并解除其阻塞状态。</p>
<p>如果接收者要求接收页映射而发送者没有发送页映射，则出错；如果接收者不要求接收页映射而发送者发送页映射，不会出错。<br>接收者期望映射的虚拟地址不必与发送者发送的虚拟地址一致。<br>无需指定<code>ipc_recv</code>和<code>ipc_send</code>的先后调用顺序，因为即使接收者未准备好接收，发送者仍会判断<code>sys_ipc_recv</code>的返回结果，一旦是由于接收者未准备好接收而引起的错误，发送者会循环尝试发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;ipc_send not implemented&quot;); </span><br><span class="line">	int r; </span><br><span class="line">	if (!pg)&#123;</span><br><span class="line">		pg = (void *)IPC_NOPAGE;</span><br><span class="line">	&#125;</span><br><span class="line">	while((r = sys_ipc_try_send(to_env, val, pg, perm)))&#123; </span><br><span class="line">		if(r == 0)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r != -E_IPC_NOT_RECV)&#123;</span><br><span class="line">			panic(&quot;sys_ipc_try_send error, not -E_IPC_NOT_RECV, result: %d&quot;,r);</span><br><span class="line">		&#125;</span><br><span class="line">		sys_yield();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	// panic(&quot;sys_ipc_try_send not implemented&quot;);</span><br><span class="line">	struct Env *e; </span><br><span class="line">	int r = envid2env(envid,&amp;e, 0);</span><br><span class="line">	if(r&lt;0) return r;//-E_BAD_ENV </span><br><span class="line">	// target is not blocked, waiting for an IPC.</span><br><span class="line">	if(!e-&gt;env_ipc_recving) return -E_IPC_NOT_RECV;</span><br><span class="line">	// if receiver asking for one page</span><br><span class="line">	if ((uint32_t)e-&gt;env_ipc_dstva != IPC_NOPAGE &amp;&amp; (uint32_t)e-&gt;env_ipc_dstva &lt; UTOP) &#123; </span><br><span class="line">		// if srcva &lt; UTOP but srcva is not page-aligned.</span><br><span class="line">		if((uint32_t)srcva &gt;= UTOP || (uint32_t)srcva%PGSIZE != 0) return -E_INVAL;</span><br><span class="line">		// if srcva &lt; UTOP and perm is inappropriate</span><br><span class="line">		if((perm &amp; PTE_U) != PTE_U || (perm &amp; PTE_P) != PTE_P) return -E_INVAL;</span><br><span class="line">		//#define PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span><br><span class="line">		if ((perm &amp; ~PTE_SYSCALL) != 0) //no other bits may be set</span><br><span class="line">			return -E_INVAL;</span><br><span class="line">		// if srcva &lt; UTOP but srcva is not mapped in the caller&apos;s address space</span><br><span class="line">		pte_t *pte_store;</span><br><span class="line">		struct PageInfo *page = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte_store);</span><br><span class="line">		if(page == NULL) return -E_INVAL;//no page mapped at srcva </span><br><span class="line">		// if (perm &amp; PTE_W), but srcva is read-only in the current environment&apos;s address space</span><br><span class="line">		if((perm &amp; PTE_W) == PTE_W &amp;&amp; (*pte_store &amp; PTE_W) == 0) return -E_INVAL;</span><br><span class="line"></span><br><span class="line">		// if there&apos;s not enough memory to map srcva in envid&apos;s address space</span><br><span class="line">		// or if e-&gt;env_ipc_dstva invalid</span><br><span class="line">        r = page_insert(e-&gt;env_pgdir, page, e-&gt;env_ipc_dstva, perm);</span><br><span class="line">        if (r &lt; 0) return r;// -E_NO_MEM</span><br><span class="line">        e-&gt;env_ipc_perm = perm;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	e-&gt;env_ipc_perm = 0;</span><br><span class="line">    &#125; </span><br><span class="line">    e-&gt;env_ipc_recving = 0;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;ipc_recv not implemented&quot;); </span><br><span class="line">	if(!pg) pg = (void *)IPC_NOPAGE;</span><br><span class="line">	int r = sys_ipc_recv(pg);</span><br><span class="line">	if(r &lt; 0) return r;</span><br><span class="line">	if(from_env_store) *from_env_store = thisenv-&gt;env_ipc_from; </span><br><span class="line">	if(perm_store) *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">	return thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_ipc_recv(void *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 4: Your code here.</span><br><span class="line">	//panic(&quot;sys_ipc_recv not implemented&quot;);</span><br><span class="line">	// if dstva &lt; UTOP but dstva is not page-aligned.</span><br><span class="line">	if((uint32_t)dstva == IPC_NOPAGE)&#123;</span><br><span class="line">		curenv-&gt;env_ipc_dstva = (void*)IPC_NOPAGE; </span><br><span class="line">	&#125;else if((uint32_t)dstva &gt;= UTOP || (uint32_t)dstva%PGSIZE != 0) &#123;</span><br><span class="line">		return -E_INVAL;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = 1;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 为何ipc_send需要循环尝试发送?</span><br></pre></td></tr></table></figure>
<p>原因见上分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! prime sieve只是大量并发程序之间消息传递的一种灵巧应用。阅读 C. A. R. Hoare, ``Communicating Sequential Processes,&apos;&apos; Communications of the ACM 21(8) (August 1978), 666-667 ，实现矩阵乘法的例子。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! Doug McIlroy开发的幂级数计算器是典型的消息传递例子，阅读  M. Douglas McIlroy, ``Squinting at Power Series,&apos;&apos; Software--Practice and Experience, 20(7) (July 1990), 661-683 (http://plan9.bell-labs.com/who/rsc/thread/squint.pdf)，实现该计算器并计算sin(x+x^3)的幂级数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 阅读 Improving IPC by Kernel Design (http://dl.acm.org/citation.cfm?id=168633)，改进jos的IPC效率。可扩展系统调用接口。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记015-HW7-Locking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记015-HW7-Locking/" itemprop="url">笔记015 - HW7: Locking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:17:21+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin lock"></a>spin lock</h1><p>锁的错误实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct lock &#123; int locked; &#125;</span><br><span class="line">    acquire(lk) &#123;</span><br><span class="line">      while(1)&#123;</span><br><span class="line">        if(lk-&gt;locked == 0)&#123; // A</span><br><span class="line">          lk-&gt;locked = 1;    // B</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法存在问题，因为如果lk-&gt;locked为0时，第一个线程进入到if内，正打算执行lk-&gt;locked = 1，这时发生了一个时钟中断，切换到第二个线程。对于第二个线程，这时lk-&gt;lock依旧为0，因此也会进入到if语句内。这是因为A和B不是原子操作造成的。</p>
<p>实现A和B为原子操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire(lk)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">      if(xchg(&amp;lk-&gt;locked, 1) == 0)&#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>xchg是两个寄存器之间，或寄存器和内存变量之间内容的交换指令（两个操作数不能同时为内存变量。）。xv6的xchg函数是借助xchg指令完成以下工作：<br>假如lk-&gt;locked已经是1，xchg再次设置lk-&gt;locked为1并且返回1，循环继续；<br>假如lk-&gt;locked是0，至多只有一次xchg会遇到0它将设置lk-&gt;locked为1并且返回0，跳出循环，其他的xchgs将会返回1，继续循环。</p>
<p>这就是xv6的自旋锁。</p>
<h1 id="使用锁的过程中关中断"><a href="#使用锁的过程中关中断" class="headerlink" title="使用锁的过程中关中断"></a>使用锁的过程中关中断</h1><p>使用xv6的自旋锁的过程中需要关中断。<br>以IDE驱动为例。ide.c/iderw维护着一个disk请求的队列，处理器会并发地将新请求加入到队列中。为了维护该驱动的队列和其他变量，iderw在操作过程中会请求idelock锁，并在操作完成时释放锁。另一方面，假如发生了中断，会调用ideintr函数。</p>
<p>acquire请求idelock锁的过程中会屏蔽中断，假如iderw调用了acquire保持了对idelock锁的持有，如果这时候发生了ide中断（比如在acquire之后我们尝试调用sti()开中断），则会调用中断处理函数ideintr，ideintr函数也需要调用acquire请求idelock锁，此时发现锁被其他程序持有，则会一直等待锁的释放。然而，iderw函数不会继续执行，因为中断处理函数ideintr不会返回。这就造成了死锁，所以使用xv6的自旋锁的过程中需要关中断。</p>
<p>另外，需要注意的是必须在执行xchg之前关中断，因为如果是在xchg之后关中断仍有可能出现：iderw在操作过程中会请求idelock锁，执行xchg之后关中断之前，就发生了中断，这样仍会导致死锁。</p>
<p>release将1、先释放锁，然后2、开中断。释放锁的过程就是使lk-&gt;locked = 0，但不能直接使用c语言赋值，因为其对应的指令可能不是原子操作，且处理器可能会对内存进行排序，导致开中断先于释放锁操作的执行，倘若此时又发生中断，将可能导致死锁。xv6使用以下指令保证释放锁是原子操作：<code>asm volatile(&quot;movl $0, %0&quot; : &quot;+m&quot; (lk-&gt;locked) : );</code>。</p>
<h1 id="避免使用递归锁"><a href="#避免使用递归锁" class="headerlink" title="避免使用递归锁"></a>避免使用递归锁</h1><p>递归锁是指在某个CPU上有了一次acquire锁操作，之后还允许在该CPU上的第二次acquire操作。避免递归锁是必要的，这是因为acquire锁的过程中可能是在维护某些数据结构，如果允许了递归锁，CPU可能暂停当前维护数据结构的程序，并切换执行另一段代码，假如该代码是以“被维护的数据结构是完整的”的前提进行工作，则可能发生错误。因此，一旦发现递归锁，则panic。所以，两次acquire(&amp;lk);会导致panic。</p>
<h1 id="ide-c-iderw开中断"><a href="#ide-c-iderw开中断" class="headerlink" title="ide.c/iderw开中断"></a>ide.c/iderw开中断</h1><p>假如在ide.c/iderw中acquire()之后添加sti()，并在release()之前添加cli()，将会出现两种panic情况。panic定义在console.c中，会以输出字符串在栈中的位置为基准，往回输出函数调用的eip值，根据这些eip值在kernel.asm查询，可以查看到函数的调用顺序，有以下两种情况：<br>情况1：<code>panic-&gt;acquire-&gt;ideintr-&gt;trap-&gt;iderw-&gt;bread-&gt;initlog-&gt;trapret</code>（由后往前输出）<br>该情况是在iderw的执行过程中发生了ide中断，最终导致递归锁的出现而发生panic。<br>情况2：<code>panic-&gt;sched-&gt;yield-&gt;trap-&gt;iderw-&gt;bread-&gt;readsb-&gt;iinit-&gt;trapret</code>（由后往前输出）<br>该情况是在iderw的执行过程中发生了时钟中断，调用了yield，yield请求yieldlock，然后调用sched，在sched中检测了cpu-&gt;ncli这个变量，因为这个cpu获得了两把锁，所以这个值是2，于是就panic了。</p>
<p>pcs存储的是eip值，通过getcallerpcs实现，getcallerpcs的参数v代表当前栈内的最后一个参数。我们知道，函数调用的时候栈的布局如下：<br><img src="/2017/08/20/笔记015-HW7-Locking/1.PNG" title="函数调用的时候栈的布局"><br>因此，ebp的位置是v的位置减去2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//see in spinlock.c</span><br><span class="line">// Record the current call stack in pcs[] by following the %ebp chain.</span><br><span class="line">void</span><br><span class="line">getcallerpcs(void *v, uint pcs[])</span><br><span class="line">&#123;</span><br><span class="line">  uint *ebp;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  ebp = (uint*)v - 2;</span><br><span class="line">  for(i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    if(ebp == 0 || ebp &lt; (uint*)KERNBASE || ebp == (uint*)0xffffffff)</span><br><span class="line">      break;</span><br><span class="line">    pcs[i] = ebp[1];     // saved %eip</span><br><span class="line">    ebp = (uint*)ebp[0]; // saved %ebp</span><br><span class="line">  &#125;</span><br><span class="line">  for(; i &lt; 10; i++)</span><br><span class="line">    pcs[i] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="file-c-filealloc开中断"><a href="#file-c-filealloc开中断" class="headerlink" title="file.c/filealloc开中断"></a>file.c/filealloc开中断</h1><p>假如在file.c/filealloc中acquire()之后添加sti()，并在每一个release()之前添加cli()，同时添加<code>#include &quot;x86.h&quot;</code>，却不会发生panic现象。原因是file_table_lock保护的临界区足够短，时钟中断还来不及触发。如果在该临界区中加一段长时间的while循环，就会panic。</p>
<h1 id="xv6-lock-implementation"><a href="#xv6-lock-implementation" class="headerlink" title="xv6 lock implementation"></a>xv6 lock implementation</h1><p>release()函数中，lk-&gt;pcs[0]和lk-&gt;cpu的清除工作必须在lk-&gt;locked置零前进行，这是因为如果在清除lk-&gt;locked之后清除，那么就会有一小段空隙，在这个空隙里调度到其他等待锁的程序，就会成功获得这个锁，然后设置lk-&gt;pcs[]和lk-&gt;cpu；此时再调度到原来的进程，原来的进程继续将lk-&gt;pcs[]和lk-&gt;cpu清除，就会导致出错。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>自旋锁与互斥量的区别：互斥量通过休眠使进程阻塞，不阻塞中断；自旋锁在获取锁之前一直处于忙等（自旋）状态，除了提供互斥机制以外，它们会阻塞中断（如果不阻塞中断，如果在获取自旋锁后发生中断，中断处理程序尝试获取同一个锁，并忙等待不返回）。  </p>
<p>自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。  </p>
<p>自旋锁常用场景：非抢占式内核，中断程序。  </p>
<p>非抢占式内核使用自旋锁而不是互斥量的原因：（这里讨论的自旋锁包括xchg互斥和关中断两个部分）中断程序要求快速响应，不能阻塞。如果内核使用互斥量的概念，则可能获取锁之后发生中断，从而导致中断程序阻塞等待锁释放的情况发生。   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记014-HW6-Threads-and-Locking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记014-HW6-Threads-and-Locking/" itemprop="url">笔记014 - HW6: Threads and Locking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:16:20+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>提供一个指针数组<code>struct entry *table[NBUCKET]</code>，启动多个thread按照<code>key % NBUCKET</code>的结果往指针数组的某一个项的链表插入entry。由于并发过程中没有进行锁控制，如果多个thread同时操作同一个链表，可能会导致某个线程插入失败，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t-A: calls insert() on bucket 1 (key = 6, 6 % NBUCKETS = 1)</span><br><span class="line">t-B: calls insert() on bucket 1 (key = 21, 21 % NBUCKETS = 1)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">t-A: executes e-&gt;next = n</span><br><span class="line">t-B: executes e-&gt;next = n</span><br><span class="line">t-A: executes *p = e</span><br><span class="line">t-B: executes *p = e</span><br></pre></td></tr></table></figure></p>
<p>t-A在执行e-&gt;next = n之后、执行*p = e之前，t-B执行了e-&gt;next = n，从而导致t-A没有成功插入。</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>可参考的函数使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">互斥锁的使用：</span><br><span class="line">pthread_mutex_t lock;     // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL);   // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);  // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);  // release lock</span><br></pre></td></tr></table></figure></p>
<p>在put函数中添加锁控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lock);  // acquire lock</span><br><span class="line"></span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line">  insert(key, value, &amp;table[i], table[i]);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;lock);  // release lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -O2 ph.c -pthread</span><br><span class="line">$ ./a.out 2</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记014-HW6-Threads-and-Locking/1.PNG" title="执行结果"> 
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">#define SOL</span><br><span class="line">#define NBUCKET 5</span><br><span class="line">#define NKEYS 100000</span><br><span class="line"></span><br><span class="line">struct entry &#123;</span><br><span class="line">  int key;</span><br><span class="line">  int value;</span><br><span class="line">  struct entry *next;</span><br><span class="line">&#125;;</span><br><span class="line">struct entry *table[NBUCKET];</span><br><span class="line">int keys[NKEYS];</span><br><span class="line">int nthread = 1;</span><br><span class="line">volatile int done;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t lock;     // declare a lock</span><br><span class="line"></span><br><span class="line">double</span><br><span class="line">now()</span><br><span class="line">&#123;</span><br><span class="line"> struct timeval tv;</span><br><span class="line"> gettimeofday(&amp;tv, 0);</span><br><span class="line"> return tv.tv_sec + tv.tv_usec / 1000000.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">print(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  struct entry *e;</span><br><span class="line">  for (i = 0; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    printf(&quot;%d: &quot;, i);</span><br><span class="line">    for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">      printf(&quot;%d &quot;, e-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void </span><br><span class="line">insert(int key, int value, struct entry **p, struct entry *n)</span><br><span class="line">&#123;</span><br><span class="line">  struct entry *e = malloc(sizeof(struct entry));</span><br><span class="line">  e-&gt;key = key;</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;next = n;</span><br><span class="line">  *p = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lock);  // acquire lock</span><br><span class="line"></span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line">  insert(key, value, &amp;table[i], table[i]);</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;lock);  // release lock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct entry*</span><br><span class="line">get(int key)</span><br><span class="line">&#123;</span><br><span class="line">  struct entry *e = 0;</span><br><span class="line">  for (e = table[key % NBUCKET]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">    if (e-&gt;key == key) break;</span><br><span class="line">  &#125;</span><br><span class="line">  return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">thread(void *xa)</span><br><span class="line">&#123;</span><br><span class="line">  long n = (long) xa;</span><br><span class="line">  int i;</span><br><span class="line">  int b = NKEYS/nthread;</span><br><span class="line">  int k = 0;</span><br><span class="line">  double t1, t0;</span><br><span class="line"></span><br><span class="line">  //  printf(&quot;b = %d\n&quot;, b);</span><br><span class="line">  t0 = now();</span><br><span class="line">  for (i = 0; i &lt; b; i++) &#123;</span><br><span class="line">    // printf(&quot;%d: put %d\n&quot;, n, b*n+i);</span><br><span class="line">    put(keys[b*n + i], n);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line">  printf(&quot;%ld: put time = %f\n&quot;, n, t1-t0);</span><br><span class="line"></span><br><span class="line">  // Should use pthread_barrier, but MacOS doesn&apos;t support it ...</span><br><span class="line">  __sync_fetch_and_add(&amp;done, 1);</span><br><span class="line">  while (done &lt; nthread) ;</span><br><span class="line"></span><br><span class="line">  t0 = now();</span><br><span class="line">  for (i = 0; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    struct entry *e = get(keys[i]);</span><br><span class="line">    if (e == 0) k++;</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line">  printf(&quot;%ld: lookup time = %f\n&quot;, n, t1-t0);</span><br><span class="line">  printf(&quot;%ld: %d keys missing\n&quot;, n, k);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_init(&amp;lock, NULL);   // initialize the lock</span><br><span class="line"></span><br><span class="line">  pthread_t *tha;</span><br><span class="line">  void *value;</span><br><span class="line">  long i;</span><br><span class="line">  double t1, t0;</span><br><span class="line"></span><br><span class="line">  if (argc &lt; 2) &#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s nthread\n&quot;, argv[0], argv[0]);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  nthread = atoi(argv[1]);</span><br><span class="line">  tha = malloc(sizeof(pthread_t) * nthread);</span><br><span class="line">  srandom(0);</span><br><span class="line">  assert(NKEYS % nthread == 0);</span><br><span class="line">  for (i = 0; i &lt; NKEYS; i++) &#123;</span><br><span class="line">    keys[i] = random();</span><br><span class="line">  &#125;</span><br><span class="line">  t0 = now();</span><br><span class="line">  for(i = 0; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_create(&amp;tha[i], NULL, thread, (void *) i) == 0);</span><br><span class="line">  &#125;</span><br><span class="line">  for(i = 0; i &lt; nthread; i++) &#123;</span><br><span class="line">    assert(pthread_join(tha[i], &amp;value) == 0);</span><br><span class="line">  &#125;</span><br><span class="line">  t1 = now();</span><br><span class="line">  printf(&quot;completion time = %f\n&quot;, t1-t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记013-HW5-xv6-CPU-alarm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记013-HW5-xv6-CPU-alarm/" itemprop="url">笔记013 - HW5: xv6 CPU alarm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:15:52+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>添加一个alarm(interval, handler)系统调用，表示每过interval ticks个CPU time，内核将会调用handler函数。之后，程序将会在调用alarm系统调用的地方恢复执行。<br>alarmtest.c示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;types.h&quot;</span><br><span class="line">#include &quot;stat.h&quot;</span><br><span class="line">#include &quot;user.h&quot;</span><br><span class="line"></span><br><span class="line">void periodic();</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  printf(1, &quot;alarmtest starting\n&quot;);</span><br><span class="line">  alarm(10, periodic);</span><br><span class="line">  for(i = 0; i &lt; 50*500000; i++)&#123;</span><br><span class="line">    if((i++ % 500000) == 0)</span><br><span class="line">      write(2, &quot;.&quot;, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">  printf(1, &quot;alarm!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>alarm对应的系统调用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">sys_alarm(void)</span><br><span class="line">&#123;</span><br><span class="line">   int ticks;</span><br><span class="line">   void (*handler)();</span><br><span class="line"></span><br><span class="line">   if(argint(0, &amp;ticks) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">   if(argptr(1, (char**)&amp;handler, 1) &lt; 0)</span><br><span class="line">      return -1;</span><br><span class="line">    proc-&gt;alarmticks = ticks;</span><br><span class="line">    proc-&gt;alarmhandler = handler;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果类似于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ alarmtest</span><br><span class="line">alarmtest starting</span><br><span class="line">.....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">......alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">....alarm!</span><br><span class="line">......alarm!</span><br><span class="line">.....alarm!</span><br><span class="line">...alarm!</span><br><span class="line">...$</span><br></pre></td></tr></table></figure></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>参考其他系统调用如uptime的实现，查看alarm系统调用需要声明的位置：<br><img src="/2017/08/20/笔记013-HW5-xv6-CPU-alarm/1.PNG" title="alarm系统调用需要声明的位置"><br>alarmtest处理为可执行用户程序，在Makefile中添加：<br><img src="/2017/08/20/笔记013-HW5-xv6-CPU-alarm/2.PNG" title="alarmtest处理为可执行用户程序"></p>
<p>注意点：<br>1、proc-&gt;alarmticks记录用户程序指定的CPU time间隔，proc-&gt;alarmhandler记录内核将会调用的函数入口地址。此外还需要proc-&gt;alarmticked记录是否达到指定的CPU time间隔个数。这三个添加到proc中，见proc.h。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Per-process state</span><br><span class="line">struct proc &#123;</span><br><span class="line">  uint sz;                     // Size of process memory (bytes)</span><br><span class="line">  pde_t* pgdir;                // Page table</span><br><span class="line">  char *kstack;                // Bottom of kernel stack for this process</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  int pid;                     // Process ID</span><br><span class="line">  struct proc *parent;         // Parent process</span><br><span class="line">  struct trapframe *tf;        // Trap frame for current syscall</span><br><span class="line">  struct context *context;     // swtch() here to run process</span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line"></span><br><span class="line">  //add by jianzzz, for alarm...</span><br><span class="line">  int alarmticks;</span><br><span class="line">  int alarmticked;</span><br><span class="line">  void (*alarmhandler)();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在allocproc中初始化，见proc.h。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在进程表中寻找slot，成功的话更改进程状态embryo和pid，并初始化进程的内核栈</span><br><span class="line">static struct proc*</span><br><span class="line">allocproc(void)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">found:</span><br><span class="line">  ...</span><br><span class="line">  //add by jianzzz,for alarm</span><br><span class="line">  p-&gt;alarmticks = 0;</span><br><span class="line">  p-&gt;alarmticked = 0;</span><br><span class="line">  p-&gt;alarmhandler = 0;</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、每过一个tick的CPU time，硬件clock将会触发一个中断，并在trap()的<code>case T_IRQ0 + IRQ_TIMER</code>下被处理。同时，需要注意我们只在有用户程序被执行并且alarm中断来自用户态的情况下才对alarm中断进行处理。<br>3、需要保证当alarm中断函数执行完之后，成功返回并恢复执行用户程序。<br>4、可以通过<code>make CPUS=1 qemu</code>通知qemu只使用一个CPU。</p>
<p>实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//see in trap.c</span><br><span class="line">void</span><br><span class="line">trap(struct trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  switch(tf-&gt;trapno)&#123;</span><br><span class="line">  case T_IRQ0 + IRQ_TIMER:</span><br><span class="line">    if(cpunum() == 0)&#123;</span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      ticks++;</span><br><span class="line">      wakeup(&amp;ticks);</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    lapiceoi();</span><br><span class="line"></span><br><span class="line">    if(proc &amp;&amp; (tf-&gt;cs &amp; 3) == 3)&#123; </span><br><span class="line">      //(*proc-&gt;alarmhandler)();  </span><br><span class="line">      proc-&gt;alarmticked += 1;</span><br><span class="line">      if(proc-&gt;alarmticked == proc-&gt;alarmticks) &#123;</span><br><span class="line">        proc-&gt;alarmticked = 0;</span><br><span class="line">        tf-&gt;esp -= 4;</span><br><span class="line">        *(uint *) tf-&gt;esp = tf-&gt;eip;</span><br><span class="line">        tf-&gt;eip = (uint) proc-&gt;alarmhandler;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    break;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>1、如果直接执行在<code>case T_IRQ0 + IRQ_TIMER</code>执行<code>(*proc-&gt;alarmhandler)();</code>会怎样？<br>结果应该是可以调用到handler但是结果是错误的。可以调用到handler是因为：xv6将内核空间映射到了用户进程的页目录中（见vm.c setupkvm()），而在用户进程调用系统调用并由用户态切换到内核态并执行系统调用的时候，一直使用的是用户进程的页目录（<code>需要确定执行用户进程过程中发生中断是否也一直使用用户进程的页目录！</code>），因此中断发生的时候，alarm(interval, handler)指定的用户函数handler对内核是可见的。调用结果是错误的是因为：由alarmtest.c可以看出用户函数handler会调用printf函数，printf函数会调用write系统调用。在内核态下处理中断时，使用的是进程的内核栈，内核调用write是不会切换栈的，此刻write的参数放到内核栈中而不是用户栈中；但是write的系统函数<code>sys_write</code>会从tf-&gt;esp所指向的用户栈来获取参数，从而无法访问正确的栈。<br>换句话说，handler应该是在用户态而不是在内核态下被执行。</p>
<p>2、如何确保能成功执行handler，并返回用户程序？<br>发生中断时，触发中断的指令的下一条指令位置会被记录，对应于tf-&gt;eip。tf-&gt;esp指向用户栈空间。因此，将tf-&gt;esp指向的用户栈位置向低位移出一个空位，然后存储触发中断的指令的下一条指令位置，并将tf-&gt;eip指向handler入口。这样子会中断返回之后将根据tf-&gt;eip在用户态下执行handler，handler函数执行完毕后自动调用ret，从用户栈弹出值作为eip，该值就是触发中断的指令的下一条指令位置，从而返回用户程序。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/" itemprop="url">笔记012 - x86 v6 book | Chapter 3 Traps, interrupts, and drivers</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:15:17+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Systems-calls-exceptions-and-interrupts"><a href="#Systems-calls-exceptions-and-interrupts" class="headerlink" title="Systems calls, exceptions, and interrupts"></a>Systems calls, exceptions, and interrupts</h1><p>术语词：本章中trap和interrupt概念是可以互换的。但trap通常由当前在一个处理器上执行的程序所引起（例如当前程序调用系统调用并生成trap）；interrupt通常由设备引起，与当前执行程序没有关系。比如，磁盘可能在为某个程序检索完一个block之后生成interrupt，但interrupt生成的时候可能处理器正在执行其他程序。interrupt同其他活动可能是并发发生的，所以比trap的情况更复杂。尽管x86的官方术语是interrupt，xv6源码将所有情况都参考为trap，很大原因是因为PDP11/40使用了这个术语，这也是传统的Unix术语。</p>
<h1 id="X86-protection"><a href="#X86-protection" class="headerlink" title="X86 protection"></a>X86 protection</h1><p>xv6有4个保护级别，编号为0-3，0代表最高权限。实际上大多数OS只使用两个级别，0为内核模式，3为用户模式。xv6在执行指令的时候，当前特权级别保存在%cs中的CPL域。</p>
<p>IDT定义了xv6的中断处理程序，共有256项，处理相关中断的时候，IDT项给出了相应的%cs和%eip。</p>
<p>xv6通过int n的方式调用系统调用，n表示IDT的第n项，int指令包括以下步骤：<br>1、从IDT中找到第n个描述符，n是int指令的参数。<br>2、检查是否满足CPL &lt;= DPL，CPL在%cs中，DPL是描述符的特权级别。<br>3、如果目标段选择子的PL &lt; CPL，则将%esp和%ss保存到CPU的内部寄存器中。<br>4、从任务段描述符task segment descriptor中加载%esp和%ss。<br>5、Push %ss(old user’s)。<br>6、Push %esp(old user’s)。<br>7、Push %eflags。<br>8、Push %cs。<br>9、Push %eip。<br>10、清除%eflags的一些位。<br>11、设置%cs和%eip为IDT项给出的值。</p>
<p>int指令执行之后的内核栈变化：<br><img src="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/1.PNG" title="int指令执行之后的内核栈变化"></p>
<p>xv6使用Perl脚本生成IDT项指向的处理程序入口点entry point。如果处理器没有将错误码进栈，entry会将错误码进栈，之后中断号进栈，然后跳转到alltraps。</p>
<h1 id="Code-C-trap-handler"><a href="#Code-C-trap-handler" class="headerlink" title="Code: C trap handler"></a>Code: C trap handler</h1><p>假如引发的trap是<code>T_SYSCALL</code>，调用系统调用处理函数syscall。如果trap不是系统调用，也不是硬件设备关注的，xv6假设它是由不正确行为引起的。如果是由用户程序引起的trap，xv6会打印出相关细节信息，并设置cp-&gt;killed确保用户程序被清理。如果是由内核引起的trap，则是内核bug，xv6打印出细节信息之后调用panic。</p>
<h1 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h1><p>参考之前的博客中关于xv6系统调用的介绍。</p>
<h1 id="Code-Interrupts"><a href="#Code-Interrupts" class="headerlink" title="Code: Interrupts"></a>Code: Interrupts</h1><p>主板上的设备可以产生中断，CPU需要设置硬件来处理这些中断。<br>interrupt类似于系统调用，除了设备可以在任何时候生成interrupt。主板上的硬件在需要的时候会给CPU发送信号，因此必须给设备编程使之可以产生中断，且CPU可以接收该中断。</p>
<p>例子：timer设备和timer中断。<br>假设timer设备每秒产生100次中断，保证内核可以追踪时间的流逝并在多个执行进程间进行时间分片。  </p>
<p>xv6早期的主板有一个可编程中断控制器PIC，见picirq.c。<br><strong>PIC全称Programmable Interrupt Controller，通常是指Intel 8259A双片级联构成的最多支持15个interrupts的中断控制系统。</strong><br>而随着多处理器PC主板的出现，需要一种新方式来处理中断，因为每个CPU都需要一个中断控制器来处理发送给它的中断。同时，还需要一种将中断路由给CPU的方法，这种方法包括两部分，一部分位于I/O系统（the IO APIC, ioapic.c），一部分位于每个CPU（the local APIC, lapic.c）。xv6被设计为支持多处理器PC主板，需要编程每个处理器使之能接收到中断。<br><strong>APIC全称Advanced Programmable Interrupt Controller，APIC是为了多核平台而设计的。它由两个部分组成IOAPIC和LAPIC，其中IOAPIC通常位于南桥中用于处理桥上的设备所产生的各种中断，LAPIC则是每个CPU都会有一个。IOAPIC通过APICBUS(现在都是通过FSB/QPI)将中断信息分派给每颗CPU的LAPIC，CPU上的LAPIC能够智能的决定是否接受系统总线上传递过来的中断信息，而且它还可以处理Local端中断的pending、nesting、masking，以及IOAPIC于Local CPU的交互处理。</strong></p>
<p>为了能在单处理器机上正确运行，xv6对PIC进行编程。每个PIC最多可以处理8个设备中断，并在处理器的中断引脚上多路传输。为了能够支持多于8个设备，主板上通常级联至少两个PIC。xv6使用inb和outb指令规划master生成IRQ0-7，slave生成IRQ8-15。初始化PIC阶段屏蔽所有中断。timer.c设置定时器并使之在PIC上生效。<br><strong>基于Intel 80x86的PC使用两片8259A级联的方式组成了可以管理15级中断向量的一个中断系统，下图是它的一个连接示意图。在每台电脑的系统中，是由一个中断控制器8259或是8259A的芯片（现在此芯片大都集成到其它的芯片内）来控制系统中每个硬件的中断控制。目前共有16组IRQ，去掉其中用来作桥接的一组IRQ，实际上只有15组IRQ可供硬件调用。两片8259A，一片为Master，另一片为Slaver。其中Slaver的INT接到Master的IRQ2上。8259A有两种工作模式分别为编程和操作模式。BIOS初始化的时候会先通过IO port对8259A进行编程配置，在此之后8259A就可以响应来自外部设备的中断请求了。Master的IO address是0x20 0x21; Slaver的IO address是0xA0 0xA1。</strong><br><img src="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/2.jpg" title="PIC级联"><br>这16组IRQ的主要用途如下表：<br><img src="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/3.PNG" title="IRQ的主要用途"></p>
<p>多处理器环境下，xv6必须编程IOAPIC和每个CPU的LAPIC。IOAPIC有一张表，处理器通过内存映射I/O来编程表中的项，而不是使用inb和outb指令。初始化过程中，xv6映射 interrupt 0到IRQ 0，以此类推，但禁用它们。特定设备将允许对应的中断，并告知该中断将路由给哪个处理器，例如xv6将keyboard中断路由到处理器0。LAPIC内嵌定时器芯片，所以每个处理器都可以单独接收定时器中断，xv6在lapicinit函数中使该芯片起作用。<br><strong>Intel APIC由一组中断输入信号，一个24*64bit的Programmable Redirection Table(PRT)，一组register和用于从APIC BUS(FSB/QPI)上传送APIC MSG的部件组成，当南桥的IO device通过IOAPIC的interrupt lines产生interrupt，IOAPIC将根据内部的PRT table格式化成中断请求信息，并将该信息发送给目标CPU的LAPIC，再由LAPIC通知CPU进行处理。下图是一个基于Intel APIC的连接示意图，如下图所示IOAPIC上有24个interrupt pin，每一个pin都对应一个RTE，所以针对每一个interrupt pin都可以单独设定它的mask，触发方式(level，edge trigger)，中断管脚的极性，传送方式，传送状态，目的地，中断向量等。</strong><br><img src="/2017/08/20/笔记012-x86-v6-book-Chapter-3-Traps-interrupts-and-drivers/4.jpg" title="基于Intel APIC的连接示意图"></p>
<p>处理器通过设置eflags的IF位可以控制是否接收中断，cli指令清除IF，禁用中断，sti指令置位IF，允许中断。xv6在启动主处理器和其他处理器过程中关中断，每个处理器的scheduler将开中断。为了控制某些代码片段不被中断，xv6在执行这些代码片段过程中禁用中断。</p>
<p>定时器中断对应中断向量32（xv6选择中断向量32来处理IRQ 0），在idtinit进行设置。定时器中断向量32和系统调用中断向量64的唯一区别是定时器中断向量32是由interrupt gate进行处理而不是trap gate。所以处理定时器中断的时候会清除IF以屏蔽其他中断。trap函数在处理一次定时器中断时，做了两个工作：增加时间ticks和调用wakeup函数。</p>
<h1 id="Drivers"><a href="#Drivers" class="headerlink" title="Drivers"></a>Drivers</h1><h1 id="Add-a-network-driver"><a href="#Add-a-network-driver" class="headerlink" title="Add a network driver"></a>Add a network driver</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记011-Lab3-User-Environments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记011-Lab3-User-Environments/" itemprop="url">笔记011 - Lab3: User Environments</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:14:27+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="The-UVPT"><a href="#The-UVPT" class="headerlink" title="The UVPT"></a>The UVPT</h1><p>x86将虚拟地址转换为物理地址：CR3指向页目录，PDX是页目录索引，PTX是二级页表索引。对于处理器而言，并没有页目录、页表、页的概念，相反它只负责计算：<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong><br>页目录是“特殊”的页表，假设我们在页目录中某一索引项V存储页目录本身的地址：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/1.png" title="x86将虚拟地址转换为物理地址"><br>当设计PDX=PTX=V时，则可以通过<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong>后可以获得页目录的某一项。在jos中，V=0x3BD，所以<strong>(0x3BD&lt;&lt;22)|(0x3BD&lt;&lt;12) = 0xef400000 = UVPD</strong>。当PDX=V而PTX!=V时，通过<strong>pd = lcr3(); pt = <em>(pd+4</em>PDX); page = <em>(pt+4</em>PTX);</strong>后将指向到某一个页表的某一项，即：所有PDX=V的虚拟页刚好是所有页表本身，在jos中，V=0x3BD，所以<strong>UVPT = (0x3BD&lt;&lt;22) = 0xef400000</strong>，从该地址起的4M虚拟地址空间映射了jos的所有页表。设计UVPT的意义即在于通过虚拟地址可以访问到页表，但其前提在于<strong>在页目录中索引项V存储页目录本身的地址</strong>。</p>
<h1 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h1><p>在本实验中，术语<strong>environment</strong>和<strong>process</strong>是可以互换的，两者都是允许运行程序的一个抽象。jos的<strong>environment</strong>和unix的<strong>process</strong>提供不同的接口，因此提供了不同的语义，jos更加强调<strong>environment</strong>而不是<strong>process</strong>。<br>关于environment，jos提供了三个全局变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//kern/env.c</span><br><span class="line">struct Env *envs = NULL;		// All environments</span><br><span class="line">struct Env *curenv = NULL;		// The current env</span><br><span class="line">static struct Env *env_free_list;	// Free environment list</span><br></pre></td></tr></table></figure></p>
<p>jos内核最多支持“同时”执行NENV（inc/env.h）个活跃环境，所有不活跃的Env数据结构保存在<code>env_free_list</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//inc/env.h</span><br><span class="line">struct Env &#123;</span><br><span class="line">	struct Trapframe env_tf;	// Saved registers</span><br><span class="line">	struct Env *env_link;		// Next free Env</span><br><span class="line">	envid_t env_id;			// Unique environment identifier</span><br><span class="line">	envid_t env_parent_id;		// env_id of this env&apos;s parent</span><br><span class="line">	enum EnvType env_type;		// Indicates special system environments</span><br><span class="line">	unsigned env_status;		// Status of the environment</span><br><span class="line">	uint32_t env_runs;		// Number of times environment has run</span><br><span class="line"></span><br><span class="line">	// Address space</span><br><span class="line">	pde_t *env_pgdir;		// Kernel virtual address of page dir</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>env_tf</code>：见inc/trap.h，当环境没被执行时（即当前执行内核代码或其他环境的代码），保存了环境的被保存的寄存器值。内核在从用户态切换到内核态的时候保存这些寄存器，确保环境可以被恢复执行。<br><code>env_link</code>：连接到下一个Env，该Env位于<code>env_free_list</code>上，<code>env_free_list</code>上指向第一个空闲的环境。<br><code>env_id</code>：当前使用Env数据结构的环境的唯一标识。当一个用户环境终止时，内核可以重新分配相同的Env数据结构给不同的环境，但是<code>env_id</code>不会相同。<br><code>env_parent_id</code>：创建本环境的父环境id，可用于构建“family tree”，进而安全控制哪个环境可以对其他哪些环境做什么任务。<br><code>env_type</code>：用于区分特殊的环境，大部分时候是<code>ENV_TYPE_USER</code>。<br><code>env_status</code>：以下几种值之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENV_FREE：表明Env数据结构不活跃，位于env_free_list中。</span><br><span class="line">ENV_RUNNABLE：表明Env数据结构所代表的环境正等待处理器执行。</span><br><span class="line">ENV_RUNNING：表明Env数据结构所代表的环境正被执行。</span><br><span class="line">ENV_NOT_RUNNABLE：表明Env数据结构所代表的环境是活跃的，但还不能执行，比如它正在等待其他环境的interprocess communication (IPC)。</span><br><span class="line">ENV_DYING：表明Env数据结构所代表的环境是一个zombie。下一次trap到内核的时候，zombie环境将被释放。</span><br></pre></td></tr></table></figure></p>
<p><code>env_pgdir</code>：保存了环境的页目录的内核虚拟地址。  </p>
<p><strong>与unix对比</strong>：jos的<strong>environment</strong>也包含了<strong>thread</strong>和<strong>address space</strong>两个概念，<strong>thread</strong>的定义主要是被保存的寄存器（<code>env_tf</code>），<strong>address space</strong>的定义主要是页目录和页表的指向（<code>env_pgdir</code>）。<br><strong>与xv6对比</strong>：jos的<strong>struct Env</strong>类似于xv6的<strong>proc</strong>，两者都保存了用户模式寄存器状态，但是jos的环境并没有自己的内核栈，因为jos一次只有一个环境是活跃的，所以只需要一个内核栈。</p>
<h2 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h2><p><code>i386_init()</code>函数之后，并没有进入循环，而是相应的对进程结构初始化和中断初始化，<code>i386_init()</code>函数最后会调用<code>env_run(&amp;envs[0])</code>；运行一个进程。一个进程的执行不能对内核（kernel）和其他进程产生干扰，当进程执行特权指令时，需要处理器产生中断，从用户态切换到内核态，完成任务后中断返回到用户态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 1.修改kern/pmap.c中mem_init()函数，分配并映射envs数组（NENV instances），参考pages数组的分配和映射。pages数组基址映射到UPAGES虚拟地址，envs数组基址映射到UENVS虚拟地址，两者的二级页表项权限都是用户只读，用户环境不能修改数组本身。顺利完成的话将通过check_kern_pgdir()检查。</span><br></pre></td></tr></table></figure></p>
<p>解决方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//pmap.c</span><br><span class="line">                                   ...</span><br><span class="line">	//////////////////////////////////////////////////////////////////////</span><br><span class="line">	// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	envs = (struct Env*)boot_alloc(NENV*sizeof(struct Env));</span><br><span class="line">	memset(envs,0,NENV*sizeof(struct Env)); </span><br><span class="line">                                   ...</span><br><span class="line">	//////////////////////////////////////////////////////////////////////</span><br><span class="line">	// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</span><br><span class="line">	// (ie. perm = PTE_U | PTE_P).</span><br><span class="line">	// Permissions:</span><br><span class="line">	//    - the new image at UENVS  -- kernel R, user R</span><br><span class="line">	//    - envs itself -- kernel RW, user NONE</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	boot_map_region(kern_pgdir,UENVS,PTSIZE,PADDR(envs),PTE_U | PTE_P);</span><br><span class="line">                                   ...</span><br></pre></td></tr></table></figure></p>
<p>这里注意到一个问题：pages和envs本身作为内核代码的数组，拥有自己的虚拟地址，且内核可对其进行读写。<code>boot_map_region</code>函数将两个数组分别映射到了UPAGES和UENVS起4M空间的虚拟地址，这相当于另外的映射镜像，其二级页表项权限被设为用户/内核可读，因此通过UPAGES和UENVS的虚拟地址去访问pages和envs的话，只能读不能写。<br>页面管理空间的布局情况如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/2.PNG" title="页面管理空间"></p>
<h2 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h2><p>由于还没实现文件系统，因此没办法从inode里读取程序内容，而是设置成由内核加载内嵌到内核的静态二进制镜像，且为ELF可执行格式，将嵌入到内核中的用户程序取出释放到相应链接器指定好的用户虚拟空间里。如果想了解二进制文件怎么连接进内核里，可以在build 内核之后查看kern/Makefrag、obj/kern/kernel.sym等文件。在JOS系统里面，采用和管理页相同的方式来管理进程，即用一个进程表来管理所有的进程，空闲的进程通过<code>env_link</code>相连接，用<code>env_free_list</code>指向空闲进程表的头节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exercise 2.在kern/env.c中完成以下函数：</span><br><span class="line">env_init()：初始化进程数据结构数组，将所有数据结构加到env_free_list上。调用env_init_percpu函数为特权级别0(内核)和特权级别3(用户)将段式硬件配以单独的段。</span><br><span class="line">env_setup_vm()：分配页目录，初始化进程的内核部分地址空间。</span><br><span class="line">region_alloc()：分配和映射物理空间。</span><br><span class="line">load_icode()：解析ELF二进制镜像，加载进新进程的地址空间。</span><br><span class="line">env_create()：通过env_alloc分配一个新进程，调用load_icode加载ELF二进制镜像。</span><br><span class="line">env_run()：在用户模式下执行新进程。</span><br></pre></td></tr></table></figure>
<p>进程的管理方法和页面的管理方法是相同的，都是用一组结构体的数组来管理，在这种管理的方式下，对于空闲进程的申请和添加，只需要用<code>env_free_list</code>这个参数就可以了。进程表的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	// Set up envs array</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	env_free_list = NULL;  </span><br><span class="line">    int i;  </span><br><span class="line">    for( i = NENV -1; i&gt;=0; i--)&#123;  </span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">        envs[i].env_id = 0;  </span><br><span class="line">        envs[i].env_link = env_free_list;  </span><br><span class="line">        env_free_list = &amp;envs[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">	// Per-CPU part of the initialization</span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个用户进程的建立:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//init.c</span><br><span class="line">ENV_CREATE(user_hello, ENV_TYPE_USER);</span><br><span class="line"></span><br><span class="line">//env.h</span><br><span class="line">#define ENV_PASTE3(x, y, z) x ## y ## z</span><br><span class="line"></span><br><span class="line">#define ENV_CREATE(x, type)						\</span><br><span class="line">	do &#123;								\</span><br><span class="line">		extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[];	\</span><br><span class="line">		env_create(ENV_PASTE3(_binary_obj_, x, _start),		\</span><br><span class="line">			   type);					\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_create(uint8_t *binary, enum EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	struct Env *newEnv;</span><br><span class="line">	//Allocates a new env </span><br><span class="line">	int i = env_alloc(&amp;newEnv,0);</span><br><span class="line">	if(i&lt;0) panic(&quot;env_create&quot;);</span><br><span class="line">	//loads the named elf binary into</span><br><span class="line">	load_icode(newEnv,binary);</span><br><span class="line">	//set env_type</span><br><span class="line">	newEnv-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>env_alloc</code>向进程表申请空闲的进程，在<code>env_alloc</code>的函数中，向进程表申请空闲的进程，对新申请的进程的struct Env(进程描述符)进行初始化，主要是对段寄存器的初始化。内核要开始的第一个用户进程不是通过中断等方法来进入到内核的，而是由内核直接载入的。对进程的进程描述符进行初始化，是为了模仿int x指令的作用，模拟第一个进程是通过中断进入了内核，在内核处理完了相应的操作之后，才返回用户态的。<strong>xv6的做法是也是类似载入程序内容后对进程的进程描述符进行初始化，不过它之后是通过int指令来中断，执行exec。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">int</span><br><span class="line">env_alloc(struct Env **newenv_store, envid_t parent_id)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t generation;</span><br><span class="line">	int r;</span><br><span class="line">	struct Env *e;</span><br><span class="line"></span><br><span class="line">	if (!(e = env_free_list))</span><br><span class="line">		return -E_NO_FREE_ENV;</span><br><span class="line"></span><br><span class="line">	// Allocate and set up the page directory for this environment.</span><br><span class="line">	if ((r = env_setup_vm(e)) &lt; 0)</span><br><span class="line">		return r;</span><br><span class="line"></span><br><span class="line">	//todo...?????????????????????</span><br><span class="line">	// Generate an env_id for this environment.</span><br><span class="line">	generation = (e-&gt;env_id + (1 &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - 1);</span><br><span class="line">	if (generation &lt;= 0)	// Don&apos;t create a negative env_id.</span><br><span class="line">		generation = 1 &lt;&lt; ENVGENSHIFT;</span><br><span class="line">	e-&gt;env_id = generation | (e - envs);</span><br><span class="line"> </span><br><span class="line">	// Set the basic status variables.</span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = 0;</span><br><span class="line"></span><br><span class="line">	// Clear out all the saved register state,</span><br><span class="line">	// to prevent the register values</span><br><span class="line">	// of a prior environment inhabiting this Env structure</span><br><span class="line">	// from &quot;leaking&quot; into our new environment.</span><br><span class="line">	memset(&amp;e-&gt;env_tf, 0, sizeof(e-&gt;env_tf)); //env_tf是Trapframe结构体，不是Trapframe结构体指针!</span><br><span class="line"> </span><br><span class="line">	// Set up appropriate initial values for the segment registers.</span><br><span class="line">	// GD_UD is the user data segment selector in the GDT, and</span><br><span class="line">	// GD_UT is the user text segment selector (see inc/memlayout.h).</span><br><span class="line">	// The low 2 bits of each segment register contains the</span><br><span class="line">	// Requestor Privilege Level (RPL); 3 means user mode.  When</span><br><span class="line">	// we switch privilege levels, the hardware does various</span><br><span class="line">	// checks involving the RPL and the Descriptor Privilege Level</span><br><span class="line">	// (DPL) stored in the descriptors themselves.</span><br><span class="line">	e-&gt;env_tf.tf_ds = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_es = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_ss = GD_UD | 3;</span><br><span class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">	e-&gt;env_tf.tf_cs = GD_UT | 3;</span><br><span class="line">	// You will set e-&gt;env_tf.tf_eip later.</span><br><span class="line"></span><br><span class="line">	// commit the allocation</span><br><span class="line">	env_free_list = e-&gt;env_link;</span><br><span class="line">	*newenv_store = e;</span><br><span class="line"> </span><br><span class="line">	cprintf(&quot;env_id, %x\n&quot;, e-&gt;env_id);</span><br><span class="line">	cprintf(&quot;[%08x] new env %08x\n&quot;, curenv ? curenv-&gt;env_id : 0, e-&gt;env_id);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>env_setup_vm</code>创建进程页目录。<strong>在xv6中，每个进程都有自己的内核栈，进程的trapframe也是存在内核栈中。但是jos中用户进程是使用同一个内核栈虚拟地址的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static int</span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	struct PageInfo *p = NULL;</span><br><span class="line"></span><br><span class="line">	// Allocate a page for the page directory</span><br><span class="line">	if (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		return -E_NO_MEM;</span><br><span class="line"> </span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	//在没有具体的映射之前，物理地址都是直接加上KERNBASE作为虚拟地址的!!!</span><br><span class="line">	//内核空间的变量的虚拟地址也是如此</span><br><span class="line">	e-&gt;env_pgdir = (pde_t *) page2kva(p); //pa + KERNBASE !!!!!!</span><br><span class="line">	p-&gt;pp_ref = 1;</span><br><span class="line">	//use kern_pgdir as a template</span><br><span class="line">	/*</span><br><span class="line">	由于每个用户进程都需要共享内核空间，所以对于用户进程而言，在UTOP以上的部分，和系统内核的空间是完全一样的。</span><br><span class="line">	因此在pgdir开始设置的时候，只需要在一级页表目录上，把共享部分的一级页表目录部分复制进用户进程的地址空间就可以了，</span><br><span class="line">	这样，就实现了页面的共享。因为一级页目录里面存储的是二级页表目录的物理地址，其直接映射到物理内存部分，</span><br><span class="line">	而共享的内核部分的二级页目录在前期的内核操作中，已经完成了映射，所以二级页目录是不需要初始化的。</span><br><span class="line">	简单来说，不需要映射二级页表的原因是，用户进程可以和内核共用这些二级页表。</span><br><span class="line"></span><br><span class="line">	UTOP以下部分清空: 注意4G虚拟地址空间是由低到高每4M按顺序映射到页目录的一项的，因此需要取出UTOP的PDX索引部分，将前PDX项清空。</span><br><span class="line">	*/</span><br><span class="line">	memcpy(e-&gt;env_pgdir,kern_pgdir,PGSIZE);</span><br><span class="line">	memset(e-&gt;env_pgdir,0,UTOP &gt;&gt; PTSHIFT);</span><br><span class="line"></span><br><span class="line">	// UVPT maps the env&apos;s own page table read-only.</span><br><span class="line">	// Permissions: kernel R, user R</span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>load_icode</code>将用户进程的文件载入内存。由于还没有实现文件系统，所以用户进程实际的存放的位置实际上是在内存中的，文件载入内存，实际上是内存之间的数据的复制而已。程序载入内存的时候，需要把pgdir设置为用户进程的页目录，这样，这些程序才会载入用户进程所属的地址空间，而且在载入的过程中，根据elf文件中程序头表中载入内存的va和memsz，还需要为用户空间申请新的地址映射，在这个过程中，会建立新的页表。加载完ELF文件之后，为进程再申请一页物理页作为用户栈，并映射到USTACKTOP - PGSIZE，之前tampframe的esp也指向了USTACKTOP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static void</span><br><span class="line">load_icode(struct Env *e, uint8_t *binary)</span><br><span class="line">&#123; </span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	struct Elf *elf = (struct Elf *)binary;</span><br><span class="line">	if (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(&quot;load_icode&quot;); </span><br><span class="line">	struct Proghdr *ph = (struct Proghdr *)(binary+elf-&gt;e_phoff);</span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; elf-&gt;e_phnum; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		if(ph-&gt;p_type != ELF_PROG_LOAD) &#123;//不可载入段  </span><br><span class="line">			ph++;</span><br><span class="line">		 	continue;</span><br><span class="line">		&#125;</span><br><span class="line">		//xv6分配用户空间是连续的, 给出起始地址va和结束地址，然后ROUNDUP(va)，根据结束地址分配了足够的页空间，</span><br><span class="line">		//va的值是结束地址，而不是当前空间顶端。读取下一段的时候，新的开始地址是上次结束地址, 新的结束地址是ph.vaddr + ph.memsz。 </span><br><span class="line">		//jos分配用户空间不是连续的,而是根据ph-&gt;p_va作为每次的开始地址，以p_memsz为长度进行页分配。</span><br><span class="line">		region_alloc(e,(void*)ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">		//read into env&apos;s memory , need env&apos;s pgdir</span><br><span class="line">		memcpy((char*)ph-&gt;p_va,(char*)(binary + ph-&gt;p_offset),ph-&gt;p_filesz);</span><br><span class="line">		ph++;</span><br><span class="line">	&#125;</span><br><span class="line">	// Now map one page for the program&apos;s initial stack</span><br><span class="line">	// at virtual address USTACKTOP - PGSIZE.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	region_alloc(e,(void*)USTACKTOP - PGSIZE,PGSIZE);</span><br><span class="line"></span><br><span class="line">	//todo...binary的数据位于内核空间的哪个节？</span><br><span class="line">	e-&gt;env_tf.tf_eip = elf-&gt;e_entry;  // main </span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到一个现象，加载程序分配用户空间时，<strong>在xv6中，分配的地址空间是连续的，进程的用户地址空间也是通过加载过程中分配的地址空间范围来决定。而在jos中，用户空间是不一定连续的，每次在加载段的时候，都是从新的段虚拟地址开始映射，不关心之前段的结束地址。jos中也没有设置进程的地址空间大小。因此，jos和xv6为进程分配物理空间的函数有些不同，xv6会记录上次分配的结束地址，而jos不会。</strong><code>region_alloc</code>为va申请物理空间，并且完成映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">static void</span><br><span class="line">region_alloc(struct Env *e, void *va, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	if(ROUNDUP((pte_t)va + len, PGSIZE) &gt;= KERNBASE)&#123; </span><br><span class="line">    	panic(&quot;region_alloc panic, out of memory1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int npages = (ROUNDUP((pte_t)va + len, PGSIZE) - ROUNDDOWN((pte_t)va, PGSIZE)) / PGSIZE;  </span><br><span class="line">	struct PageInfo *p = NULL; </span><br><span class="line">	int i=0;</span><br><span class="line">  	for(; i&lt;npages; i++)&#123;</span><br><span class="line">                //加上ALLOC_ZERO标志则物理页内容初始化为&apos;\0&apos;，如果这里没有初始化，则最好在分配物理页并且将内容拷贝进来后，将剩余的空间置0</span><br><span class="line">		if (!(p = page_alloc(ALLOC_ZERO)))&#123;</span><br><span class="line">			 panic(&quot;region_alloc panic, out of memory2&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//map, use page_insert</span><br><span class="line">		if(page_insert(e-&gt;env_pgdir,p,(void*)((pte_t)va+i*PGSIZE),PTE_U|PTE_W)!=0)&#123;</span><br><span class="line">			panic(&quot;region_alloc panic, out of memory3&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">  	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后<code>env_run</code>开始准备运行进程，先切换到用户进程的地址空间，然后调用<code>env_pop_tf</code>载入寄存器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//env.c</span><br><span class="line">void</span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	// Step 1: If this is a context switch (a new environment is running):</span><br><span class="line">	//	   1. Set the current environment (if any) back to</span><br><span class="line">	//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="line">	//	      what other states it can be in),</span><br><span class="line">	//	   2. Set &apos;curenv&apos; to the new environment,</span><br><span class="line">	//	   3. Set its status to ENV_RUNNING,</span><br><span class="line">	//	   4. Update its &apos;env_runs&apos; counter,</span><br><span class="line">	//	   5. Use lcr3() to switch to its address space.</span><br><span class="line">	// Step 2: Use env_pop_tf() to restore the environment&apos;s</span><br><span class="line">	//	   registers and drop into user mode in the</span><br><span class="line">	//	   environment. </span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	if(!e) panic(&quot;env_run panic&quot;); </span><br><span class="line">	if(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	&#125;	</span><br><span class="line">	curenv = e;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">	e-&gt;env_runs += 1;</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); </span><br><span class="line"></span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));//never return  </span><br><span class="line">	//panic(&quot;env_run not yet implemented&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  </span><br><span class="line">env_pop_tf(struct Trapframe *tf)  </span><br><span class="line">&#123;  </span><br><span class="line">    __asm __volatile(&quot;movl %0,%%esp\n&quot;  </span><br><span class="line">        &quot;\tpopal\n&quot;  </span><br><span class="line">        &quot;\tpopl %%es\n&quot;  </span><br><span class="line">        &quot;\tpopl %%ds\n&quot;  </span><br><span class="line">        &quot;\taddl $0x8,%%esp\n&quot; /* skip tf_trapno and tf_errcode */  </span><br><span class="line">        &quot;\tiret&quot;  </span><br><span class="line">        : : &quot;g&quot; (tf) : &quot;memory&quot;);  </span><br><span class="line">    panic(&quot;iret failed&quot;);  /* mostly to placate the compiler */  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>movl %0,%%esp</strong>，这里出现了占位符%0，通过后面的参数可以看到这里的占位符代表的意思是memory中的变量tf，即Trapframe的指针地址。iret之后发生特权级的改变(即由内核态转到了用户态)，所以iret总共会压出5个寄存器，依次是eip、cs、eflags、esp、ss，即iret会从栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器，然后弹出esp和ss寄存器的值，这些函数在<code>env_alloc()</code>以及<code>load_icode()</code>中都设置好了，其中EIP为用户程序入口地址，CS为用户程序代码段基地址。完成iret之后，eip就指向了程序的入口地址，cs也由内核态转向了用户态， esp也由内核栈转到了用户栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调试技巧：</span><br><span class="line">调用env_pop_tf后，将开始执行用户代码，并且不会返回。使用b *0x...在env_pop_tf处设置断点，然后单步调试直至执行用户代码。参考obj/user/hello.asm，在sys_cputs()中的int $0x30处设置断点，如果以上函数补充正确的话，运行至此的指令均不会出错。下面将对中断进行处理。</span><br></pre></td></tr></table></figure>
<h2 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h2><p>在没有实现系统调用之前，处理器一旦进入用户模式将没有办法返回。只有实现基本的异常和系统调用处理，才能使内核从用户模式代码中恢复内核对处理器的控制。另外，诸如异常、陷阱、中断、错误、中止（exception, trap, interrupt, fault, abort）等概念，在架构或操作系统中并没有标准意义，因此在一个特定的体系结构中如xv6，经常不考虑它们之间的细微差别。</p>
<h2 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h2><p>exceptions和interrupts都是“protected control transfers”（受保护控制转移）的，它们将导致处理器从用户态切换为内核态，但用户代码不会影响其他进程以及内核。在Intel的术语中，<strong>interrupt</strong>通常指由外部异步事件引起的受保护控制转移（外部是相对于处理器而言），如外部设备I/O活动的通知，<strong>exception</strong>通常指由当前执行代码同步引起的受保护控制转移，如除0或非法内存访问。<br>为了保护控制转移，处理器仅在一定的控制条件下允许进入内核。x86使用两种保护机制：<strong>1、中断描述符表IDT，2、任务状态段TSS。</strong><br><strong>中断描述符表interrupt descriptor table</strong>：x86允许多达256个不同的中断或异常的内核入口点，每一个都有不同的中断向量。一个向量是一个0到255之间的数字。IDT表设置在内核的私有内存中，CPU使用向量在IDT表中进行索引，找到入口点后，处理器将会加载对应的值到eip（instruction pointer register）中，该值指向处理异常的内核代码，同时加载对应的值到cs（code segment register）中，该值的0-1位表明了执行异常处理代码的特权级别。<strong>在jos中，所有异常都在内核模式下处理，特权级别为0。</strong><br><strong>任务状态段TSS</strong>：处理器需要在调用执行异常处理代码之前保存好旧寄存器的状态，保证异常处理完毕后能恢复用户代码的执行。当interrupt或trap导致从用户态到内核态的特权级别改变时，x86处理器还将切换到内核内存的栈。task state segment即TSS指定了段选择子（ss）和栈地址（esp）。处理器将在新的栈上push SS、ESP、EFLAGS、CS、EIP，和一个可选的error code，然后从中断描述符加载cs和ip，并设置esp和ss引用新的栈。TSS可以用于各种各样的目的，但jos只使用它来定义处理器从用户模式切换到内核模式后的内核栈。因为jos的内核模式在特权级别0上，所以处理器使用ESP0和SS0来定义进入内核模式的内核栈。<strong>不同于xv6的设计，jos只用一个内核栈地址，其栈顶被映射到KSTACKTOP上，而xv6的每一个进程都有对应的内核栈。</strong><br><strong>TSS描述的是一个task在执行中的状态信息，重在描述代码切换之间权限的转换，用于保护机制。Env对应的是一个用户进程的状态，主要用于保持用户进程的独立，这里的进程是一个抽象程度较高的概念，包括PCB(jos中 evns 数组就等价于 PCB 表)、地址空间等，不仅仅是一段用户程序代码。</strong><br>TSS结构如下所示：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/3.PNG" title="TSS结构"></p>
<h2 id="Exceptions-and-Interrupts-Example"><a href="#Exceptions-and-Interrupts-Example" class="headerlink" title="Exceptions and Interrupts Example"></a>Exceptions and Interrupts Example</h2><p>假设处理器正在执行用户进程代码，并遇到了一条尝试除以0的divide指令：<br>1、处理器切换到TSS指定的SS0和ESP0指向的栈，jos中分别是GD_KD和KSTACKTOP。<br>2、处理器将相关寄存器保存到内核栈，从KSTACKTOP开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>3、除0异常在x86上是中断向量0，处理器读取IDT表的第0项，根据该项描述的信息设置CS:EIP，指向处理函数。<br>4、处理函数获得控制权，开始处理异常，比如终止用户进程。</p>
<p>对于某些x86异常，处理器可能会将错误码进栈，比如页错误。布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20</span><br><span class="line">|     error code     |     &quot; - 24 &lt;---- ESP</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，将相关寄存器（和某些异常的错误码）保存到内核栈后，处理器才读取IDT表，寻找处理函数。</strong></p>
<h2 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h2><p>处理器可以处理来自内核或用户模式的中断和异常。只有由用户模式切换到内核模式的时候，处理器才会在保存旧寄存器之前自动切换栈，并根据IDT调用合适的处理函数。如果中断或异常发生的时候，处理器已经处于内核模式（<strong>CS的低2位为0</strong>），将只在原来的栈上保存数据。这种情况下处理器可以优雅地处理由内核代码本身引起的内嵌异常。这种能力也是实施保护的工具，详见后面系统调用。<br>如果处理器已经在内核模式中且需要处理一个内嵌的异常，因为不需要切换栈，处理器不保存旧SS或ESP寄存器。对于不会导致错误码进栈的异常，进入异常处理程序的时候内核栈的样子如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>对于需要将错误码进栈的异常，进入异常处理程序的时候内核栈的样子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">|     error code     |     &quot; - 16 </span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>假如处理器处于内核模式，且由于某些原因（如缺乏栈空间）导致无法保存处理器的旧状态，那么处理器将没有办法恢复原先状态。内核应该设计为不会发生这种情况。</p>
<p>JOS 系统中断过程的控制流如下所示：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/4.PNG" title="JOS 系统中断过程的控制流"></p>
<h2 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h2><p>kern/trap.h包含了内核专属的定义，inc/trap.h包含了用户级别的程序和库可用的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exercise 4: 在kern/trapentry.S中定义每个中断对应的中断处理程序，在kern/trap.c中根据定义好的中断处理程序初始化IDT。</span><br><span class="line">每个中断对应的中断处理程序实际上是在内核栈中设置好Trapframe的布局结构，然后将这个结构传递给trap()函数进行处理，最后在trap_dispatch()中进行具体中断处理程序的分发。</span><br></pre></td></tr></table></figure></p>
<p>关于中断处理程序的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */ </span><br><span class="line"> #define TRAPHANDLER(name, num)						\</span><br><span class="line"> 	.globl name;		/* define global symbol for &apos;name&apos; */	\</span><br><span class="line"> 	.type name, @function;	/* symbol type is function */		\</span><br><span class="line"> 	.align 2;		/* align function definition */		\</span><br><span class="line"> 	name:			/* function starts here */		\</span><br><span class="line"> 	pushl $(num);							\</span><br><span class="line"> 	jmp _alltraps</span><br><span class="line"></span><br><span class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</span><br><span class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="line"> * format in either case.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)					\</span><br><span class="line">	.globl name;							\</span><br><span class="line">	.type name, @function;						\</span><br><span class="line">	.align 2;							\</span><br><span class="line">	name:								\</span><br><span class="line">	pushl $0;							\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br></pre></td></tr></table></figure></p>
<p>这两个宏的功能是接受一个函数名和中断向量编号，定义出相应的以该函数名命名的中断处理程序，中断处理程序的执行流程是向栈里压入相关错误码和中断号，然后跳转到_alltraps把Trapframe剩下的部分在栈中设置好。对于某些中断，处理器将向栈中放入对应的中断错误码。当系统没有放入错误码的时候，中断处理函数则使用<code>TRAPHANDLER_NOEC</code>手动补齐。<code>当用户使用int指令手动调用中断时，处理器不会放入错误码。</code>具体的中断处理程序定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */  </span><br><span class="line">TRAPHANDLER_NOEC(entry_point0,T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point1,T_DEBUG) </span><br><span class="line">TRAPHANDLER_NOEC(entry_point2,T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point3,T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point4,T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point5,T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point6,T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point7,T_DEVICE)</span><br><span class="line">TRAPHANDLER(entry_point8,T_DBLFLT)</span><br><span class="line"># TRAPHANDLER(entry_point9,T_COPROC)</span><br><span class="line">TRAPHANDLER(entry_point10,T_TSS)</span><br><span class="line">TRAPHANDLER(entry_point11,T_SEGNP)</span><br><span class="line">TRAPHANDLER(entry_point12,T_STACK)</span><br><span class="line">TRAPHANDLER(entry_point13,T_GPFLT)</span><br><span class="line">TRAPHANDLER(entry_point14,T_PGFLT)</span><br><span class="line"># TRAPHANDLER(entry_point15,T_RES)</span><br><span class="line">TRAPHANDLER_NOEC(entry_point16,T_FPERR) </span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(entry_point48,T_SYSCALL) </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line"> .globl _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">  # Build trap frame. //将用户进程的寄存器保存</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es </span><br><span class="line">  pushal</span><br><span class="line">  //load GD_KD into %ds and %es</span><br><span class="line">  movw $(GD_KD), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es </span><br><span class="line">  pushl %esp</span><br><span class="line">  call trap</span><br><span class="line"></span><br><span class="line"># entry point table</span><br><span class="line">.data</span><br><span class="line">.globl entry_points</span><br><span class="line">entry_points:</span><br><span class="line">  .long entry_point0</span><br><span class="line">  .long entry_point1</span><br><span class="line">  .long entry_point2</span><br><span class="line">  .long entry_point3</span><br><span class="line">  .long entry_point4</span><br><span class="line">  .long entry_point5</span><br><span class="line">  .long entry_point6</span><br><span class="line">  .long entry_point7</span><br><span class="line">  .long entry_point8</span><br><span class="line">#  .long entry_point9</span><br><span class="line">  .long 0   #attendion: instead we should fill the hole with 0, or it will cause entry_points array&apos;s wrong index</span><br><span class="line">  .long entry_point10</span><br><span class="line">  .long entry_point11</span><br><span class="line">  .long entry_point12</span><br><span class="line">  .long entry_point13</span><br><span class="line">  .long entry_point14</span><br><span class="line">#  .long entry_point15</span><br><span class="line">  .long 0   #attendion: instead we should fill the hole with 0, or it will cause entry_points array&apos;s wrong index</span><br><span class="line">  .long entry_point16</span><br><span class="line">  .long 0   </span><br><span class="line">...</span><br><span class="line">  .long entry_point48</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>为了方便，将中断处理程序函数名定义到函数名数组<code>entry_points</code>中。之后初始化IDT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c</span><br><span class="line">void</span><br><span class="line">trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	extern struct Segdesc gdt[];</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	/*</span><br><span class="line">	 * add by jianzzz</span><br><span class="line">	 */</span><br><span class="line">	//entry_points store handler-function&apos;s address</span><br><span class="line">	extern uint32_t entry_points[]; //see in trapentry.S</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; 16; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		if (i==T_BRKPT)</span><br><span class="line">			SETGATE(idt[i], 0, GD_KT, entry_points[i], 3)</span><br><span class="line">		else if(i!=9 &amp;&amp; i!=15)</span><br><span class="line">			SETGATE(idt[i],0,GD_KT,entry_points[i],0);//todo...why GD_KT???  </span><br><span class="line">	&#125; </span><br><span class="line">	SETGATE(idt[T_SYSCALL],0,GD_KT,entry_points[T_SYSCALL],3); </span><br><span class="line">	// Per-CPU setup </span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SETGATE第三个参数cs设为内核的代码段<code>GD_KT</code>。最后一个参数是用户特权级。到此为止，就完成了中断响应机制的建立。<br>中断处理过程图示如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/5.PNG" title="中断处理过程"><br>中断门格式如下：<br><img src="/2017/08/20/笔记011-Lab3-User-Environments/6.PNG" title="中断门"><br>其结构 struct Gatedesc 是在 inc/mmu.h 中定义的。由其结构可知，中断或异常也有特权级别，由中断门描述符中的 DPL 约束，门描述符中的段选择子中的 CPL 说明中断处理程序运行的特权级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Questions:</span><br><span class="line">1、为什么需要设计为每一个中断/异常都有单独的中断处理程序？如果所有的中断/异常都传递到相同的处理程序，会丢失什么特性？（这里指的中断处理程序是指跳转到_alltraps之前的处理过程）</span><br><span class="line">中断处理程序在真正的处理之前会将中断号放入内核栈以组织成Trapframe的结构，如果所有的中断/异常都跳到同一个处理程序，那么无法正确设置中断/异常的中断号等。</span><br><span class="line">2、user/softint程序的预想结果是抛出general protection fault (trap 13)，但程序代码是执行int $14，如果内核实际允许该程序执行int $14并调用页错误处理程序，会发生什么情况？</span><br><span class="line">中断向量14 Page fault的调用权限为0，只能由内核抛出，直接在softint中用int指令调用将会产生一般保护错误。</span><br></pre></td></tr></table></figure>
<h1 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h1><h2 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h2><p>当处理器遇到页错误时，会将导致页错误的线性地址保存到处理器控制寄存器CR2中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 5.修改trap_dispatch()，将页错误分发给page_fault_handler()处理。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123;</span><br><span class="line">	case (T_PGFLT):</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">		break;</span><br></pre></td></tr></table></figure>
<h2 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h2><p>中断向量3(<strong>T_BRKPT</strong>)断点异常通常是用于允许调试器通过用单字节的int3软件中断指令临时替换相关程序指令的方式在程序代码中插入断点。jos中我们将这个异常变成一个粗糙的系统调用，任何用户程序都可以调用它从而嵌入到jos内核监控，在这个角度上jos相当于一个粗糙的调试器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 6.修改trap_dispatch()，使得断点异常嵌入到内核监控程序。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_BRKPT):</span><br><span class="line">		//print_trapframe(tf);</span><br><span class="line">		monitor(tf);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">//see in kern/trap.c, trap_init() </span><br><span class="line">    if (i==T_BRKPT)</span><br><span class="line">        SETGATE(idt[i], 0, GD_KT, entry_points[i], 3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 熟悉EFLAGS，修改jos内核监控程序，当因为int3发生断点中断嵌入内核监控的时候，能够在当前位置执行“continue”操作和一次单步执行一条指令。</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://www.zhihu.com/question/40555332/answer/87130016?from=profile\_answer\_card" target="_blank" rel="noopener">https://www.zhihu.com/question/40555332/answer/87130016?from=profile\_answer\_card</a> ，一般情况下，在指令被执行前，断点指令会产生调试异常，如果异常处理程序在返回前没有移除断点的话，处理器在重启指令之前会再次发现断点，进而生成另一个调试异常。为了防止重复进入调试中断，Intel 64和IA-32架构使用RF标志控制处理器对指令断点的响应。RF置1则禁用断点指令产生调试异常，但是其它情况仍可以产生调试异常。RF置0则断点指令会产生调试异常。调试软件必须在用IRETD指令返回到被中断程序之前，将栈中的EFLAGES映象中的该位置为1，以阻止断点指令产生另外的调试异常。在返回并成功执行断点指令之后，处理器会自动清零该位，从而允许继续通过断点指令产生调试异常。<br>在jos中，情况有所不同。jos遇到断点指令后直接陷入了监控程序，而不会产生调试异常，因此跟RF没有什么关系。为了能够单步调试，需要EFLAGS的TF(Trap Flag)跟踪标志，置1则开启单步执行调试模式，置0则关闭。在单步执行模式下，处理器在每条指令后产生一个调试异常，这样在每条指令执行后都可以查看执行程序的状态。当然，为了达到观察每次调试结果，我们也同样需要将调试异常嵌入内核监控。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trap.c, trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_DEBUG):</span><br><span class="line">		//print_trapframe(tf);</span><br><span class="line">		monitor(tf);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">//see in kern/monitor.c</span><br><span class="line">int mon_continue(int argc,char **argv,struct Trapframe *tf)&#123; </span><br><span class="line">	uint32_t eflags;</span><br><span class="line">	if(tf==NULL)&#123; </span><br><span class="line">		cprintf(&quot;No trapped environment\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	eflags=tf-&gt;tf_eflags; </span><br><span class="line">	eflags &amp;= ~FL_TF; </span><br><span class="line">	tf-&gt;tf_eflags=eflags; </span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mon_step(int argc,char **argv,struct Trapframe *tf)&#123; </span><br><span class="line">	uint32_t eflags;</span><br><span class="line">	if(tf==NULL)&#123; </span><br><span class="line">		cprintf(&quot;No trapped environment\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	eflags=tf-&gt;tf_eflags;</span><br><span class="line">	eflags |= FL_TF; </span><br><span class="line">	tf-&gt;tf_eflags=eflags;  </span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设<code>mon_continue</code>对应的指令的continue，<code>mon_step</code>对应的指令是step。那么每次执行step的话，就相当于执行一次单步调试，这是因为：当我们执行int3时，eip记录了int3指令的下一条用户指令的位置，然后断点异常嵌入内核监控，此时如果输入step，内核会执行对应的<code>mon_step</code>函数，设置TF标志，然后返回-1；由于返回-1，内核会跳出监控程序返回用户程序，执行eip所指向的用户指令，记录下一条指令位置，然后发生调试异常嵌入内核监控，重复上述步骤即相当于每次执行一次单步调试。我们可以借助eip值和用户程序的asm文件查看每次执行的用户指令。如果输入continue会发生什么事呢：由于用户程序由lib/entry.S开始执行，然后调用lib/libmain.c中的libmain函数，可以看到最后libmain函数会调用exit，因此如果输入continue将会返回用户程序，最终触发一次系统调用并结束用户程序。</p>
<h2 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h2><p>jos的系统调用是通过int 0x30实现的。程序将会使用寄存器传递系统调用号和系统调用参数，这样就不需要在用户环境的栈或指令流中进行查找。系统调用号存在%eax中，系统调用参数存在%edx, %ecx, %ebx, %edi, %esi中，最多传递5个参数。<strong>xv6使用宏定义将用户调用转换为系统调用，并使用用户栈传递参数；不同于xv6，用户程序调用系统调用时，jos通过汇编指令同时完成参数传递和调用转换，见lib/syscall.c</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//see in lib/syscall.c</span><br><span class="line">//用户代码通过该接口进行系统调用</span><br><span class="line">static inline int32_t</span><br><span class="line">syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t ret;</span><br><span class="line"></span><br><span class="line">	// Generic system call: pass system call number in AX,</span><br><span class="line">	// up to five parameters in DX, CX, BX, DI, SI.</span><br><span class="line">	// Interrupt kernel with T_SYSCALL.</span><br><span class="line">	//</span><br><span class="line">	// The &quot;volatile&quot; tells the assembler not to optimize</span><br><span class="line">	// this instruction away just because we don&apos;t use the</span><br><span class="line">	// return value.</span><br><span class="line">	//</span><br><span class="line">	// The last clause tells the assembler that this can</span><br><span class="line">	// potentially change the condition codes and arbitrary</span><br><span class="line">	// memory locations.</span><br><span class="line"></span><br><span class="line">	asm volatile(&quot;int %1\n&quot;</span><br><span class="line">		: &quot;=a&quot; (ret)</span><br><span class="line">		: &quot;i&quot; (T_SYSCALL),</span><br><span class="line">		  &quot;a&quot; (num),</span><br><span class="line">		  &quot;d&quot; (a1),</span><br><span class="line">		  &quot;c&quot; (a2),</span><br><span class="line">		  &quot;b&quot; (a3),</span><br><span class="line">		  &quot;D&quot; (a4),</span><br><span class="line">		  &quot;S&quot; (a5)</span><br><span class="line">		: &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line"></span><br><span class="line">	if(check &amp;&amp; ret &gt; 0)</span><br><span class="line">		panic(&quot;syscall %d returned %d (&gt; 0)&quot;, num, ret);</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exercise 7.为系统调用添加处理程序，包括：</span><br><span class="line">1、kern/trapentry.S定义“预先”处理程序。</span><br><span class="line">2、kern/trap.c的trap_init()函数初始化idt表。</span><br><span class="line">3、trap_dispatch()调用syscall()，执行系统调用。</span><br><span class="line">4、实现kern/syscall.c的syscall()。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//see in kern/trapentry.S</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)				\</span><br><span class="line">	.globl name;						\</span><br><span class="line">	.type name, @function;					\</span><br><span class="line">	.align 2;						\</span><br><span class="line">	name:							\</span><br><span class="line">	pushl $0;						\</span><br><span class="line">	pushl $(num);						\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">TRAPHANDLER_NOEC(entry_point48,T_SYSCALL) </span><br><span class="line"></span><br><span class="line">//see in kern/trap.c, trap_init()</span><br><span class="line">SETGATE(idt[T_SYSCALL],0,GD_KT,entry_points[T_SYSCALL],3); </span><br><span class="line"></span><br><span class="line">//see in kern/trap.c,trap_dispatch()</span><br><span class="line">switch(tf-&gt;tf_trapno) &#123; </span><br><span class="line">	case (T_SYSCALL):</span><br><span class="line">		ret_code = syscall(</span><br><span class="line">			tf-&gt;tf_regs.reg_eax,</span><br><span class="line">			tf-&gt;tf_regs.reg_edx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">			tf-&gt;tf_regs.reg_edi,</span><br><span class="line">			tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = ret_code;//attention</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">/see in kern/syscall.c, syscall()</span><br><span class="line">int32_t</span><br><span class="line">syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</span><br><span class="line">&#123;</span><br><span class="line">	// Call the function corresponding to the &apos;syscallno&apos; parameter.</span><br><span class="line">	// Return any appropriate return value.</span><br><span class="line">	// LAB 3: Your code here. </span><br><span class="line">	//panic(&quot;syscall not implemented&quot;);</span><br><span class="line"></span><br><span class="line">	switch (syscallno) &#123;</span><br><span class="line">	case SYS_cputs:&#123;</span><br><span class="line">		sys_cputs((char *)a1,a2); //refer to lib/syscall.c</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_cgetc:&#123;</span><br><span class="line">		return sys_cgetc();</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_getenvid:&#123;</span><br><span class="line">		return sys_getenvid();</span><br><span class="line">	&#125;</span><br><span class="line">	case SYS_env_destroy:&#123;</span><br><span class="line">		return sys_env_destroy(a1);</span><br><span class="line">	&#125;</span><br><span class="line">	case NSYSCALLS:</span><br><span class="line">	default:</span><br><span class="line">		return -E_NO_SYS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Challenge! 使用sysenter和sysexit指令代替int 0x30和iret指令来实现系统调用。sysenter/sysexit的速度快于int/iret，因为使用了寄存器而不是栈。jos中可以这样实现：在kern/trapentry.S中添加sysenter_handler，用以保存返回用户程序的信息、设置内核环境、将syscall()参数进栈，然后直接调用syscall()。syscall()返回时，设置好返回信息后执行sysexit指令。同时，在kern/init.c设置model specific registers (MSRs)，可参考Section 6.1.2 in Volume 2 of the AMD Architecture Programmer&apos;s Manual和the reference on SYSENTER in Volume 2B of the Intel reference manuals。最后，lib/syscall.c必须支持sysenter指令。</span><br><span class="line">使用sysenter时，寄存器的布局可能是：</span><br><span class="line">	eax                - syscall number</span><br><span class="line">	edx, ecx, ebx, edi - arg1, arg2, arg3, arg4</span><br><span class="line">	esi                - return pc</span><br><span class="line">	ebp                - return esp</span><br><span class="line">	esp                - trashed by sysenter</span><br><span class="line">GCC的内联汇编程序将在被直接告知加载值的时候自动保存寄存器。内联汇编程序不支持保存%ebp，需要添加代码来保存和恢复。返回地址可以通过使用类似于leal after_sysenter_label, %%esi的指令存在%esi中。</span><br><span class="line">注意到这个方法最多支持4个参数，不同于原来可支持5个参数的方法。另外这个方法不更新当前进程的trapframe，不适合后续lab添加的一些system call。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">???</span><br></pre></td></tr></table></figure>
<h2 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h2><p>用户程序由lib/entry.S开始执行，经过一些设置之后调用lib/libmain.c中的libmain函数。libmain函数会调用umain，umain是用户程序的主函数入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 8. lib/entry.S已经定义envs指向UENVS，需要在libmain函数中初始化全局变量thisenv指向当前进程的struct Env结构，用户程序通过thisenv获取进程的相关信息。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//see in lib/libmain.c</span><br><span class="line">void</span><br><span class="line">libmain(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	// set thisenv to point at our Env structure in envs[].</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	thisenv = 0; </span><br><span class="line">	//envs see in inc/lib.h</span><br><span class="line">	thisenv = &amp;envs[ENVX(sys_getenvid())]; </span><br><span class="line">	</span><br><span class="line">	// save the name of the program so that panic() can use it</span><br><span class="line">	if (argc &gt; 0)</span><br><span class="line">		binaryname = argv[0];</span><br><span class="line"></span><br><span class="line">	// call user main routine</span><br><span class="line">	umain(argc, argv); //see in user/*.c</span><br><span class="line"></span><br><span class="line">	// exit gracefully</span><br><span class="line">	exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h2><p>操作系统通常依赖于硬件支持来实现内存保护。当程序试图访问一个无效的或者没有权限的地址，处理器停止导致故障的指令然后陷入到内核。如果故障是可以解决的，内核可以修复它并让程序继续运行。如果故障是不可以解决的，那么程序将不能继续执行，因为引起故障的指令永远不会被越过。<br>故障可以被解决的一个例子是：自动扩展栈。在许多系统中最初只分配了一页的栈空间。当程序错误访问到栈地址时（further down the stack），内核自动分配这些页并且恢复程序执行。基于此，内核按需分配栈空间，但是程序在拥有任意大栈的“错觉”下正常工作。<br>系统调用给内核留下了一个内存保护的问题：许多系统调用接口让用户程序传递指针到内核中，这些指针指向了可读写的用户缓冲区，内核在执行系统调用时会间接引用这些指针。这会引发两个问题：<br>1、在内核中发生页错误比在用户程序中发生页错误更加严重。如果内核在操作自己的数据结构时发生了页错误，页错误处理程序应该panic内核，因为这是内核的bug。但如果是间接引用用户程序传递的指针引起的页错误，需要一种方式记住这些间接引用导致的页错误都是代表用户程序的。<br>2、内核通常比用户程序拥有更多的内存权限。用户程序传递给内核的指针指向的内存对于内核来说可能是可读写的，但对于用户程序来说是不能读写的。内核应当注意不要暴露一些私有信息或破坏内核完整性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exercise 9. 解决上述两个问题。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">问题1的解决：在kern/trap.c的page_fault_handler函数中识别页错误是发生在内核模式还是用户模式中（判断tf_cs的低2位），如果是内核模式，直接panic；如果是用户模式，销毁进程。</span><br><span class="line">//see in kern/trap.c</span><br><span class="line">void</span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">	// Read processor&apos;s CR2 register to find the faulting address</span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	// Handle kernel-mode page faults.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	if ((tf-&gt;tf_cs&amp;3) == 0)</span><br><span class="line">		panic(&quot;Kernel page fault!&quot;);</span><br><span class="line">	// We&apos;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="line">	// the page fault happened in user mode.</span><br><span class="line"></span><br><span class="line">	// Destroy the environment that caused the fault.</span><br><span class="line">	cprintf(&quot;[%08x] user fault va %08x ip %08x\n&quot;,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">问题2的解决：查看kern/pmap.c的user_mem_assert函数，并实现user_mem_check。然后在kern/syscall.c中检查系统调用的参数。user_mem_check函数主要是根据给定的权限查看给定的[va, va+len)是否有对应的访问权限。</span><br><span class="line">//see in kern/pmap.c</span><br><span class="line">//</span><br><span class="line">// Check that an environment is allowed to access the range of memory</span><br><span class="line">// [va, va+len) with permissions &apos;perm | PTE_P&apos;.</span><br><span class="line">// Normally &apos;perm&apos; will contain PTE_U at least, but this is not required.</span><br><span class="line">// &apos;va&apos; and &apos;len&apos; need not be page-aligned; you must test every page that</span><br><span class="line">// contains any of that range.  You will test either &apos;len/PGSIZE&apos;,</span><br><span class="line">// &apos;len/PGSIZE + 1&apos;, or &apos;len/PGSIZE + 2&apos; pages.</span><br><span class="line">//</span><br><span class="line">// A user program can access a virtual address if (1) the address is below</span><br><span class="line">// ULIM, and (2) the page table gives it permission.  These are exactly</span><br><span class="line">// the tests you should implement here.</span><br><span class="line">//</span><br><span class="line">// If there is an error, set the &apos;user_mem_check_addr&apos; variable to the first</span><br><span class="line">// erroneous virtual address.</span><br><span class="line">//</span><br><span class="line">// Returns 0 if the user program can access this range of addresses,</span><br><span class="line">// and -E_FAULT otherwise.</span><br><span class="line">//</span><br><span class="line">int</span><br><span class="line">user_mem_check(struct Env *env, const void *va, size_t len, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	cprintf(&quot;user_mem_check va: %x, len: %x\n&quot;, va, len);</span><br><span class="line">	uint32_t begin = (uint32_t)ROUNDDOWN((char*)va,PGSIZE);</span><br><span class="line">	uint32_t end = (uint32_t)ROUNDUP((char*)(va+len),PGSIZE);</span><br><span class="line">	uint32_t i=0;</span><br><span class="line">	for(i=begin;i&lt;end;i+=PGSIZE)&#123;</span><br><span class="line">		pte_t *pte = pgdir_walk(env-&gt;env_pgdir,(void *)i,false);</span><br><span class="line">		if(i&gt;=ULIM || !pte || !(*pte &amp; PTE_P) || (*pte &amp; perm) != perm)&#123;</span><br><span class="line">			user_mem_check_addr = (i&lt;(uint32_t)va?(uint32_t)va:i);</span><br><span class="line">			return -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(&quot;user_mem_check success va: %x, len: %x\n&quot;, va, len);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Checks that environment &apos;env&apos; is allowed to access the range</span><br><span class="line">// of memory [va, va+len) with permissions &apos;perm | PTE_U | PTE_P&apos;.</span><br><span class="line">// If it can, then the function simply returns.</span><br><span class="line">// If it cannot, &apos;env&apos; is destroyed and, if env is the current</span><br><span class="line">// environment, this function will not return.</span><br><span class="line">//</span><br><span class="line">void</span><br><span class="line">user_mem_assert(struct Env *env, const void *va, size_t len, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	if (user_mem_check(env, va, len, perm | PTE_U) &lt; 0) &#123;</span><br><span class="line">		cprintf(&quot;[%08x] user_mem_check assertion failure for &quot;</span><br><span class="line">			&quot;va %08x\n&quot;, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">		env_destroy(env);	// may not return</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//see in kern/syscall.c</span><br><span class="line">// Print a string to the system console.</span><br><span class="line">// The string is exactly &apos;len&apos; characters long.</span><br><span class="line">// Destroys the environment on memory errors.</span><br><span class="line">static void</span><br><span class="line">sys_cputs(const char *s, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	// Check that the user has permission to read memory [s, s+len).</span><br><span class="line">	// Destroy the environment if not.</span><br><span class="line"></span><br><span class="line">	// LAB 3: Your code here.</span><br><span class="line">	//see in kern/env.c : int	envid2env(envid_t envid, struct Env **env_store, bool checkperm);</span><br><span class="line">	//struct Env* e ;</span><br><span class="line">	//envid2env(sys_getenvid(),&amp;e,1);</span><br><span class="line">	user_mem_assert(curenv, s, len, PTE_U);//see in kern/pmap.c</span><br><span class="line">	// Print the string supplied by the user.</span><br><span class="line">	cprintf(&quot;%.*s&quot;, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p>1、二进制文件怎么连接进内核里？<br>2、如何生成唯一pid？以及pid与ENVX的关系<br>3、binary的数据位于内核空间的哪个节？<br>4、为什么所有中断都设置为中断门？<br>5、Exercise 7的Challenge实现<br>6、实际用户程序编译之后的地址与所谓的段选择子:偏移的对应关系？<br>7、各种门的使用情况</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记10-HW4-xv6-lazy-page-allocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记10-HW4-xv6-lazy-page-allocation/" itemprop="url">笔记10 - HW4: xv6 lazy page allocation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:12:30+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Part-One-Eliminate-allocation-from-sbrk"><a href="#Part-One-Eliminate-allocation-from-sbrk" class="headerlink" title="Part One: Eliminate allocation from sbrk()"></a>Part One: Eliminate allocation from sbrk()</h1><p>xv6应用程序通过调用sbrk()系统调用向内核申请heap内存空间，该系统调用将分配物理内存并map到进程的页目录（虚拟地址空间）。鉴于许多程序申请物理空间后并不使用，因此复杂的内核通常会设计为：在应用程序试图使用不存在的页面（访问到的虚拟地址不存在物理页映射）的时候，通过捕获产生页错误信号，然后分配物理内存使得程序可以继续执行，这称为“lazy page allocation”。而在申请heap内存空间的时候，仅仅是增大用户空间的值，即proc-&gt;sz。</p>
<p>修改后的代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//sysproc.c</span><br><span class="line">int</span><br><span class="line">sys_sbrk(void)</span><br><span class="line">&#123;</span><br><span class="line">  int addr;</span><br><span class="line">  int n;</span><br><span class="line"></span><br><span class="line">  if(argint(0, &amp;n) &lt; 0)</span><br><span class="line">    return -1;</span><br><span class="line">  addr = proc-&gt;sz; </span><br><span class="line">  //if(growproc(n) &lt; 0)</span><br><span class="line">  //  return -1;</span><br><span class="line">  proc-&gt;sz += n;</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_sbrk()</code>是通过growproc()函数来增加物理空间和改变用户空间大小的，注意到一个事实：<strong>用户空间的栈顶指针并没有发生改变。init.c通过fork子进程，然后子进程exec执行sh的时候，sh程序的栈顶指针是指向新分配的用户空间顶端的。之后sh程序fork子进程执行命令，子进程保持了该栈顶指针，子进程增加heap内存空间的时候，栈顶指针也没有变化。</strong><br>这样子的话，在sh中执行<code>echo hi</code>将会出现页错误，具体的发生时机是：<br>sh.c读取输入命令后，fork子进程执行命令，在解析命令的过程中调用execcmd，execcmd函数调用malloc()函数（见umalloc.c），malloc()函数根据空间使用情况将调用morecore()函数，morecore()函数调用sbrk()函数分配物理空间，进而内核执行<code>sys_sbrk()</code>系统调用。<code>sys_sbrk()</code>只返回分配前用户空间顶部的逻辑地址，因此malloc操作的地址空间其实是位于原用户空间之上。这里我们没有实际分配物理空间，因此后续在morecore()函数中执行<code>hp-&gt;s.size = nu;</code>时将发生页错误（还有其他地方也可能产生页错误，只要是访问到的虚拟地址没有映射到物理页），系统会产生<code>T_PGFLT</code>信号，trap.c中将输出相关错误信息，说明内核不知如何处理此类问题。</p>
<h1 id="Part-Two-Lazy-allocation"><a href="#Part-Two-Lazy-allocation" class="headerlink" title="Part Two: Lazy allocation"></a>Part Two: Lazy allocation</h1><p>我们将在trap.c对缺页信号进行处理，具体思路是：获取发生页错误的虚拟地址，将其向下4K页对齐，然后分配一页的物理空间并映射到进程页目录中。注意到，这并不会产生地址重映射的问题，因为如果重映射，说明发生页错误的虚拟地址向下4K页对齐后的对应的页之前已经被映射进页目录了，而这样的话该地址是不会产生页错误的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//trap.c</span><br><span class="line">void</span><br><span class="line">trap(struct trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">  switch(tf-&gt;trapno)&#123;</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">//PAGEBREAK: 13</span><br><span class="line">  default:</span><br><span class="line">    if(proc == 0 || (tf-&gt;cs&amp;3) == 0)&#123;</span><br><span class="line">      // In kernel, it must be our mistake.</span><br><span class="line">      cprintf(&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;,</span><br><span class="line">              tf-&gt;trapno, cpunum(), tf-&gt;eip, rcr2());</span><br><span class="line">      panic(&quot;trap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //By jianzzz</span><br><span class="line">    //处理页错误T_PGFLT</span><br><span class="line">    if(tf-&gt;trapno == T_PGFLT)&#123;</span><br><span class="line">      //rcr2() --&gt; 导致页错误的虚拟地址</span><br><span class="line">      uint va = rcr2();</span><br><span class="line">      uint sz = PGROUNDDOWN(va); </span><br><span class="line">      cprintf( &quot;T_PGFLT:%x\n&quot;,va);</span><br><span class="line">      if((sz = allocuvm(proc-&gt;pgdir, sz, sz + PGSIZE)) == 0)</span><br><span class="line">        panic(&quot;trap T_PGFLT&quot;);  </span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // In user space, assume process misbehaved.</span><br><span class="line">    cprintf(&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span><br><span class="line">            &quot;eip 0x%x addr 0x%x--kill proc\n&quot;,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, tf-&gt;trapno, tf-&gt;err, cpunum(), tf-&gt;eip,</span><br><span class="line">            rcr2());</span><br><span class="line">    proc-&gt;killed = 1;</span><br><span class="line">  &#125;</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">                           .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>xv6的堆分配思想见【The C Programming Language 8.7.实例–存储分配程序】。<br><strong>由上可知，堆是在用户态实现的，使用链表进行管理。在xv6中，使用malloc并不一定分配物理空间。如果堆管理发现可用空间不够，则调用sbrk()函数申请分配物理空间，此时系统只累加进程空间大小，并返回当前用户空间顶部的逻辑地址。堆管理根据申请的大小调整链表记录，然后尝试对“分配”的空间进行访问，产生页错误，内核对其进行页分配和映射，返回用户态后程序正常运行。之后只要继续在链表记录的大小内使用malloc，若遇到未分配地址则继续产生页错误，否则使用已有的空间；而如果超出了链表记录大小，则再次调用调用sbrk()函数申请分配物理空间并更新链表大小记录。对于不再使用的空间，调用free()并入到空闲链表中，没有实际归还到操作系统。等到程序结束的时候，所有映射到页表的堆空间将被释放。</strong></p>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p>申请新的heap空间后，特殊情况下栈顶指针会不会指向到heap空间（比如人为一直pop）？即这里存在一个疑问：栈底是固定的吗？？？  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记09-xv6-部分系统调用的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记09-xv6-部分系统调用的实现/" itemprop="url">笔记09 - xv6 部分系统调用的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:11:53+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h1><p>exec指令用新程序替代当前进程的内存和寄存器，但保留文件描述符、进程id、父进程不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">//exec.c</span><br><span class="line">int</span><br><span class="line">exec(char *path, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  char *s, *last;</span><br><span class="line">  int i, off;</span><br><span class="line">  uint argc, sz, sp, ustack[3+MAXARG+1];</span><br><span class="line">  struct elfhdr elf;</span><br><span class="line">  struct inode *ip;</span><br><span class="line">  struct proghdr ph;</span><br><span class="line">  pde_t *pgdir, *oldpgdir;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  if((ip = namei(path)) == 0)&#123;//寻找name对应的inode</span><br><span class="line">    end_op();</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  pgdir = 0;</span><br><span class="line"></span><br><span class="line">  // Check ELF header</span><br><span class="line">  //读取程序的elf</span><br><span class="line">  if(readi(ip, (char*)&amp;elf, 0, sizeof(elf)) &lt; sizeof(elf))// Read data from inode.</span><br><span class="line">    goto bad;</span><br><span class="line">  if(elf.magic != ELF_MAGIC)</span><br><span class="line">    goto bad;</span><br><span class="line">  //创建内核页目录，映射内核空间。实际上是创建二级页表，并在二级页表项上存储物理地址。</span><br><span class="line">  //页目录项所存页表的权限是用户可读写,二级页表项所存物理页的权限按照kmap设定</span><br><span class="line">  if((pgdir = setupkvm()) == 0)</span><br><span class="line">    goto bad;</span><br><span class="line"></span><br><span class="line">  // Load program into memory.</span><br><span class="line">  //根据inode和elf程序头表偏移量, 按段读取程序</span><br><span class="line">  sz = 0;</span><br><span class="line">  for(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph))&#123;</span><br><span class="line">    //读取段的程序头表项</span><br><span class="line">    if(readi(ip, (char*)&amp;ph, off, sizeof(ph)) != sizeof(ph))</span><br><span class="line">      goto bad;</span><br><span class="line">    if(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      continue;</span><br><span class="line">    if(ph.memsz &lt; ph.filesz)</span><br><span class="line">      goto bad;</span><br><span class="line">    if(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      goto bad;</span><br><span class="line">    //根据段的虚拟地址及段占据的内存大小分配物理空间,该过程会将程序的虚拟地址映射到分配到的物理页地址上</span><br><span class="line">    //二级页表项所存物理页的权限是用户可读写</span><br><span class="line">    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)</span><br><span class="line">      goto bad;</span><br><span class="line">    if(ph.vaddr % PGSIZE != 0)</span><br><span class="line">      goto bad;</span><br><span class="line">    //根据程序头表项信息读取段到内存中</span><br><span class="line">    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &lt; 0)</span><br><span class="line">      goto bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = 0;</span><br><span class="line"></span><br><span class="line">  // Allocate two pages at the next page boundary.</span><br><span class="line">  // Make the first inaccessible.  Use the second as the user stack.</span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  //继续为程序分配两页物理空间,二级页表项所存物理页的权限是用户可读写</span><br><span class="line">  //取消第一页用户可读写权限，第二页作为用户栈</span><br><span class="line">  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)</span><br><span class="line">    goto bad;</span><br><span class="line">  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));</span><br><span class="line">  sp = sz;</span><br><span class="line"></span><br><span class="line">  // Push argument strings, prepare rest of stack in ustack.</span><br><span class="line">  for(argc = 0; argv[argc]; argc++) &#123;</span><br><span class="line">    if(argc &gt;= MAXARG)</span><br><span class="line">      goto bad;</span><br><span class="line">    sp = (sp - (strlen(argv[argc]) + 1)) &amp; ~3;</span><br><span class="line">    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) &lt; 0)</span><br><span class="line">      goto bad;</span><br><span class="line">    ustack[3+argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[3+argc] = 0;</span><br><span class="line"></span><br><span class="line">  ustack[0] = 0xffffffff;  // fake return PC</span><br><span class="line">  ustack[1] = argc;</span><br><span class="line">  ustack[2] = sp - (argc+1)*4;  // argv pointer</span><br><span class="line"></span><br><span class="line">  sp -= (3+argc+1) * 4;</span><br><span class="line">  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) &lt; 0)</span><br><span class="line">    goto bad;</span><br><span class="line"></span><br><span class="line">  // Save program name for debugging.</span><br><span class="line">  for(last=s=path; *s; s++)</span><br><span class="line">    if(*s == &apos;/&apos;)</span><br><span class="line">      last = s+1;</span><br><span class="line">  safestrcpy(proc-&gt;name, last, sizeof(proc-&gt;name));</span><br><span class="line"></span><br><span class="line">  // Commit to the user image.</span><br><span class="line">  oldpgdir = proc-&gt;pgdir;</span><br><span class="line">  proc-&gt;pgdir = pgdir;</span><br><span class="line">  proc-&gt;sz = sz;</span><br><span class="line">  proc-&gt;tf-&gt;eip = elf.entry;  // main</span><br><span class="line">  proc-&gt;tf-&gt;esp = sp;</span><br><span class="line">  switchuvm(proc);//设置cpu环境后，加载进程的页目录地址到cr3</span><br><span class="line">  freevm(oldpgdir);</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  if(pgdir)</span><br><span class="line">    freevm(pgdir);</span><br><span class="line">  if(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到，exec改变的有<strong>进程的页目录、用户空间内容、用户空间size、进程的tf-&gt;eip、tf-&gt;esp、用户栈、进程名</strong>，没有改变的有<strong>进程文件描述符、进程pid、父进程、内核栈、进程状态、当前目录</strong>等。  </p>
<p>exec的整体思路是：1、根据程序路径查找对应的inode；2、根据inode读取程序的elf信息；3、调用setupkvm()创建页目录，并映射内核空间（页目录项所存页表的权限是用户可读写，二级页表项所存物理页的权限按照kmap设定）；4、根据inode和elf程序头表偏移量，按段读取程序。每次循环时：4.1、先读取段的程序头表项，程序头表项包含段的虚拟地址及段占据的内存大小，4.2、根据信息调用allocuvm()分配出物理空间，分配过程会将程序的虚拟地址映射到分配到的物理页地址上，二级页表项所存物理页的权限是用户可读写，4.3、根据程序头表项信息（段偏移及段的文件大小）读取段到内存中；5、继续为程序分配两页物理空间，二级页表项所存物理页的权限是用户可读写，取消第一页用户可读写权限，第二页将作为用户栈。6、构建用户栈数据（参数等，见下）；7、更新进程的页目录、用户空间size、进程的tf-&gt;eip为elf.entry(main)、tf-&gt;esp为用户栈指针当前位置，然后调用switchuvm()函数设置cpu环境，加载进程的页目录地址到cr3，释放旧页目录空间；8、返回trapret处，切换为用户态，返回执行新程序代码，不返回执行旧程序代码。<br><img src="/2017/08/20/笔记09-xv6-部分系统调用的实现/1.JPG" title="构建用户栈数据"></p>
<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>fork用于创建新进程，并且复制当前进程的页目录、tramframe、内存空间大小、文件描述符、当前目录等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//proc.c</span><br><span class="line">int</span><br><span class="line">fork(void)</span><br><span class="line">&#123;</span><br><span class="line">  int i, pid;</span><br><span class="line">  struct proc *np;</span><br><span class="line"></span><br><span class="line">  // Allocate process.</span><br><span class="line">  //在进程表中寻找slot，成功的话更改进程状态和pid，并初始化进程的内核栈</span><br><span class="line">  //注意子进程使用的是新的内核栈</span><br><span class="line">  if((np = allocproc()) == 0)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Copy process state from p.</span><br><span class="line">  //copy一个进程的页目录对应的所有内容，思路是：首先创建新的页目录；</span><br><span class="line">  //在进程的用户空间虚拟地址范围内，由虚拟地址0x0开始，取得映射的物理页地址，然后申请新的物理页，将前者物理页的内容copy到后者；</span><br><span class="line">  //取出二级页表项的flag，当前虚拟地址映射到新物理页地址，其二级页表项权限设为flag。</span><br><span class="line">  if((np-&gt;pgdir = copyuvm(proc-&gt;pgdir, proc-&gt;sz)) == 0)&#123; //see in vm.c</span><br><span class="line">    kfree(np-&gt;kstack);</span><br><span class="line">    np-&gt;kstack = 0;</span><br><span class="line">    np-&gt;state = UNUSED;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = proc-&gt;sz; //设置进程的用户空间范围</span><br><span class="line">  np-&gt;parent = proc; //设置进程的父进程</span><br><span class="line">  *np-&gt;tf = *proc-&gt;tf; //设置进程的tramframe,这是结构体的值传递???</span><br><span class="line"></span><br><span class="line">  // Clear %eax so that fork returns 0 in the child.</span><br><span class="line">  np-&gt;tf-&gt;eax = 0;</span><br><span class="line">  //复制fd </span><br><span class="line">  for(i = 0; i &lt; NOFILE; i++)</span><br><span class="line">    if(proc-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(proc-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(proc-&gt;cwd);//复制当前目录</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, proc-&gt;name, sizeof(proc-&gt;name));</span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;//父进程必须在子进程的所有内容设置完毕后，才改为runnable，才能被cpu调度</span><br><span class="line"></span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  return pid;</span><br><span class="line">  //对于父进程而言，其系统调用的结果（子进程的pid）将在syscall.c中赋值到tf-&gt;eax中，</span><br><span class="line">  //然后在trapasm.S中弹出到eax，最终被用户进程获取。</span><br><span class="line">  //对于子进程而言，其复制了父进程的用户空间内容（包括代码），并使用新的内核栈，</span><br><span class="line">  //内核栈中trapframe的内容复制于父进程（包括下一条指令的eip，这条指令往往是从eax获取系统调用结果），</span><br><span class="line">  //并将eax的值改为0，这样子当cpu调度到子进程的时候，内核会将子进程的trapframe弹出，子进程将执行eip指向的指令，即从eax获取系统调用结果，所以获取到的pid是0。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到，fork新建并复制的内容有<strong>进程的内核栈（copy了tramframe）、页目录、用户空间内容</strong>，改变的内容有<strong>进程的父进程、进程的tf-&gt;eax、进程状态</strong>，复制的有<strong>用户空间size、进程的tramframe、进程的文件描述符、当前目录、进程名</strong>等。  </p>
<p>fork的过程是：1、在进程表中寻找slot，成功的话更改进程状态和pid，并初始化进程的内核栈。注意子进程使用的是新的内核栈。2、copy当前进程的页目录对应的所有内容，思路是：首先创建新的页目录；在进程的用户空间虚拟地址范围内，由虚拟地址0x0开始，取得映射的物理页地址，然后申请新的物理页，将前者内容copy到后者；取出二级页表项的flag，当前虚拟地址映射到新物理页地址，其二级页表项权限设为flag。3、设置进程的用户空间范围、进程的父进程、进程的tramframe（值传递）。4、清除新进程tf-&gt;eax为0，所以子进程的fork返回值为0。5、复制fd、当前目录、进程名。6、设置进程状态为RUNNABLE。7、父进程返回pid。</p>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、inode以及目录项的设计</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记08-HW3-xv6-system-calls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记08-HW3-xv6-system-calls/" itemprop="url">笔记08 - HW3: xv6 system calls</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:09:35+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h1><p>任务：修改syscall.c的syscall()函数，输出系统调用函数名和执行结果。<br>解决方案如下：<br>根据xv6源码分析，可以知道inidcode.S执行<code>movl $SYS_exec, %eax</code>把trapno放到%eax里面，之后int的时候会跳转到alltraps，其会执行pushal将包括eax在内的通用寄存器进栈（其实是保存到proc-&gt;tf），之后在syscall函数就可以通过proc-&gt;tf-&gt;eax获取trapno了。而系统调用的执行结果也放在了eax中。从proc-&gt;tf-&gt;eax中可以拿到syscall number，然后做个映射表输出就可以了。<br>另外，syscall.c提供argint、argptr和argstr等工具函数，用于在进程用户空间获得第 n 个系统调用参数。argint用于获取第n个整数，存储在int指针中（通过fetchint工具函数完成）。argptr用于获取第n个整数，将char<em>指针指向它。argstr用于获取第n个整数，该参数是字符串起始地址值，使用char</em>指针指向它，函数本身返回字符串长度（通过fetchstr工具函数完成）。argint利用用户空间的%esp寄存器定位第n个参数：%esp指向系统调用结束后的返回地址，参数就恰好在%esp之上（%esp+4），因此第n个参数就在%esp+4+4*n。<br>此处不对系统调用参数进行输出，因为每个系统调用所传递的参数个数和类型不同，而如果直接在工具函数中输出的话，则无法判断是地址值还是参数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const char* syscall_name[] = &#123; &quot;fork&quot;,&quot;exit&quot;,&quot;wait&quot;,&quot;pipe&quot;,&quot;read&quot;,&quot;kill&quot;,&quot;exec&quot;,&quot;fstat&quot;,&quot;chdir&quot;,&quot;dup&quot;,&quot;getpid&quot;,&quot;sbrk&quot;,&quot;sleep&quot;,&quot;uptime&quot;,&quot;open&quot;,&quot;write&quot;,&quot;mknod&quot;,&quot;unlink&quot;,&quot;link&quot;,&quot;mkdir&quot;,&quot;close&quot; &#125;;</span><br><span class="line"> </span><br><span class="line">void</span><br><span class="line">syscall(void)</span><br><span class="line">&#123;</span><br><span class="line">  int num; </span><br><span class="line">  num = proc-&gt;tf-&gt;eax;</span><br><span class="line">  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    proc-&gt;tf-&gt;eax = syscalls[num](); </span><br><span class="line">    //trapno放到%eax里面,系统调用的执行结果也放在了eax中</span><br><span class="line">    //打印系统调用名称和结果</span><br><span class="line">    //cprintf(&quot;\n%s -&gt; %d\n&quot;, syscall_name[num], proc-&gt;tf-&gt;eax);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cprintf(&quot;%d %s: unknown sys call %d\n&quot;,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, num);</span><br><span class="line">    proc-&gt;tf-&gt;eax = -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h1><p>系统调用实现思路如下：<br>有一个.h文件暴露接口，有一个.c文件来实现接口，在x86上实现方法是c语言层内联汇编int指令（或者直接汇编实现），把系统调用号放入eax，内核中有一个系统调用表，根据eax的值来索引这个表得到vectorXXX地址，vectorXXX jmp过去alltraps，进入内核模式，执行trap函数，trap函数将执行系统调用函数（如果系统调用叫xxx，内核对应的函数一般叫sys_xxx）。<br>在xv6中，想要添加新的系统调用并在shell中调用，需要了解五个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user.h 定义了可以通过shell调用的函数</span><br><span class="line">usys.S 使用宏定义将用户调用转换为系统调用</span><br><span class="line">syscall.h 定义系统调用的位置向量，从而可以连接到系统调用的实现</span><br><span class="line">syscall.c 根据syscall.h 定义的系统调用位置向量，调用系统调用的实现函数</span><br><span class="line">sysproc.c 增加了系统调用的真正实现</span><br></pre></td></tr></table></figure></p>
<p>添加系统调用函数date()，返回当前UTC时间。参考cmostime()(defined in lapic.c)函数，其功能是读取实时时钟；参考date.h，该头文件定义了struct rtcdate，该结构体作为cmostime()的指针形参。<br>技巧：参考uptime的实现，执行<code>grep -n uptime *.[chS]</code>参考其在对应的文件中的定义。然后在Makefile中添加_date到UPROGS中。创建date.c，输入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;types.h&quot;</span><br><span class="line">#include &quot;user.h&quot;</span><br><span class="line">#include &quot;date.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  struct rtcdate r;</span><br><span class="line"></span><br><span class="line">  if (date(&amp;r)) &#123;</span><br><span class="line">    printf(2, &quot;date failed\n&quot;);</span><br><span class="line">    exit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // your code to print the time in any format you like...</span><br><span class="line">  printf(1, &quot;%d/%d/%d %d:%d:%d\n&quot;, r.year, r.month, r.day, r.hour, r.minute, r.second);</span><br><span class="line">  exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样之后编译执行后，在命令行输入date应该能输出时间。<br>其工作原理是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//see in usys.S</span><br><span class="line">#define SYSCALL(name) .globl name; name: movl $SYS_ ## name, %eax; int $T_SYSCALL; ret</span><br><span class="line">## 操作符将会连接$SYS_和name。</span><br><span class="line">所以，声明SYSCALL(date)将被扩展为：</span><br><span class="line">.globl date; date: movl $SYS_date, %eax; int $T_SYSCALL; ret</span><br><span class="line"></span><br><span class="line">如果在控制台中（用户进程）执行date(&amp;r)，其中r的定义是struct rtcdate r，将会将r的地址进栈，eip进栈，然后寻找到 date: 标识位置，执行int系统调用。syscall.c根据SYS_date的值调用sys_date()函数。sys_date()函数的实现是：</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">sys_date(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct rtcdate *pr;</span><br><span class="line">  if (argptr(0, (void*)&amp;pr, sizeof(struct rtcdate)) &lt; 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  cmostime(pr);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其将会定义struct rtcdate类型的pr指针，然后使用argptr函数获取proc-&gt;tf-&gt;esp（进程用户栈）指向的第一个32-bit参数（跳过esp指向的eip），将pr指针指向该值，由上述可知这是调用date函数的参数地址，所以存储到pr相当于存储到参数r中。</span><br></pre></td></tr></table></figure></p>
<p>在Makefile中添加<code>_date</code>到UPROGS中后，将生成<code>_date</code>的可执行文件，其将作为内核的内置函数。</p>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>add a dup2() system call<br>实现的方法如上。区别是将<code>sys_dup2(void)</code>的实现放在<code>sysfile.c</code>中，与<code>sys_dup(void)</code>放在一起。<br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/1.PNG" title="dup2 system call"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">sys_dup2(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *oldfile, *newfile;</span><br><span class="line">    int newfd;</span><br><span class="line">    //取出第一个参数fd，其应该对应到一个file对象</span><br><span class="line">    if (argfd(0, 0, &amp;oldfile) &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //取出第二个参数fd</span><br><span class="line">    if (argint(1, &amp;newfd) &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(newfd &lt; 0 || newfd &gt;= NOFILE) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //newfd文件描述符没有对应的file对象，可以安全使用，使新旧fd指向同一个file对象</span><br><span class="line">    if (proc-&gt;ofile[newfd] == 0) &#123; </span><br><span class="line">        goto final;</span><br><span class="line">    &#125; else if (argfd(1, &amp;newfd, &amp;newfile) &lt; 0) &#123; //newfd文件描述符有对应的file对象,取出file对象</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //两个fd指向同个file对象，返回 </span><br><span class="line">    if (oldfile == newfile) &#123;</span><br><span class="line">        return newfd;</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭文件</span><br><span class="line">    if (newfile-&gt;ref &gt; 0) &#123;</span><br><span class="line">        fileclose(newfile);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">final:</span><br><span class="line">    proc-&gt;ofile[newfd] = oldfile;</span><br><span class="line">    filedup(oldfile);</span><br><span class="line"></span><br><span class="line">    return newfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dup2test.c比较疑惑的是创建的文件不知道在哪里，所以使用了read函数进行测试。（在xv6虚拟的文件系统中）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//dup2test.c</span><br><span class="line">/*</span><br><span class="line"> * Tests the functionality of the `dup2` system call. The first argument is the</span><br><span class="line"> * original file the we are duplicating. If a second argument is passed in we</span><br><span class="line"> * open this file, write a string to it, then duplicate it. This tests that our</span><br><span class="line"> * kernel is properly closing and duplicating the file. In both cases the original </span><br><span class="line"> * file should have the string &quot;foobar\n&quot;. If not, then something went wrong </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;types.h&quot;</span><br><span class="line">#include &quot;stat.h&quot;</span><br><span class="line">#include &quot;user.h&quot;</span><br><span class="line">#include &quot;fcntl.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[]) &#123;</span><br><span class="line">    int origfd, newfd = 0; </span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">      printf(1, &quot;%s: Not enough arguments\n&quot;, argv[0]);</span><br><span class="line">      printf(1, &quot;Usage: origfile [newfile]\n&quot;);</span><br><span class="line">      exit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlink(argv[1]);</span><br><span class="line"></span><br><span class="line">    if ((origfd = open(argv[1], O_CREATE|O_RDWR)) &lt; 0) &#123;</span><br><span class="line">      printf(1, &quot;Cannot open &apos;%s&apos;\n&quot;, argv[1]);</span><br><span class="line">      exit();</span><br><span class="line">    &#125; </span><br><span class="line">    if (argc &gt; 2) &#123;</span><br><span class="line">      unlink(argv[2]);</span><br><span class="line">      if ((newfd = open(argv[2], O_CREATE|O_RDWR)) &lt; 0) &#123;</span><br><span class="line">          printf(1, &quot;Cannot open &apos;%s&apos;\n&quot;, argv[2]);</span><br><span class="line">          exit();</span><br><span class="line">      &#125; </span><br><span class="line">      write(newfd, &quot;ignored\n&quot;, 8);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    write(origfd, &quot;foo&quot;, 3);</span><br><span class="line">    if (dup2(origfd, newfd) &lt; 0) &#123;</span><br><span class="line">        printf(1, &quot;dup2 error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(newfd, &quot;bar\n&quot;, 4);</span><br><span class="line"></span><br><span class="line">    close(origfd);</span><br><span class="line">    close(newfd);</span><br><span class="line">    if ((newfd = open(argv[1], O_RDWR)) &lt; 0) &#123;</span><br><span class="line">      printf(1, &quot;Cannot open &apos;%s&apos;\n&quot;, argv[2]);</span><br><span class="line">      exit();</span><br><span class="line">    &#125; </span><br><span class="line">    char buf[256];</span><br><span class="line">    int n = read(newfd,buf,256);</span><br><span class="line">    printf(1, &quot;%d: %s\n&quot;, n,buf);</span><br><span class="line"></span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p><strong>如何拿到系统调用的结果，比如dup(fd)？</strong><br>我们知道，系统调用的结果最终是放在进程tf结构的eax中，然后在trapret阶段弹出到寄存器中。而返回到用户空间后会往eax中拿取结果，这是一种默认约定。<br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/2.jpg" title="系统调用的结果1"><br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/3.jpg" title="系统调用的结果2"><br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/4.jpg" title="系统调用的结果3"><br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/5.jpg" title="系统调用的结果4"><br><img src="/2017/08/20/笔记08-HW3-xv6-system-calls/6.jpg" title="系统调用的结果5">  </p>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p>为什么需要转换成系统调用？实质区别在哪里（关于硬件特权）？<br>为什么类似printf等不需要实现为系统调用？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记07-xv6-启动到执行第一个进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记07-xv6-启动到执行第一个进程/" itemprop="url">笔记07 - xv6 启动到执行第一个进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:09:04+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>xv6的boot loader从硬盘加载xv6内核到内存并在entry处开始执行，此时xv6还没开启分页，virtual addresses直接映射到physical addresses。boot loader将内核加载到物理地址0x100000，不加载在0x80100000（内核期望由此地址寻找指令和数据）的原因是机器不一定有这么多内存，不加载在0x0的原因是0xa0000:0x100000的范围内包含了IO设备。为了允许剩余的内核代码可以正常运行，entry设置了页表，映射virtual addresses 0x80000000(KERNBASE)到physical addresses 0x0。entry分别映射virtual addresses 0:0x400000 到 physical addresses 0:0x400000，以及virtual addresses KERNBASE:KERNBASE+0x400000 到 physical addresses 0:0x400000，这也要求内核指令和数据占据的空间在4M以内。以下主要分析x86启动分页、内核初始化、启动多处理器、启动init进程的过程。  </p>
<p>xv6的进程结构以及进程调度涉及到进程的有三大数据结构：struct cpu、struct proc、struct context。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// proc.h</span><br><span class="line"></span><br><span class="line">// Per-CPU state</span><br><span class="line">struct cpu &#123;</span><br><span class="line">  uchar apicid;                // Local APIC ID</span><br><span class="line">  struct context *scheduler;   // swtch() here to enter scheduler</span><br><span class="line">  struct taskstate ts;         // Used by x86 to find stack for interrupt</span><br><span class="line">  struct segdesc gdt[NSEGS];   // x86 global descriptor table</span><br><span class="line">  volatile uint started;       // Has the CPU started?</span><br><span class="line">  int ncli;                    // Depth of pushcli nesting.</span><br><span class="line">  int intena;                  // Were interrupts enabled before pushcli?</span><br><span class="line"></span><br><span class="line">  // Cpu-local storage variables; see below</span><br><span class="line">  struct cpu *cpu;</span><br><span class="line">  struct proc *proc;           // The currently-running process.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum procstate &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line">// Per-process state</span><br><span class="line">struct proc &#123;</span><br><span class="line">  uint sz;                     // Size of process memory (bytes)</span><br><span class="line">  pde_t* pgdir;                // Page table</span><br><span class="line">  char *kstack;                // Bottom of kernel stack for this process</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  int pid;                     // Process ID</span><br><span class="line">  struct proc *parent;         // Parent process</span><br><span class="line">  struct trapframe *tf;        // Trap frame for current syscall</span><br><span class="line">  struct context *context;     // swtch() here to run process</span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//PAGEBREAK: 17</span><br><span class="line">// Saved registers for kernel context switches.</span><br><span class="line">// Don&apos;t need to save all the segment registers (%cs, etc),</span><br><span class="line">// because they are constant across kernel contexts.</span><br><span class="line">// Don&apos;t need to save %eax, %ecx, %edx, because the</span><br><span class="line">// x86 convention is that the caller has saved them.</span><br><span class="line">// Contexts are stored at the bottom of the stack they</span><br><span class="line">// describe; the stack pointer is the address of the context.</span><br><span class="line">// The layout of the context matches the layout of the stack in swtch.S</span><br><span class="line">// at the &quot;Switch stacks&quot; comment. Switch doesn&apos;t save eip explicitly,</span><br><span class="line">// but it is on the stack and allocproc() manipulates it.</span><br><span class="line">struct context &#123;</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>附上file、inode以及trapframe结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// file.h</span><br><span class="line">struct file &#123;</span><br><span class="line">  enum &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type;</span><br><span class="line">  int ref; // reference count</span><br><span class="line">  char readable;</span><br><span class="line">  char writable;</span><br><span class="line">  struct pipe *pipe;</span><br><span class="line">  struct inode *ip;</span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">// in-memory copy of an inode</span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           // Device number</span><br><span class="line">  uint inum;          // Inode number</span><br><span class="line">  int ref;            // Reference count</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  int flags;          // I_VALID</span><br><span class="line"></span><br><span class="line">  short type;         // copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// x86.h</span><br><span class="line">//PAGEBREAK: 36</span><br><span class="line">// Layout of the trap frame built on the stack by the</span><br><span class="line">// hardware and by trapasm.S, and passed to trap().</span><br><span class="line">struct trapframe &#123;</span><br><span class="line">  // registers as pushed by pusha</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      // useless &amp; ignored</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"></span><br><span class="line">  // rest of trap frame</span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;</span><br><span class="line"></span><br><span class="line">  // below here defined by x86 hardware</span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  // below here only when crossing rings, such as from user to kernel</span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="启动分页"><a href="#启动分页" class="headerlink" title="启动分页"></a>启动分页</h1><p>启动分页之前必须创建页表并设置给cr3寄存器，然后给cr0寄存器的PG位置为1。除此之外，x86还允许创建不同粒度的内存页，这涉及到cr4寄存器。在x86中，一个也目录中可以同时存在两种粒度的内存页，4K或者4M。page dir是必须的，这是一个长度最大为1024的整数数组，如果页目录表项的PS位置为1且cr4寄存器的PSE位置为1，那么CPU自动使用4M大小的内存页，即该页目录表项中保存的就是内存页的起始地址，这相当于进行二级分页而不是更常见的三级分页。如果这两个要求不能同时满足就进行三级分页。注意x86运行两种分页同时存在，比如cr4的PSE位设为1，而有些page dir表项设置PS位而有些则不设置，这样就同时存在两种分页机制。为何要使用4MB页呢，考虑这种场景：kernel img大小大约为1M，如果使用4M页映射kernel img，则TLB只需缓存一个页目录项即可，而如果是4K页则需要256个页目录项，这么多的表项是无法都缓存到TLB中的，这会使得地址翻译变慢很多。所以kernel img部分一般用一个4M页进行映射，而其他则使用4K页。对于xv6来说，使用4M页只是临时，不用创建复杂的页表，如此而已，内核启动之后很快就会重新创建页表。  </p>
<p>为何要将0~4M进行1:1映射呢？在开启分页之前我们都是小心翼翼的使用“低地址”，<br>而打开分页之后我们将会跳转到“高地址”，低地址还有必要映射吗？有必要。在启动多处理器的时候，还需要从低地址启动，因为这些CPU（non-boot CPU，也叫做AP）要需要从real mode启动，见entryother.S。</p>
<h1 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h1><p>进入main函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">main(void)</span><br><span class="line">&#123;</span><br><span class="line">  //根据entry.S里面对栈的设置，可知栈顶位置在end之前。（存疑：根据objdump -h kernel结果和kernel.asm，entry.S里stack的位置并不在.data节内，为什么？）</span><br><span class="line">  //将[end，4M](end先4K对齐)范围free为kmem，此时未开启分页，使用的是硬编码的4m地址映射。</span><br><span class="line">  //kmem锁初始化，处于解锁状态，占有kmem锁的CPU数目为0</span><br><span class="line">  //end: first address after kernel loaded from ELF file</span><br><span class="line">  kinit1(end, P2V(4*1024*1024)); // phys page allocator // see in kalloc.c</span><br><span class="line">  //为scheduler进程创建内核页目录，根据kmap设定将所有涉及范围内的内核空间虚拟地址</span><br><span class="line">  //(从KERNBASE开始,把IO空间、内核镜像等都建立映射，这些空间全都是用户空间可见的，位于2GB以上)按页大小映射到物理地址上，</span><br><span class="line">  //实际上是创建二级页表，并在二级页表项上存储物理地址。将页目录地址存储到cr3中。</span><br><span class="line">  //页目录项所存页表的权限是用户可读写</span><br><span class="line">  //二级页表项所存物理页的权限按照kmap设定</span><br><span class="line">  kvmalloc();      // kernel page table //see in vm.c</span><br><span class="line">  //</span><br><span class="line">  mpinit();        // detect other processors</span><br><span class="line">  lapicinit();     // interrupt controller</span><br><span class="line">  //初始化段寄存器，更新当前cpu</span><br><span class="line">  seginit();       // segment descriptors // see in vm.c</span><br><span class="line">  //</span><br><span class="line">  cprintf(&quot;\ncpu%d: starting xv6\n\n&quot;, cpunum());</span><br><span class="line">  //</span><br><span class="line">  picinit();       // another interrupt controller</span><br><span class="line">  //</span><br><span class="line">  ioapicinit();    // another interrupt controller</span><br><span class="line">  //</span><br><span class="line">  consoleinit();   // console hardware</span><br><span class="line">  //</span><br><span class="line">  uartinit();      // serial port</span><br><span class="line">  //进程表锁初始化，设置进程表处于解锁状态，占有进程表锁的CPU数目为0</span><br><span class="line">  pinit();         // process table //see in proc.c</span><br><span class="line">  //建立正常的中断/陷阱门描述符,中断处理锁初始化，处于解锁状态，占有中断处理锁的CPU数目为0</span><br><span class="line">  tvinit();        // trap vectors //see in trap.c</span><br><span class="line">  //</span><br><span class="line">  binit();         // buffer cache</span><br><span class="line">  //</span><br><span class="line">  fileinit();      // file table</span><br><span class="line">  //</span><br><span class="line">  ideinit();       // disk</span><br><span class="line">  //</span><br><span class="line">  if(!ismp)</span><br><span class="line">    timerinit();   // uniprocessor timer</span><br><span class="line">  //</span><br><span class="line">  startothers();   // start other processors</span><br><span class="line">  //将[4M,PHYSTOP]范围free为kmem，此时已经开启分页。</span><br><span class="line">  //设置计数表示kmem锁处于使用状态</span><br><span class="line">  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers() // see in kalloc.c</span><br><span class="line"></span><br><span class="line">  //1.</span><br><span class="line">  //在进程表中寻找slot，成功的话更改进程状态embryo和pid，并初始化进程的内核栈</span><br><span class="line">  //2.</span><br><span class="line">  //为进程创建内核页目录，根据kmap设定将所有涉及范围内的内核空间虚拟地址</span><br><span class="line">  //(从KERNBASE开始,把IO空间、内核镜像等都建立映射，这些空间全都是用户空间可见的，位于2GB以上)按页大小映射到物理地址上，</span><br><span class="line">  //实际上是创建二级页表，并在二级页表项上存储物理地址。</span><br><span class="line">  //每个进程都会新建页目录和二级页表</span><br><span class="line">  //页目录项所存页表的权限是用户可读写</span><br><span class="line">  //二级页表项所存物理页的权限按照kmap设定</span><br><span class="line">  //3.</span><br><span class="line">  //从kmem上分配一页的物理空间给进程，在新建进程的页目录上映射[0,PGSIZE]的虚拟地址到分配的物理地址上，将指向内容复制到物理内存上</span><br><span class="line">  //页目录项所存页表的权限是用户可读写</span><br><span class="line">  //二级页表项所存物理页的权限为用户可读写</span><br><span class="line">  //4.</span><br><span class="line">  //设置进程的trapframe</span><br><span class="line">  //设置进程状态runnable</span><br><span class="line">  userinit();      // first user process  //see in proc.c </span><br><span class="line">  //idtinit()加载中断描述符表寄存器</span><br><span class="line">  //scheduler()无限循环寻找进程状态为runnable的进程</span><br><span class="line">  //对于每次循环：</span><br><span class="line">      //开中断运行当前进程</span><br><span class="line">      //找到可执行的进程后，更新全局变量proc为当前被选中的进程</span><br><span class="line">      //设置cpu环境后，加载选中进程的页目录地址到cr3,切换为进程的页目录</span><br><span class="line">      //更改进程状态为running</span><br><span class="line">      //CPU调度</span><br><span class="line">      //加载内核的页目录地址到cr3,切换为内核的页目录</span><br><span class="line">  mpmain();        // finish this processor&apos;s setup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vm.c</span><br><span class="line">static struct kmap &#123;</span><br><span class="line">  void *virt;</span><br><span class="line">  uint phys_start;</span><br><span class="line">  uint phys_end;</span><br><span class="line">  int perm;</span><br><span class="line">&#125; kmap[] = &#123;</span><br><span class="line"> &#123; (void*)KERNBASE, 0,             EXTMEM,    PTE_W&#125;, // I/O space</span><br><span class="line"> &#123; (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0&#125;,     // kern text+rodata</span><br><span class="line"> &#123; (void*)data,     V2P(data),     PHYSTOP,   PTE_W&#125;, // kern data+memory</span><br><span class="line"> &#123; (void*)DEVSPACE, DEVSPACE,      0,         PTE_W&#125;, // more devices</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记07-xv6-启动到执行第一个进程/1.JPG" title="Layout of a virtual address space">
<h1 id="启动多处理器"><a href="#启动多处理器" class="headerlink" title="启动多处理器"></a>启动多处理器</h1><p>（此部分待后续理解）<br>多处理器的启动是通过IPI，即Inter-Processor Instructions进行的，这是CPU间的通讯方式。startothers()来启动其他non-boot CPU，做法是：<br>复制启动代码到0x7000处，这部分代码相当于boot CPU的启动扇区代码。<br>为每个AP分配stack（是的，每个CPU都一个自己的stack）。<br>告诉每个AP，kernel入口在哪里(mpenter函数)。<br>告诉每个AP，页目录在哪里(entrypgdir)。<br>然后控制local apic进行CPU间通讯，依次启动其他CPU。启动之后他们会执行mpenter()，进而进入scheduler()开始执行程序。</p>
<h1 id="启动init进程"><a href="#启动init进程" class="headerlink" title="启动init进程"></a>启动init进程</h1><p>boot CPU启动其他CPU之后，自己继续执行kinit2()初始化剩余的内存空间，然后开始启动init进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">//proc.c</span><br><span class="line">//在进程表中寻找slot，成功的话更改进程状态embryo和pid，并初始化进程的内核栈</span><br><span class="line">static struct proc*</span><br><span class="line">allocproc(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p;</span><br><span class="line">  char *sp;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)</span><br><span class="line">    if(p-&gt;state == UNUSED)</span><br><span class="line">      goto found;</span><br><span class="line"></span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;state = EMBRYO;</span><br><span class="line">  p-&gt;pid = nextpid++;</span><br><span class="line"></span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  // Allocate kernel stack.</span><br><span class="line">  if((p-&gt;kstack = kalloc()) == 0)&#123;</span><br><span class="line">    p-&gt;state = UNUSED;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  sp = p-&gt;kstack + KSTACKSIZE;</span><br><span class="line"></span><br><span class="line">  // Leave room for trap frame.</span><br><span class="line">  sp -= sizeof *p-&gt;tf;</span><br><span class="line">  p-&gt;tf = (struct trapframe*)sp;</span><br><span class="line"></span><br><span class="line">  // Set up new context to start executing at forkret,</span><br><span class="line">  // which returns to trapret.</span><br><span class="line">  sp -= 4;</span><br><span class="line">  *(uint*)sp = (uint)trapret;</span><br><span class="line"></span><br><span class="line">  sp -= sizeof *p-&gt;context;</span><br><span class="line">  p-&gt;context = (struct context*)sp;</span><br><span class="line">  memset(p-&gt;context, 0, sizeof *p-&gt;context);</span><br><span class="line">  p-&gt;context-&gt;eip = (uint)forkret;</span><br><span class="line"></span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//PAGEBREAK: 32</span><br><span class="line">// Set up first user process.</span><br><span class="line">void</span><br><span class="line">userinit(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p;</span><br><span class="line">  extern char _binary_initcode_start[], _binary_initcode_size[];</span><br><span class="line"></span><br><span class="line">  //在进程表中寻找slot，成功的话更改进程状态和pid，并初始化进程的内核栈</span><br><span class="line">  p = allocproc();</span><br><span class="line">  </span><br><span class="line">  initproc = p;</span><br><span class="line">  //为进程创建内核页目录，根据kmap设定将所有涉及范围内的内核空间虚拟地址</span><br><span class="line">  //(从KERNBASE开始,把IO空间、内核镜像等都建立映射，这些空间全都是用户空间可见的，位于2GB以上)按页大小映射到物理地址上，</span><br><span class="line">  //实际上是创建二级页表，并在二级页表项上存储物理地址。</span><br><span class="line">  //每个进程都会新建页目录和二级页表</span><br><span class="line">  //页目录项所存页表的权限是用户可读写</span><br><span class="line">  //二级页表项所存物理页的权限按照kmap设定</span><br><span class="line">  if((p-&gt;pgdir = setupkvm()) == 0) //see in vm.c</span><br><span class="line">    panic(&quot;userinit: out of memory?&quot;); </span><br><span class="line">  //从kmem上分配一页的物理空间给进程，在新建进程的页目录上映射[0,PGSIZE]的虚拟地址到分配的物理地址上，将指向内容复制到物理内存上</span><br><span class="line">  //页目录项所存页表的权限是用户可读写</span><br><span class="line">  //二级页表项所存物理页的权限为用户可读写</span><br><span class="line">  inituvm(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);//see in vm.c</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  memset(p-&gt;tf, 0, sizeof(*p-&gt;tf));</span><br><span class="line">  p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER; // todo ???</span><br><span class="line">  p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER; // todo ???</span><br><span class="line">  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;</span><br><span class="line">  p-&gt;tf-&gt;eflags = FL_IF;//allow hardware interrupts</span><br><span class="line">  p-&gt;tf-&gt;esp = PGSIZE;</span><br><span class="line">  p-&gt;tf-&gt;eip = 0;  // beginning of initcode.S</span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, &quot;initcode&quot;, sizeof(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">  // this assignment to p-&gt;state lets other cores</span><br><span class="line">  // run this process. the acquire forces the above</span><br><span class="line">  // writes to be visible, and the lock is also needed</span><br><span class="line">  // because the assignment might not be atomic.</span><br><span class="line">  acquire(&amp;ptable.lock);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建进程数据结构"><a href="#创建进程数据结构" class="headerlink" title="创建进程数据结构"></a>创建进程数据结构</h2><p>allocproc()函数在全局变量ptable中寻找UNUSED的进程结构，如果找到就做必要的初始化，然后将其返回，否则返回0，即空指针。其初始化过程包括修改进程状态，设置进程pid，构建进程的kenel stack（每个进程都有一个对应的内核栈）。进程的内核栈是调用<strong>p-&gt;kstack = kalloc()</strong>分配的，而<strong>p-&gt;tf</strong>和<strong>p-&gt;context</strong>都在内核栈中。<strong>由上可知，进程结构体proc是在内核指令和数据所处的内存空间上，而内核栈是在end[]之后的内存空间上</strong>。<br>每个进程的创建都会调用allocproc()函数，不论是init进程还是fork创建的普通进程。调用allocproc()函数之后，进程的kernel stack初始化状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">                     +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                 |   | ss            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | esp           |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | eflags        |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | cs            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | eip           | &lt;-- 这里往上在iret时自动弹出到相关寄存器中</span><br><span class="line">                 |   +---------------+    </span><br><span class="line">                 |   | err           |  </span><br><span class="line">                 |   +---------------+  </span><br><span class="line">                 |   | trapno        |  </span><br><span class="line">                 |   +---------------+                       </span><br><span class="line">                 |   | ds            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | es            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | fs            |                           </span><br><span class="line">struct trapframe |   +---------------+                           </span><br><span class="line">                 |   | gs            |                           </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | eax           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ecx           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | edx           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ebx           |   </span><br><span class="line">                 |   +---------------+                        </span><br><span class="line">                 |   | oesp          |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ebp           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | esi           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | edi           |   </span><br><span class="line">                 \   +---------------+ &lt;-- p-&gt;tf                 </span><br><span class="line">                     | trapret       | &lt;-- 弹出进程tf，执行用户代码                           </span><br><span class="line">                 /   +---------------+ &lt;-- forkret will return to</span><br><span class="line">                 |   | eip(=forkret) | &lt;-- return addr，启动log           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | ebp           |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">  struct context |   | ebx           |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | esi           |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | edi           |                           </span><br><span class="line">                 \   +-------+-------+ &lt;-- p-&gt;context            </span><br><span class="line">                     |       |       |                           </span><br><span class="line">                     |       v       |                           </span><br><span class="line">                     |     empty     |                           </span><br><span class="line">                     +---------------+ &lt;-- p-&gt;kstack</span><br></pre></td></tr></table></figure></p>
<p>注意trapframe里的eip正是进入用户态之后执行的程序的入口，init进程跟普通进程<br>的差别就在这里了，init进程设置的eip=0（见userinit()函数，可知进程将分配一页空间来存放initcode的指令和数据，其虚拟地址范围为0x0:4K，因此eip=0则会跳转执行initcode的第一条指令），在此之前0这里已经放置了initcode.S的内容，而普通进程这里设置的是elf-&gt;entry，即程序的main()函数。</p>
<h2 id="构建进程地址空间"><a href="#构建进程地址空间" class="headerlink" title="构建进程地址空间"></a>构建进程地址空间</h2><p>userinit函数调用setupkvm函数为进程创建内核页目录，根据kmap设定将所有涉及范围内的内核空间虚拟地址(从KERNBASE开始,把IO空间、内核镜像等都建立映射，这些空间全都是用户空间可见的，位于2GB以上)按页大小映射到物理地址上，实际上是创建二级页表，并在二级页表项上存储物理地址。每个进程都会新建页目录和二级页表，页目录项所存页表的权限是用户可读写，二级页表项所存物理页的权限按照kmap设定。<strong>根据kmap把kernel也映射到进程空间的原因是：执行initcode代码前将切换为进程页目录，为了能继续执行内核代码，需要把kernel也映射到进程空间。</strong><br>之后userinit函数调用inituvm函数从kmem（end[]之后的内存空间）上分配一页的物理空间给进程，在新建进程的页目录上映射[0,PGSIZE]的虚拟地址到分配的物理地址上，将<code>_binary_initcode_start</code>指向内容复制到物理内存上。页目录项所存页表的权限是用户可读写，二级页表项所存物理页的权限为用户可读写。然后设置进程的tf值，这部分值将在执行trapret时弹出到相关寄存器中，将进程的状态更改为RUNNABLE。</p>
<h2 id="进入调度器开始执行"><a href="#进入调度器开始执行" class="headerlink" title="进入调度器开始执行"></a>进入调度器开始执行</h2><p>boot CPU继续执行进入scheduler()函数，它线性遍历ptable寻找RUNNABLE的进程，找到之后就执行，无穷循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//proc.c</span><br><span class="line">void</span><br><span class="line">scheduler(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct proc *p;</span><br><span class="line"></span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    // Enable interrupts on this processor.</span><br><span class="line">    //进程开中断</span><br><span class="line">    sti();</span><br><span class="line"></span><br><span class="line">    // Loop over process table looking for process to run.</span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class="line">      if(p-&gt;state != RUNNABLE)</span><br><span class="line">        continue;</span><br><span class="line"></span><br><span class="line">      // Switch to chosen process.  It is the process&apos;s job</span><br><span class="line">      // to release ptable.lock and then reacquire it</span><br><span class="line">      // before jumping back to us.</span><br><span class="line">      //更新全局变量proc为当前被选中的进程</span><br><span class="line">      proc = p;</span><br><span class="line">      //设置cpu环境后，加载选中进程的页目录地址到cr3,切换为进程的页目录</span><br><span class="line">      switchuvm(p); //see in vm.c</span><br><span class="line">      //更改进程状态为running</span><br><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line">      swtch(&amp;cpu-&gt;scheduler, p-&gt;context); //see in swtch.S</span><br><span class="line">      //调用swtch之后将不会返回内核，但会将下一条指令的eip进栈，swtch会保存context寄存器，并将cpu-&gt;scheduler指向保存位置，程序执行完毕后应该会返回执行内核代码，重新调度下一个进程。（中断时会执行相关中断处理函数，不会返回这里。）</span><br><span class="line">      //加载内核的页目录地址到cr3,切换为内核的页目录</span><br><span class="line">      switchkvm(); //see in vm.c</span><br><span class="line"></span><br><span class="line">      // Process is done running for now.</span><br><span class="line">      // It should have changed its p-&gt;state before coming back.</span><br><span class="line">      proc = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vm.c</span><br><span class="line">// 设置cpu环境后，加载进程的页目录地址到cr3</span><br><span class="line">void</span><br><span class="line">switchuvm(struct proc *p)</span><br><span class="line">&#123;</span><br><span class="line">  pushcli();</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;cpu-&gt;ts, sizeof(cpu-&gt;ts)-1, 0);</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS].s = 0;</span><br><span class="line">  cpu-&gt;ts.ss0 = SEG_KDATA &lt;&lt; 3;</span><br><span class="line">  cpu-&gt;ts.esp0 = (uint)proc-&gt;kstack + KSTACKSIZE;</span><br><span class="line">  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span><br><span class="line">  // forbids I/O instructions (e.g., inb and outb) from user space</span><br><span class="line">  cpu-&gt;ts.iomb = (ushort) 0xFFFF;</span><br><span class="line">  ltr(SEG_TSS &lt;&lt; 3);</span><br><span class="line">  if(p-&gt;pgdir == 0)</span><br><span class="line">    panic(&quot;switchuvm: no pgdir&quot;);</span><br><span class="line">  lcr3(V2P(p-&gt;pgdir));  // switch to process&apos;s address space</span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>switchuvm(p)，它会设置TSS段并且将其中的ss0设置为SEG_KDATA，把esp0设置成p-&gt;kstack+KSTACKSIZE，也就是该进程内核栈的栈底，然后<code>ltr(SEG_TSS&lt;&lt;3)</code>，这会让CPU在执行iret时使用该TSS的内容。设置ss0，esp0的意思是：该进程以后被中断或者trap时，只要进入kernel，就使用这个stack，上述代码表明<strong>trap时将使用进程的内核栈</strong>。然后切换到进程页目录，注意，因为kernel空间也映射进用户也目录了，所以kernel在切换页目录之后依然正常执行，<strong>此时仍然使用的是CPU栈</strong>。标记进程状态为RUNNING之后开始执行swtch，看<code>swtch(&amp;cpu-&gt;scheduler, p-&gt;context);</code>。注意到swtch会将当前context相关寄存器进栈，然后将cpu的context（即scheduler）指针指向当前esp（仍然是cpu栈，即在内核的指令和数据内存空间上），再将esp指向到进程的context，由于会改变cpu的scheduler指针指向，因此需要传递<strong>&amp;cpu-&gt;scheduler</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//swtch.S</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl 4(%esp), %eax #load *(esp + 4) into eax, that is &amp;cpu-&gt;scheduler, pointer&apos;s addr</span><br><span class="line">  movl 8(%esp), %edx #load *(esp + 8) into edx, that is p-&gt;context, pointer&apos;s value</span><br><span class="line"></span><br><span class="line">  # Save old callee-save registers #进入swtch函数之前，eip已经进栈</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)  #cpu-&gt;scheduler现在指向了当前cpu栈顶，保存了相关context寄存器</span><br><span class="line">  movl %edx, %esp  #esp指向进程的context</span><br><span class="line"></span><br><span class="line">  # Load new callee-save registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure></p>
<p><strong>swtch的作用是保存相关context寄存器到cpu栈，将当前cpu的scheduler指向保存位置，然后将栈顶指针指向进程的context（进程的内核栈），将相关寄存器弹出之后执行ret指令，由于此时esp指向进程context的eip，因此将从栈中弹出该数据作为eip。该eip实际指向forkret函数入口地址，不同于call指令，调用该函数不会将下一条指令的地址进栈。因此后面forkret启动了一个log之后返回时将继续弹栈作为新的eip，即trapret地址，见tramasm.S。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//trapasm.S</span><br><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">  popal #弹出通用寄存器中的上下文环境</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl $0x8, %esp  # trapno and errcode</span><br><span class="line">  iret</span><br></pre></td></tr></table></figure></p>
<p>popal弹出一堆寄存器值，其中部分寄存器值在userinit函数中被指定了，如cs。popl又弹出一堆，然后<strong>addl $0x8, %esp</strong>越过trapno和errcode，此时esp指向进程tf的eip。执行iret时会把int指令自动压栈的内容再自动恢复回去，这里是eip、cs、eflags、esp、ss。eip在userinit函数中被设置为0，此处已经被inituvm()放置上initcode.S的内容了；esp在userinit函数中被设置为PGSIZE，即进程分配到的物理地址空间的顶部，此处作为栈顶（<strong>由此可以看出esp的地址也是虚拟地址，将根据进程页目录和页表被转化为物理地址</strong>）。之后回到用户空间的起始地址处执行initcode.S的内容。这个文件通过系统调用exec执行/init程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//initcode.S</span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  pushl $argv</span><br><span class="line">  pushl $init</span><br><span class="line">  pushl $0  // where caller pc would be</span><br><span class="line">  movl $SYS_exec, %eax</span><br><span class="line">  int $T_SYSCALL</span><br><span class="line"></span><br><span class="line">//exec指令用新程序替代当前进程的内存和寄存器，但保留文件描述符、进程id、父进程不变。如果一切运行正常，exec将不会返回到这里，它将执行一个新的名为$init的程序。init进程根据需要创建终端设备文件，以文件描述符0、1、2打开它，然后循环开启一个控制台shell、处理孤立僵尸进程直到shell退出，重复循环。整个系统启动。</span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">  movl $SYS_exit, %eax</span><br><span class="line">  int $T_SYSCALL</span><br><span class="line">  jmp exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure></p>
<p>$argv、$init、$0将被存储在进程物理空间顶部。<code>movl $SYS_exec, %eax</code>把trapno放到%eax里面，之后int的时候会跳转到alltraps，其会执行pushal将包括eax在内的通用寄存器进栈（其实是保存到proc-&gt;tf），之后在类似syscall函数就可以通过proc-&gt;tf-&gt;eax获取trapno了。此时的esp指向0x00000ff4，根据initcode.asm可知int指令的下一条指令地址（即执行int时的eip为）0x00000013。<br>CPU在执行int指令时会执行以下动作：<br>1、栈转换，stack转换到tr寄存器指定的tss里面的ss0:esp0，这是该进程对应的内核栈，esp指向内核栈栈顶。<br>2、自动将相关寄存器的内容进栈：ss、esp、eflag、cs、eip。<br>3、跳转到中断处理程序处（trap.c），也就是vectorXXX处，这里为每个中断设置了一个中断处理程序，xv6的中断处理表是用vector.pl生成的(make之后见vectors.S)，基本每个表项都是一样的。<br>（上述动作还应包含触发中断时的权限检查。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.globl vector64</span><br><span class="line">vector64:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $64</span><br><span class="line">  jmp alltraps</span><br></pre></td></tr></table></figure></p>
<p>内核栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CPU执行int指令时自动压栈的，加上中断处理程序压栈</span><br><span class="line">                      +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                      | ss            |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | esp           | &lt;-- 0x00000ff4(压进三个参数)                          </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | eflags        |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | cs            |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | eip           | &lt;-- 0x00000013(int指令的下一条指令地址)</span><br><span class="line">                      +---------------+ </span><br><span class="line">                      | err           |</span><br><span class="line">                      +---------------+</span><br><span class="line">                      | trapno        |</span><br><span class="line">                      +---------------+ &lt;-- %esp</span><br></pre></td></tr></table></figure></p>
<p>跳转到alltrap处执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  # vectors.S sends all traps here.</span><br><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">  # Build trap frame. //将用户进程的寄存器保存</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal</span><br><span class="line">  </span><br><span class="line">  # Set up data and per-cpu segments.</span><br><span class="line">  #此时已经由p-&gt;tf-&gt;esp指向的进程用户栈切换到ssX:espX指定的栈中，</span><br><span class="line">  #这里是p-&gt;kstack指向的进程内核栈，当前进程相关的寄存器保存到了进程内核栈中。</span><br><span class="line">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es</span><br><span class="line">  movw $(SEG_KCPU&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %fs</span><br><span class="line">  movw %ax, %gs</span><br><span class="line"></span><br><span class="line">  # Call trap(tf), where tf=%esp</span><br><span class="line">  pushl %esp #push %esp的原因是将当前esp指向的tf结构基地址作为传递的参数</span><br><span class="line">  call trap</span><br><span class="line">  addl $4, %esp</span><br><span class="line"></span><br><span class="line">  # Return falls through to trapret...</span><br><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">  #主要是弹出保存在ssX:espX指定的栈中的进程相关的寄存器，返回执行进程代码。</span><br><span class="line">  #第一次切换到用户态执行代码时，ssX:espX指定的栈中的进程相关的寄存器是在userinit函数中指定的。</span><br><span class="line">  popal #弹出通用寄存器中的上下文环境</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl $0x8, %esp  # trapno and errcode</span><br><span class="line">  iret</span><br></pre></td></tr></table></figure></p>
<p>alltraps将进程相关的寄存器压入到ssX:espX指定的栈中，这里是p-&gt;kstack指向的进程内核栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">                 /   +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                 |   | ss            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | esp           |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | eflags        |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | cs            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | eip           | &lt;-- 这里往上在iret时自动弹出到相关寄存器中</span><br><span class="line">                 |   +---------------+    </span><br><span class="line">                 |   | err           |  </span><br><span class="line">                 |   +---------------+  </span><br><span class="line">                 |   | trapno        |  </span><br><span class="line">                 |   +---------------+                       </span><br><span class="line">                 |   | ds            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | es            |                           </span><br><span class="line">                 |   +---------------+                           </span><br><span class="line">                 |   | fs            |                           </span><br><span class="line">struct trapframe |   +---------------+                           </span><br><span class="line">                 |   | gs            |                           </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | eax           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ecx           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | edx           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ebx           |   </span><br><span class="line">                 |   +---------------+                        </span><br><span class="line">                 |   | oesp          |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | ebp           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | esi           |   </span><br><span class="line">                 |   +---------------+   </span><br><span class="line">                 |   | edi           |   </span><br><span class="line">                 \   +---------------+ &lt;-- %esp</span><br></pre></td></tr></table></figure></p>
<p>然后执行<strong>pushl %esp</strong>为trap()函数准备参数，调用trap()函数，处理所有的中断、trap，参数是一个trapframe。完成后弹出之前压栈的参数，%esp又指向trapframe结构了。到此为止，系统调用的实质工作已经完成了，接下来就要返回用户态了，也就是trapret，把进程状态相关的寄存器恢复回去。iret指令把int自动压栈的内容再自动恢复回去，这样程序就回到eip处了，即中断发生的指令处。 </p>
<h2 id="系统调用的执行结果和参数"><a href="#系统调用的执行结果和参数" class="headerlink" title="系统调用的执行结果和参数"></a>系统调用的执行结果和参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//syscall.c</span><br><span class="line">void</span><br><span class="line">syscall(void)</span><br><span class="line">&#123;</span><br><span class="line">  int num; </span><br><span class="line">  num = proc-&gt;tf-&gt;eax;</span><br><span class="line">  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    proc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    //cprintf(&quot;\n%s -&gt; %d\n&quot;, syscall_name[num], proc-&gt;tf-&gt;eax);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cprintf(&quot;%d %s: unknown sys call %d\n&quot;,</span><br><span class="line">            proc-&gt;pid, proc-&gt;name, num);</span><br><span class="line">    proc-&gt;tf-&gt;eax = -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inidcode.S执行<code>movl $SYS_exec, %eax</code>把trapno放到%eax里面，之后int的时候会跳转到alltraps，其会执行pushal将包括eax在内的通用寄存器进栈（其实是保存到proc-&gt;tf），之后在syscall函数就可以通过proc-&gt;tf-&gt;eax获取trapno了。而系统调用的执行结果也放在了eax中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//syscall.c</span><br><span class="line">// 获取第n个32-bit参数</span><br><span class="line">int</span><br><span class="line">argint(int n, int *ip)</span><br><span class="line">&#123;</span><br><span class="line">  return fetchint(proc-&gt;tf-&gt;esp + 4 + 4*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考argint等函数，可知道系统调用的参数保存在tf-&gt;esp指向的进程用户栈中，userinit函数中将其指向进程数据和指令物理内存空间的顶端PAGESIZE，initcode传递的参数保存在这里。</p>
<h2 id="以下是scheduler调度器调用swtch函数到initcode调用的第一个系统调用结束的栈变化。"><a href="#以下是scheduler调度器调用swtch函数到initcode调用的第一个系统调用结束的栈变化。" class="headerlink" title="以下是scheduler调度器调用swtch函数到initcode调用的第一个系统调用结束的栈变化。"></a>以下是scheduler调度器调用swtch函数到initcode调用的第一个系统调用结束的栈变化。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//设置cpu环境后，加载选中进程的页目录地址到cr3，切换为进程的页目录。此时仍然使用的是cpu栈（即在内核的指令和数据内存空间上），且由于内核空间映射到了进程页目录中，所以仍可执行内核代码。</span><br><span class="line">当前是swtch阶段，保存当前cpu的context，并将栈顶指针指向进程的context，以下是cpu栈：</span><br><span class="line">                      +---------------+ &lt;-- $(stack + KSTACKSIZE)(see in entry.S)</span><br><span class="line">                      | ...           |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | p-&gt;context    |                            </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      |&amp;cpu-&gt;scheduler|                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | eip           | &lt;-- 调用swtch函数的下一条指令 </span><br><span class="line">                      +---------------+      </span><br><span class="line">                      | ebp           | &lt;-- see in swtch.S </span><br><span class="line">                      +---------------+ </span><br><span class="line">                      | ebx           |</span><br><span class="line">                      +---------------+</span><br><span class="line">                      | esi           |</span><br><span class="line">                      +---------------+</span><br><span class="line">                      | edi           |</span><br><span class="line">                      +---------------+ &lt;-- %esp</span><br><span class="line">esp此时指向上面四个寄存器信息，现在改变cpu-&gt;scheduler指针的指向（指向位置仍然是cpu栈的某个单元），使其指向esp的位置。即让cpu的context变量保存了当前的cpu寄存器状态。</span><br><span class="line">然后esp指向进程的context，其位于进程内核栈内。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//当前是swtch阶段，栈顶指针指向进程的context，将相关寄存器弹出之后执行ret指令，从栈中弹出数据作为eip，进程context的eip指向forkret函数入口地址。</span><br><span class="line">//forkret启动了一个log之后返回时将继续弹栈作为新的eip（不同于call指令，调用该函数不会将下一条指令的地址进栈。），即trapret地址。转入trapret阶段，弹出已设定的进程状态相关寄存器，由内核态切换到用户态，执行iret指令后开始执行用户代码。这时候esp指针将指进程的用户栈，其位于所分配的进程指令和数据物理地址空间（一页）的顶端。以下是进程内核栈：</span><br><span class="line"></span><br><span class="line">                      +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                  |   | ss            | &lt;-- (SEG_UDATA &lt;&lt; 3) | DPL_USER;  </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | esp           | &lt;-- PGSIZE                          </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | eflags        | &lt;-- FL_IF(allow hardware interrupts)                          </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | cs            | &lt;-- (SEG_UCODE &lt;&lt; 3) | DPL_USER;</span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | eip           | &lt;-- 0(init进程)/main函数入口(其他进程)</span><br><span class="line">                  |   +---------------+ &lt;-- 这里往上在iret时自动弹出到相关寄存器中 </span><br><span class="line">                  |   | err           |  </span><br><span class="line">                  |   +---------------+  </span><br><span class="line">                  |   | trapno        |  </span><br><span class="line">                  |   +---------------+                       </span><br><span class="line">                  |   | ds            | &lt;-- (SEG_UDATA &lt;&lt; 3) | DPL_USER;</span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | es            | &lt;-- (SEG_UDATA &lt;&lt; 3) | DPL_USER; </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | fs            |                           </span><br><span class="line"> struct trapframe |   +---------------+                           </span><br><span class="line">                  |   | gs            |                           </span><br><span class="line">                  |   +---------------+  第一次切换到用户态执行代码前，trapframe </span><br><span class="line">                  |   | eax           |   </span><br><span class="line">                  |   +---------------+  的值是在userinit函数中指定的 </span><br><span class="line">                  |   | ecx           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | edx           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | ebx           |   </span><br><span class="line">                  |   +---------------+                        </span><br><span class="line">                  |   | oesp          |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | ebp           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | esi           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | edi           |   </span><br><span class="line">                  \   +---------------+ &lt;-- p-&gt;tf                 </span><br><span class="line">                      | trapret       | &lt;-- 跳转到trapret，由allocproc()设置</span><br><span class="line">                  /   +---------------+ &lt;-- forkret返回</span><br><span class="line">                  |   | eip(=forkret) | &lt;-- 由allocproc()设置         </span><br><span class="line">                  |   +---------------+ &lt;-- 执行ret指令，forkret启动log</span><br><span class="line">                  |   | ebp           |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">   struct context |   | ebx           |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | esi           |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | edi           |                           </span><br><span class="line">                  \   +-------+-------+ &lt;-- p-&gt;context, %esp            </span><br><span class="line">                      |       |       |                           </span><br><span class="line">                      |       |       |                           </span><br><span class="line">                      |     empty     |                           </span><br><span class="line">                      +---------------+ &lt;-- p-&gt;kstack</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//当前是initcode阶段，esp指向了进程的用户栈，参数进栈，然后执行int指令调用系统调用。以下是进程的用户栈：</span><br><span class="line"></span><br><span class="line">                      +---------------+ &lt;-- stack base(PGSIZE)</span><br><span class="line">                      | $argv         |   </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | $init         |                            </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | $0            |                             </span><br><span class="line">                      +-------+-------+ &lt;-- %esp            </span><br><span class="line">                      |       |       |                           </span><br><span class="line">                      |       |       |                           </span><br><span class="line">                      |       |       |                           </span><br><span class="line">                      +---------------+ &lt;-- 0，initcode的代码放置在此</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//当前是int阶段，stack转换到tr寄存器指定的tss里面的ss0:esp0，这是该进程对应的内核栈。自动将进程相关寄存器的内容进栈：ss、esp、eflag、cs、eip，这样返回用户态之后才能恢复执行。然后跳转到中断处理程序处，将errcode和trapno压栈，再跳转到alltraps处。以下是进程的内核栈：</span><br><span class="line"> </span><br><span class="line">                      +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                      | ss            |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | esp           | &lt;-- 0x00000ff4(压进三个参数)    </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | eflags        |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | cs            |                           </span><br><span class="line">                      +---------------+                           </span><br><span class="line">                      | eip           | &lt;-- 0x00000013(int指令的下一条指令地址)</span><br><span class="line">                      +---------------+ </span><br><span class="line">                      | err           |</span><br><span class="line">                      +---------------+</span><br><span class="line">                      | trapno        |</span><br><span class="line">                      +---------------+ &lt;-- %esp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//当前是alltraps阶段，将用户进程的寄存器保存到进程内核栈中，构成tramframe，由用户态切换到内核态。push %esp，将当前esp指向的tf结构基地址作为传递的参数，调用trap函数。以下是内核栈：</span><br><span class="line"></span><br><span class="line">                  /   +---------------+ &lt;-- stack base(= p-&gt;kstack + KSTACKSIZE)</span><br><span class="line">                  |   | ss            |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | esp           | &lt;-- 0x00000ff4(压进三个参数)    </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | eflags        |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | cs            |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | eip           | &lt;-- 0x00000013(int指令的下一条指令地址)</span><br><span class="line">                  |   +---------------+ </span><br><span class="line">                  |   | err           |</span><br><span class="line">                  |   +---------------+</span><br><span class="line">                  |   | trapno        |</span><br><span class="line">                  |   +---------------+     </span><br><span class="line">                  |   | ds            |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | es            |                           </span><br><span class="line">                  |   +---------------+                           </span><br><span class="line">                  |   | fs            |                           </span><br><span class="line"> struct trapframe |   +---------------+                           </span><br><span class="line">                  |   | gs            |                           </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | eax           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | ecx           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | edx           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | ebx           |   </span><br><span class="line">                  |   +---------------+                        </span><br><span class="line">                  |   | oesp          |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | ebp           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | esi           |   </span><br><span class="line">                  |   +---------------+   </span><br><span class="line">                  |   | edi           |   </span><br><span class="line">                  \   +---------------+   </span><br><span class="line">                      | esp           |  </span><br><span class="line">                      +---------------+ &lt;-- %esp</span><br></pre></td></tr></table></figure>
<p>trap阶段将会使用内核栈，而系统调用所传递的参数将由p-&gt;tf-&gt;esp处取得，这个位置一开始指向了虚拟地址0xPAGE处，即进程的用户栈。系统调用的工作完成后，跳过之前压栈的参数esp，由内核态切换到用户态，弹出保存在ssX:espX指定的栈中的进程相关的寄存器，返回执行进程代码。<br>上述所有阶段关于栈的变化是：<br><strong>切换到进程页目录/使用cpu栈–swtch切换到进程的内核栈–trapret根据设定切换内核态为用户态/使用进程的用户栈–initcode.S调用系统调用切换到进程的内核栈–alltraps保存进程寄存器并切换用户态为内核态–执行系统调用后trapret出栈进程相关的寄存器切换内核态为用户态/使用进程的用户栈</strong></p>
<h2 id="exec执行“-init”程序。"><a href="#exec执行“-init”程序。" class="headerlink" title="exec执行“/init”程序。"></a>exec执行“/init”程序。</h2><p>进入系统调用时，stack转换到tr寄存器指定的tss里面的ss0:esp0，即该进程对应的内核栈。exec将会执行新程序，替换掉当前执行的用户程序，执行“/init”程序具体如下：1、根据“/init”路径查找对应的inode；2、根据inode读取程序的elf信息；3、调用setupkvm()创建页目录，并映射内核空间（页目录项所存页表的权限是用户可读写，二级页表项所存物理页的权限按照kmap设定）；4、根据inode和elf程序头表偏移量，按段读取程序。每次循环时：4.1、先读取段的程序头表项，程序头表项包含段的虚拟地址及段占据的内存大小，4.2、根据信息调用allocuvm()分配出物理空间，分配过程会将程序的虚拟地址映射到分配到的物理页地址上，二级页表项所存物理页的权限是用户可读写，4.3、根据程序头表项信息（段偏移及段的文件大小）读取段到内存中；5、继续为程序分配两页物理空间，二级页表项所存物理页的权限是用户可读写，取消第一页用户可读写权限，第二页将作为用户栈。6、构建用户栈数据（参数等，见下）；7、更新进程的页目录、用户空间size、进程的tf-&gt;eip为elf.entry(main)、tf-&gt;esp为用户栈指针当前位置，然后调用switchuvm()函数设置cpu环境，加载进程的页目录地址到cr3，释放旧页目录空间；8、返回trapret处，切换为用户态，返回执行init程序代码，不返回initcode.S。<br><img src="/2017/08/20/笔记07-xv6-启动到执行第一个进程/2.JPG" title="构建用户栈数据"><br>由此可以注意到，exec改变的有<strong>进程的页目录、用户空间内容、用户空间size、进程的tf-&gt;eip、tf-&gt;esp、用户栈、进程名</strong>，没有改变的有<strong>进程文件描述符、进程pid、父进程、内核栈、进程状态、当前目录</strong>等。  </p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p><strong>进程的内核栈有没有设置访问权限？</strong><br>所谓的访问权限指的是进程页目录、二级页表的权限。自始自终进程的内核栈都没有映射进页目录，所以不存在设置访问权限的问题，从进程用户的角度来讲，它是无法访问到进程的内核栈的，这是由内核维护的。</p>
<h1 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h1><p><code>各种寄存器的作用？</code>   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
