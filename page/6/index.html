<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="tWqzAeLYHxufjgoQXpm3qh6YTje2bah03cY7dTfBvWw">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝色步行者">
<meta property="og:url" content="http://www.jianzzz.com/page/6/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓝色步行者">
<meta name="twitter:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/page/6/">





  <title>蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记05-Lab2-Memory-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记05-Lab2-Memory-Management/" itemprop="url">笔记05 - Lab2: Memory Management</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:08:04+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>程序的几乎所有代码都集中在 pmap.c 文件中。此部分为物理页面管理，强调对机器拥有的物理内存的管理，包括建立对应的数据结构、处理分配和回收动作等。需要完成<code>boot_alloc()</code>、<code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)、<code>page_init()</code>、<code>page_alloc()</code>、<code>page_free()</code>等函数。</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>JOS 的启动过程实际上是先把 bootsector 的内容读到 0x7c00 处 （注意，bootsector 的代码在编译的时候已经故意地把逻辑地址的首地址定在了 0x7c00 上），bootsector 中的代码开始执行后，会从磁盘上紧接着自己的第 2 个扇区开始，一直读 8 个扇区的内容（一共是 8×512=4KB， ELF 头的大小）到 0x10000（64KB）的地方，然后，通过对 ELF 头的解析，得到 kernel 模块编译出来后所占的大小，并将 kernel 读到物理内存 0x100000（1MB）开始的地方。然后加载 <code>entry_pgdir</code> 的物理地址到 cr3 中开启分页，并调用 <code>i386_init()</code> 函数，而 <code>i386_init()</code> 函数在将自己的 BSS 区域清零后，调用 <code>cons_init()</code> 函数设置好屏幕显示设备为 cprintf 的运行做好准备后就调用 <code>mem_init()</code> 函数。 <code>mem_init();</code> 函数调用 <code>i386_detect_memory();</code> 函数读 CMOS 取得物理内存的实际大小。<code>i386_init()</code> 函数最后会调用 <code>monitor(NULL);</code> 并进入循环，处理用户通过终端输入的命令。<br>在调用 <code>i386_init()</code> 函数以前，内存分布如下所示：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/1.JPG" title="在调用i386_init函数以前内存分布"></p>
<h2 id="以下是物理内存管理设计思想"><a href="#以下是物理内存管理设计思想" class="headerlink" title="以下是物理内存管理设计思想"></a>以下是物理内存管理设计思想</h2><p>调用<code>i386_detect_memory()</code>函数获取到物理内存的基本内存页数和总内存页数（包括扩展内存）。  </p>
<p>调用<code>boot_alloc()</code>函数为页目录分配 4KB 的空间。外部字符数组变量 edata 和 end，其中 edata 表示的是 bss 节起始位置（虚拟地址），而 end 则是表示内核可执行程序结束位置（虚拟地址）。<code>boot_alloc()</code>函数从 end 表示的位置（注意是<strong>线性地址</strong>）开始进行 4K 位置对齐，然后分配足够页空间。nextfree 表示空闲的线性地址，npages 表示总内存页数。根据<code>(uint32_t)nextfree - KERNBASE &gt; npages * PGSIZE</code>判断是否越界。每次分配后对 nextfree 进行 4K 对齐。</p>
<p>使用<code>boot_alloc()</code>函数分配 pages 结构体数组空间(struct PageInfo 类型)，共 npages 项，将其清零，后续将从该数组空间中动态分配出页空间（<strong>比如分配页存储页表等</strong>）。pages 数组与实际物理空间存在映射关系，不需要通过pages 数组存储物理页位置。struct PageInfo 包括 <code>pp_link</code> 和 <code>pp_ref</code>， <code>pp_ref</code>标识页空间是否可用，<code>pp_link</code>用于回溯前一个空闲的PageInfo，形成双向列表（具体见<code>page_init()</code>）。pages 始终指向页空间首位置，使用下标向后访问所有可用/不可用内存；<code>page_free_list</code> 始终指向可用页空间的末尾位置，往回指的指针 <code>pp_link</code> 要越过非空物理页,这样 <code>page_free_list</code> 才能通过 <code>pp_link</code> 往回获取空闲空间。<strong>由此可知， PageInfo 结构体数组空间是连续的，对于每次分配出的PageInfo指针，都可以计算出其与数组头之间的偏移，从而计算出当前是分配到第几页物理页；另一方面，从<code>page_free_list</code>角度看，连续的 PageInfo 结构体数组空间又是由指针回溯的不连续空间，从而可以自由合并和分出PageInfo空间。</strong></p>
<p>关于内存可用与否：<br>第一页数据是被使用的，该页保存了实模式IDT和BIOS数据结构。<br>第二页至基本内存结束位置(640K)是可用的。<br>[IOPHYSMEM, EXTPHYSMEM)即[0x0A0000,0x100000)即[640K,1MB)是被使用的。<code>io_hole</code> = 96 pages。<br>扩展内存开始位置至当前 pages 数组存储的末端为不可使用的部分（准确来说应该是使用 <code>boot_alloc(0)</code> 获取得到的线性地址，此线性地址才是代表 <code>boot_alloc()</code> 后 4K 对齐的位置），<code>boot_alloc(0)</code> 的线性地址开始至可用内存末端即为可用的。<br>注意：扩展内存开始位置为 1M，内核代码存放于 0x100000 处，即 1M 处，KERNBASE 是内核代码存储起点的线性地址。对于存于物理地址 1M 后的数据，其线性地址减去 KERNBASE 的值相当于该处与内核代码存储起点线性地址位置的差，而不是与 0x0 的差, 需要加上 1M 的空间，即 256 page。</p>
<p><code>page_alloc()</code>函数将从 pages 数组空间中由后往前分配，通过使用 <code>page_free_list</code> 指针和 <code>pp_link</code> 成员。当传入参数标识非 0 时，分配的空间将被清零。虽然一开始 pages 数组空间被清零，但此刻分配的空间可能是之前被使用后回收的，不一定为空。<br><code>page_free()</code>函数回收页空间，将<code>page_free_list</code>指向回收的空间。</p>
<h1 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h1><p>通过 Part1 的几个函数，我们得以在可用内存空间上调用<code>boot_alloc()</code>函数分配足够的页对齐的空间大小，并且通过映射物理页使用情况的 pages 数组来分配二级页表页和索引页目录项到该二级页表页，以及分配物理页和索引二级页表项到该物理页。</p>
<h2 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h2><p>1、x86的虚拟地址包括段选择子和偏移部分，经过段地址转换以后，获得线性地址，再经过页地址转换以后，获得物理地址。<br>2、<strong>一个C指针就是代表虚拟地址的偏移地址部分。</strong><br>3、boot/boot.S对GDT表进行设置，其中所有段基址设为0，段限长设为0xffffffff，因此段选择子部分失去了对段地址转换的影响，线性地址等于偏移地址（那也就是说一个C指针就是代表线性地址？）。<br>在内核还没动态创建页目录和页表之前，为了能在0xf0100000地址上运行内核代码，jos通过手写、静态初始化页目录和页表映射了前4M内存空间。而lab2实验则是动态映射物理地址空间的低256MB（0x00000000 - 0x0fffffff）到线性地址（0xf0000000 - 0xffffffff）。<br>4、qemu使用<code>info pg</code>命令可以查看当前页表的详细信息，包括映射的内存范围、权限以及标识。<code>info mem</code>命令概述了哪个范围的虚拟地址被映射，以及其权限。<br>5、页目录所在的物理页面的首地址在启动 x86 的页式地址管理前，需要放到 CR3 中，这样 x86 在进行页式地址转换时会自动地从 CR3 中取得页目录地址，从而找到当前的页目录。<br>6、在现代操作系统中，我们经常可以听到“用户进程的虚地址空间为 4GB”的说法，怎么来实现呢？原理其实很简单：为每个用户进程创建一个页目录，并将这个页目录保存到用户进程的上下文中，当该用户进程被切换过来执行的时候，就将该用户进程的页目录地址写入 CR3，并重新启动一次页式内存管理。当然如果采用这种方式，势必占用更多的内存用于页式地址变换。对于老版本的 Linux 系统以及我们现在接触的 JOS 系统， 为了避免太大的内存开销（另一个原因是因为还没有虚拟内存的支持），在整个系统中只使用一个内核页目录。这就意味着，整个系统的线性地址空间只有 4GB，而且是所有（操作系统内核、各个用户程序）代码所公用的！这种情况下，就必须对线性地址进行合理的规划了。<br>7、对于页式地址管理，由于页目录以及页表都存放在物理内存的页面中，要进行地址变换先要到内存中访问页目录和页表。由于 CPU 和内存速度的不匹配，为了最小化用于地址转换的总线周期， x86 系统中设计了用于地址翻译的缓存来解决这一问题，这一缓存称为 TLB（ Translation Look-aside buffer，即旁路转换缓冲，或称为页表缓冲，或转换后备缓冲区），在该缓存中存放了最近访问的页目录和页表条目，由于程序执行的局部性原理，下一次的地址转换往往跟上一次的地址转换采用的是同一个页目录表项和页表项），同时，由于 TLB 跟处理器的距离更近，这样就极大地提高了地址翻译的效率和速度。但是，这样做可能存在一个潜在的问题：页目录（表）数据项的不一致性。以前系统里对应一个线性地址只有唯一的存放在内存中的页目录和页表，用于完成翻译的工作，但是现在由于 TLB 的存在，系统可能在高速缓存中也存放了一份页表项数据，用于更快地对地址进行翻译。因为 TLB 中的数据对于程序员来说是不可见的，程序对于页表项或者页目录项的修改并不能马上反映到 TLB 中，这样就可能导致错误的地址翻译，因为为了提高翻译的速度，处理器总是尽量地采用 TLB 中的页表数据进行地址的翻译。所以，为了避免这种数据的不一致性所导致的地址翻译的错误情形的出现，系统程序员就必须在对页表进行修改后使 TLB 中旧的页表数据失效。使其失效的办法有两个，一个是重载 CR3，使整个 TLB 中的数据都失效，也可以采用 invlpg 指令。</p>
<p>以下是线性地址到物理页映射的设计思想：<br><code>pgdir_walk()</code>函数根据线性地址返回二级页表项入口。首先获取页目录项位置，使用指针指向其索引位置。如果页目录项不存在二级页表映射，且create标识为0，则返回NULL。否则使用<code>page_alloc</code>函数分配页表空间，分配失败则返回NULL，否则将分配的PageInfo结构体引用加1，并将其对应的物理页地址和权限（<strong>二级页表权限设为 kern R/W, user R/W</strong>）存在页目录项中。二级页表物理地址是4K对齐的，将其低12位清零然后转化为内核地址，使用指针指向它。<strong>注意到页目录和页表存的是物理地址，而指向页目录和页表的指针需要使用逻辑地址。</strong>最后根据指向二级页表的指针和通过线性地址求得的二级页表项索引，返回指向二级页表项的指针。<code>pgdir_walk()</code>只负责创建二级页表，然后返回指向二级页表项的指针，不对二级页表做处理，也不做其对物理页映射。我们知道，pages结构体数组是用于映射所有内存空间的，<code>page_free_list</code>指针指向的结构体所映射的内存空间均可用。<code>page_alloc</code>函数将从 pages 数组空间中分配可用空间，结构体映射的物理页地址将作为线性地址的页表，将其存储到页目录里。</p>
<p><code>page_lookup()</code>函数根据线性地址返回二级页表项所指的物理页对应的PageInfo数据结构。<code>pte_t **pte_store</code>存储的是二级页表项的地址（传递过来的是某个指针的地址，对于那个指针来说，函数执行后它就指向对应的二级页表项了），设计这个指针的含义是：当通过<code>page_remove()</code>移除线性地址对应的物理页时，可以清空二级页表项的内容。<code>page_lookup()</code>函数调用<code>pgdir_walk()</code>获得指向二级页表项的指针，不允许创建二级页表。如果页目录项不存在二级页表映射且不允许创建二级页表，或者没有空间分配二级页表，<code>pgdir_walk()</code>会返回NULL，则<code>page_lookup()</code>返回NULL。如果获得的二级页表项不存在物理页映射，则<code>page_lookup()</code>返回NULL。否则将二级页表项的地址存于<code>pte_t **pte_store</code>，<code>pgdir_walk()</code>返回的二级页表项指针内容是所指的物理页物理地址，将其低12位清零，并返回对应的PageInfo数据结构。</p>
<p><code>page_remove()</code>函数移除线性地址对应的物理页，清空二级页表项，使tlb无效化。如果不同的线性地址映射到同一个二级页表项，它们就映射到同一个物理页。另一种情况是不同的线性地址映射到不同的二级页表项，且它们通过<code>page_insert</code>映射到同一个物理页，这代表的是不同的二级页表项存取同一个物理页地址。通过<code>page_remove</code>即可解除情况1到二级页表项的映射，在这里，一旦线性地址对应到二级页表项，即将其清空。<code>page_remove()</code>函数通过调用<code>page_lookup()</code>函数获得线性地址对应的物理页的PageInfo数据结构，然后调用<code>page_decref()</code>函数将PageInfo对象引用减1，如果引用为0则释放该内存页。</p>
<p><code>page_insert()</code>函数将映射物理页的PageInfo数据结构的地址及访问权限存于线性地址所对应的二级页表项内。<code>page_insert()</code>函数首先调用<code>pgdir_walk()</code>函数获得指向线性地址的二级页表项的指针，允许创建二级页表。当对应的二级页表不存在且没有足够内存空间创建二级页表时，<code>pgdir_walk()</code>函数返回NULL，则<code>page_insert()</code>函数返回-1。否则<code>pgdir_walk()</code>函数返回指向二级页表项的指针，当该指针的P存在位为1时，代表当前二级页表项存在物理页映射，这时候需要判断该物理页与要插入的物理页是否是同一页，判断方法是：将指针内容（已经是物理地址）低12位清零，转化为PageInfo指针p，并与函数参数<code>PageInfo *pp</code>进行比较。如果是同一页（p与pp指向同个结构体），应该允许修改权限（包括降低权限，所以先清空低12位）后直接返回0，否则调用<code>page_remove()</code>函数移除线性地址对应的物理页，清空二级页表项。接着待插入的PageInfo指针pp的引用加1，将pp对应的物理页物理地址及权限存于二级页表项处，使tlb无效化。注意如果已映射的物理页和待插入的物理页是同一页的话，不能先移除物理页p再将pp的引用加1，因为一旦移除物理页p，p可能因为引用为0而被释放，进而page_free_list指向这块内存页，将其标记为可用，而此时pp的物理页是不可用的。</p>
<p><code>boot_map_region()</code>函数将线性地址空间[va, va+size)映射到物理地址空间[pa, pa+size)。pa、va是页对齐的，size是页大小的倍数。<code>boot_map_region()</code>函数循环调用<code>pgdir_walk()</code>函数返回指向二级页表项的指针，然后将对应的物理地址和权限存储到该指针。jos只有一个内核页目录，最多映射4G空间。jos将[KERNBASE,4G)的空间映射到物理内存上，其中KERNBASE=0xf0000000=3840M，4G=4096M，两者相差256M。因此，物理内存最多映射256M，即[0,256M)。4G等于0x100000000，其被映射的最后一页的起点地址是0xfffff000，这也就是<code>boot_map_region()</code>中能被映射的最后一个线性地址。</p>
<h1 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h1><p>jos一共有三个线性地址到物理地址的映射是需要的，此部分负责进行映射：<br><code>[UPAGES, sizeof(PAGES) ] =&gt; [pages, sizeof(PAGES)]</code>，这里 PAGES 代表页面管理结构所占用的空间；<br><code>[KSTACKTOP – KSTKSIZE, 8] =&gt; [bootstack, 8]</code>，<br>其中 bootstack 为内核编译时预先留下的 8 个页面（用做内核堆栈）；<br><code>[KERNBASE, 4G) =&gt; [0, pages in the memory)</code>，这个地址映射范围比较广，含盖了所有物理内存。这里是256M。<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/2.jpg" title="线性地址映射"></p>
<p><code>以下是对question的解答：</code><br><strong>2. 哪些页目录项已经被填充？它们映射到哪些地址并指向哪些内容？</strong><br>使用技巧：使用qemu调试后，在执行qemu的控制台里，先后按下ctrl、a、h查看帮助，先后按下ctrl、a、c可切换qemu监控器和终端控制台，切换到qemu监控器后，执行<code>info pg</code>可查看当前页表结构。<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/3.JPG" title="当前页表结构"><br>以其中的<code>[ef000-ef3ff]  PDE[3bc]     -------UWP</code>为例，它表示该页目录项映射的线性空间范围是[ef000000, ef3fffff]，两者之差为3fffff，即4M大小。3bc表示索引是956。UWP表示该项是kernel RW, user RW且president的。  </p>
<p>上图表示的页目录项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Entry       Base Virtual Address    Points to (logically):</span><br><span class="line">1023(3ff)   0xffc0000               Page table for top 4MB of phys memory, kernel RW, user NONE</span><br><span class="line">1022(3fe)   0xff80000               Page table for second to top 4MB of phys mem, kernel RW, user NONE</span><br><span class="line">.</span><br><span class="line">960(3c0)    0xf0000000              Page table for bottom 4MB of phys memory, kernel RW, user NONE</span><br><span class="line">959(3bf)    0xefc00000              (0xefff8000 - 0xf0000000 Kernel stack, kernel RW, user NONE)</span><br><span class="line">                                    (0xefc00000 - 0xefff8000 Invalid memory, or maybe other cpu&apos;s stack)</span><br><span class="line">957(3bd)    0xef400000              Current page table kernel R-, user R- (pgdir)</span><br><span class="line">956(3bc)    0xef000000              User pages, kernel R, user R</span><br><span class="line">.</span><br><span class="line">2           0x00800000</span><br><span class="line">1           0x00400000</span><br><span class="line">0           0x00000000              &lt;Nothing, mapping got cleared&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 内核环境和用户环境被映射到同一个地址空间，为什么用户程序不会读写内核内存？有什么保护机制吗？</strong><br>ULIM和UTOP将虚拟内存分为各个段。(ULIM, 4GB)只有内核环境能读写，(UTOP, ULIM]内核和用户环境都可以读取，[0x0, UTOP]是用户环境空间。这些内存空间被权限位所保护，如PTE_W(可写)和PTE_U(用户)，这些是在页表/页目录项中设置的标识。<br>具体用于保护的机制是当前特权级别(CPL)，CS的低2位。CPL=0则代表特权O/S，CPL=3 代表用户可访问。这也被用来检测当前的模式，以及我们是否可以写入虚拟内存地址。</p>
<p><strong>4.jos能支持的最大物理内存是多少？为什么？</strong><br>这个操作系统能支持的最大物理内存是256 MB。这是因为我们希望能够将所有的线性地址映射到物理地址。事实证明这样做使它更容易从物理地址反向映射到虚拟地址。</p>
<p><strong>5.如果我们真的有最大数量的物理内存，需要多少空间开销来管理内存？</strong><br>管理内存有页表和页目录，4G空间需要1个页目录和1024个页表，总共需要的空间开销是4KB * 1024 + 4KB。</p>
<p><strong>6.重新阅读kern/entry.S和kern/entrypgdir.c，我们开启分页后，EIP仍然是小于1MB的值，我们是在哪个point开始在基于KERNBASE的EIP上执行指令？从我们开启分页的时刻，到我们开始在基于KERNBASE的EIP上执行指令的时刻，这段时间为什么能够使用low EIP？</strong><br>在entry.S中，执行<code>jmp *%eax</code>指令之后eip将会加上KERNBASE。在开启分页到执行<code>jmp *%eax</code>指令这段期间，之所以能够使用low EIP，是因为线性地址[0, 4MB)和[KERNBASE, KERNBASE+4MB)同时映射到[0,4MB)物理地址，如果不映射线性地址[0, 4MB)，则low eip的线性地址不在可访问线性地址范围内，将出现非法访问。</p>
<p><code>以下是对Challenge的解答：</code>  </p>
<h2 id="Changeling1"><a href="#Changeling1" class="headerlink" title="Changeling1"></a>Changeling1</h2><p>我们使用了很多二级页表来映射KERNBASE地址，一个更有效的方法是使用页目录项的PTE_PS (“Page Size”)位，最初的80386不支持该位，但近年来的x86处理器可支持。阅读【Intel® 64 and IA-32 Architectures Software Developer’s Manual】第3.6 节【PAGING (VIRTUAL MEMORY) OVERVIEW】。**<br>如果将CR4中的PSE位打开，那么就可以开启4MB物理页。那么对应使用该物理页的虚拟地址寻址方式变为：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/4.JPG" title="开启4MB物理页的虚拟地址寻址方式"><br>这个时候相应的页目录表项也要修改，要修改其PS位表明该表项对应的地址是4MB，不用再进行二级页表寻址了：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/5.JPG" title="修改页目录表项PS位"><br>设置了使用4MB页表以后，那些二级页表查找和插入的过程就不能通用了，即<code>pgdir_walk()</code>、<code>page_insert()</code>函数等。但这不影响<code>check_page()</code>函数的检查，因为<code>check_page()</code>函数虽然调用了<code>pgdir_walk()</code>、<code>page_insert()</code>等函数，但是其检查逻辑是先模拟插入page再检查，二级页表的创建和页目录存储二级页表地址这些操作仍会被模拟（虽然此时页目录项的内容应该是4MB页地址，但其实是存了二级页表的地址）。相反，<code>check_kern_pgdir()</code>函数则不会成功执行，因为该函数是直接检查线性地址到物理地址的实际映射情况，再没有模拟插入page、创建二级页表的情况，所以其在涉及到二级页表的查询将会出错。所以修改为4MB页以后，应该注释掉<code>check_kern_pgdir()</code>函数的调用。如果qemu模拟器没有出现Triple fault，则代表寻址是正确的。实现代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">mem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	// Turn on CR4_PSE for 4MB page</span><br><span class="line">	lcr4 (rcr4 () | CR4_PSE);</span><br><span class="line">	...</span><br><span class="line">	//boot_map_region(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U | PTE_P);</span><br><span class="line">	...</span><br><span class="line">	//boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line"> 	...</span><br><span class="line">	//boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">	boot_map_region_4m(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">	...</span><br><span class="line">	// Check that the initial page directory has been set up correctly.</span><br><span class="line">	//check_kern_pgdir();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	jos只有一个内核页目录，最多映射4G空间。</span><br><span class="line">	jos将[KERNBASE,4G)的空间映射到所有物理内存上，这段内存是256M，</span><br><span class="line">	其中KERNBASE=0xf0000000=3840M，4G=4096M，两者相差256M。</span><br><span class="line">	因此，物理内存最多映射256M。4G等于0x100000000，其被映射的最后一页的起点地址是0xfffff000，</span><br><span class="line">	这也就是boot_map_region中能被映射的最后一个线性地址。</span><br><span class="line"></span><br><span class="line">	todo...可能存在的问题是：映射的是256M的内存，但是实际上只有64M可用的内存空间，</span><br><span class="line">	这些内存空间有对应的页面管理结构，其中一部分被作为映射256M内存空间时的二级页表。</span><br><span class="line">*/</span><br><span class="line">static void</span><br><span class="line">boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123; </span><br><span class="line">	// Fill this function in</span><br><span class="line">	/*</span><br><span class="line">		使用下述方法时，在映射[KERNBASE,4G)地址时</span><br><span class="line">		只能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W | PTE_P);，</span><br><span class="line">		不能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);</span><br><span class="line">		0xffffffff - KERNBASE + 1 = 0x10000000，KERNBASE+ 0x10000000会越界。</span><br><span class="line">	*/</span><br><span class="line">	/*</span><br><span class="line">	uintptr_t current_va;</span><br><span class="line">	physaddr_t current_pa = pa;</span><br><span class="line">	// The highest possible address of a virtual page</span><br><span class="line">  	uint32_t last_page_addr = 0xfffff000;</span><br><span class="line">	for (current_va = va; current_va &lt; va+size; current_va += PGSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		pte_t *pte = pgdir_walk(pgdir,(void *)current_va,true);</span><br><span class="line">		if(pte == NULL) return;</span><br><span class="line">		*pte = (current_pa | perm | PTE_P);</span><br><span class="line">		 </span><br><span class="line">		//此判断是有必要的，当将[KERNBASE,4G)映射到[0,256M)时，线性地址累积到0xfffff000的时候，for循环的判断条件仍然是成立的。</span><br><span class="line">		if (current_va == last_page_addr)</span><br><span class="line">			break;</span><br><span class="line"></span><br><span class="line">		current_pa += PGSIZE; </span><br><span class="line">	&#125; </span><br><span class="line">	*/</span><br><span class="line">	/*</span><br><span class="line">		使用下述方法时，在映射[KERNBASE,4G)地址时</span><br><span class="line">		本应该使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE + 1, 0, PTE_W | PTE_P);，</span><br><span class="line">		不能使用 boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W | PTE_P);，</span><br><span class="line">		因为这会导致循环次数减1，246M物理内存最后的1页没有被映射。</span><br><span class="line">		但由于实际的npages为16639，检测的总空间为64M，</span><br><span class="line">		check_kern_pgdir()函数会针对npages大小检测KERNBASE以上的地址映射情况，</span><br><span class="line">		超过64M以上的物理内存不会被检测到，所以并没有导致出错。</span><br><span class="line">		但严谨来说应该使用第一种情况。</span><br><span class="line">	*/</span><br><span class="line">	int i;</span><br><span class="line">    for (i = 0; i &lt; size/PGSIZE; ++i, va += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        pte_t *pte = pgdir_walk(pgdir, (void *) va, 1); //create</span><br><span class="line">        if (pte == NULL) panic(&quot;boot_map_region panic, out of memory&quot;);</span><br><span class="line">        *pte = pa | perm | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">boot_map_region_4m(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123;</span><br><span class="line">	pde_t *pde;</span><br><span class="line">	int i;</span><br><span class="line">    for (i = 0; i &lt; size/PTSIZE; ++i, va += PTSIZE, pa += PTSIZE) &#123;</span><br><span class="line">        pde = pgdir + PDX(va); </span><br><span class="line">        *pde = pa | perm | PTE_P | PTE_PS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Changeling2"><a href="#Changeling2" class="headerlink" title="Changeling2"></a>Changeling2</h2><p>扩展jos的命令，1、当给定线性地址的范围时，以一种易读的格式展示内存页映射情况。如’showmappings 0x3000 0x5000’命令可以展示线性地址0x3000、0x4000、0x5000的物理页映射及其权限位。2、能显式清除、设置或改变当前地址空间映射的权限。3、给定一段线性地址/物理地址范围，显示其内容，必须确保当给定范围跨页面边界的时候显示代码的正确性。**<br>1、提供两个函数，一个是将地址字符串转换为整数，一个是将读入参数，按页大小输出二级页表项内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">uint32_t jz_xtoi(char* pstr)&#123;</span><br><span class="line">	uint32_t res = 0;</span><br><span class="line">	pstr += 2;//0x...</span><br><span class="line">	while(*pstr)&#123;</span><br><span class="line">		if(*pstr &gt;= &apos;a&apos; &amp;&amp; *pstr &lt;= &apos;z&apos;) *pstr = *pstr - &apos;a&apos; + 10 + &apos;0&apos;;</span><br><span class="line">		else if(*pstr &gt;= &apos;A&apos; &amp;&amp; *pstr &lt;= &apos;Z&apos;) *pstr = *pstr - &apos;A&apos; + 10 + &apos;0&apos;;</span><br><span class="line">		res = res*16 + *pstr - &apos;0&apos;;</span><br><span class="line">		++pstr;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">mon_showmappings(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 3) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: showmappings 0xbegin_addr 0xend_addr\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	 </span><br><span class="line">	//将地址字符串转换int，然后判断低12位是不是0</span><br><span class="line">	uint32_t begin = jz_xtoi(argv[1]), end = jz_xtoi(argv[2]);</span><br><span class="line">	if((begin &amp; 0xfff) != 0 || (end &amp; 0xfff) != 0 )&#123;</span><br><span class="line">		cprintf(&quot;Make sure the addr&apos;s low 12 bits is zero\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(&quot;Attention! You may test addr above UPAGES(0xef000000)\n&quot;);</span><br><span class="line">	cprintf(&quot;begin:%p, end:%p\n&quot;,begin,end);</span><br><span class="line">	pde_t *kpgdir = KADDR(rcr3()), *pde; </span><br><span class="line">	pte_t *pte, *p;</span><br><span class="line">	uint32_t va;</span><br><span class="line">	for (va = begin; va &lt;= end; va += PGSIZE) </span><br><span class="line">	&#123; </span><br><span class="line">                //or you can use pgdir_walk</span><br><span class="line">		pde = &amp;kpgdir[PDX(va)];</span><br><span class="line">		if (*pde &amp; PTE_P)&#123; </span><br><span class="line">			pte = (pte_t*) KADDR(PTE_ADDR(*pde)); </span><br><span class="line">			if (*pte &amp; PTE_P)&#123; </span><br><span class="line">				p = &amp;pte[PTX(va)];</span><br><span class="line">				cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">					va, *p, *p&amp;PTE_P, *p&amp;PTE_W, *p&amp;PTE_U);			</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/6.JPG" title="showmappings执行结果"><br>2、使用<code>page_walk()</code>函数实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">mon_setpermissions(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 4) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: setpermissions 0xaddr [0|1 :clear or set] [P|W|U]\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	 </span><br><span class="line">	//将地址字符串转换int，然后判断低12位是不是0</span><br><span class="line">	uint32_t va = jz_xtoi(argv[1]);</span><br><span class="line">	if((va &amp; 0xfff) != 0 )&#123;</span><br><span class="line">		cprintf(&quot;Make sure the addr&apos;s low 12 bits is zero\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte_t *pte = pgdir_walk((pde_t *)KADDR(rcr3()),(void *)va,false);</span><br><span class="line">	if (pte &amp;&amp; (*pte &amp; PTE_P))&#123;  </span><br><span class="line">		cprintf(&quot;before setpermissions %p\n&quot;,va);</span><br><span class="line">		cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">			va, *pte, *pte&amp;PTE_P, *pte&amp;PTE_W, *pte&amp;PTE_U);			</span><br><span class="line">		uint32_t perm = 0;</span><br><span class="line">	    if (argv[3][0] == &apos;P&apos;) perm = PTE_P;</span><br><span class="line">	    if (argv[3][0] == &apos;W&apos;) perm = PTE_W;</span><br><span class="line">	    if (argv[3][0] == &apos;U&apos;) perm = PTE_U;</span><br><span class="line">	    if (argv[2][0] == &apos;0&apos;)  //clear</span><br><span class="line">	        *pte = *pte &amp; ~perm;</span><br><span class="line">	    else    //set</span><br><span class="line">	        *pte = *pte | perm;</span><br><span class="line">	    cprintf(&quot;after setpermissions %p\n&quot;,va);</span><br><span class="line">		cprintf(&quot;va: %p, pa: %p, PTE_P: %x, PTE_W: %x, PTE_U: %x\n&quot;, </span><br><span class="line">			va, *pte, *pte&amp;PTE_P, *pte&amp;PTE_W, *pte&amp;PTE_U);		</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		cprintf(&quot;page mapping not exist: %x\n&quot;, va);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="/2017/08/20/笔记05-Lab2-Memory-Management/7.JPG" title="setpermissions执行结果"><br>3、代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">mon_dumpcontents(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	if(argc != 4) &#123;</span><br><span class="line">   	  	cprintf(&quot;Make sure the correct style: dumpcontents [p|v :physical or virtual] 0x3000 10\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;	  </span><br><span class="line">	void** begin = NULL;</span><br><span class="line">	long length = strtol(argv[3],0,0);</span><br><span class="line">	uint32_t i; </span><br><span class="line"> 	if (argv[1][0] == &apos;p&apos;) &#123;</span><br><span class="line">		begin = (void**)(jz_xtoi(argv[2]) + KERNBASE);  </span><br><span class="line">	&#125; else if (argv[1][0] == &apos;v&apos;) &#123;  </span><br><span class="line">		begin = (void**)(jz_xtoi(argv[2])); </span><br><span class="line">	&#125;</span><br><span class="line">	if(begin &gt; begin + length)&#123;</span><br><span class="line">		cprintf(&quot;out of memory.\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">    for (i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">        cprintf(&quot;va at %x is %x\n&quot;, begin+i, begin[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于指针的指针可以参考C语言指针部分的博客。上述设计思想是：指针所加内容是指针存储的地址，所加范围是由指针指向的对象类型决定。因此，二级指针<code>begin+i</code>所加内容是二级指针存储的一级指针地址，所加范围是由二级指针所指向的一级指针决定，即每次加4个字节。<code>begin[i]</code>是<code>*(begin+i)</code>，即一级指针的内容。因此，这里是将内存内容当作一级指针内容看待！ </p>
<h2 id="Changeling3"><a href="#Changeling3" class="headerlink" title="Changeling3"></a>Changeling3</h2><p>操作系统一般会映射内核到低线性地址上，留下高地址部分给用户程序。x86内核由于存在向后兼容的虚拟8086模式，处理器会“硬连线式”使用线性空间的低地址部分，所以即使内核映射在那里也无法使用所有映射地址。但是，可以通过设计内核，不再为内核保存任何固定的线性地址部分，允许用户级进程整个无限制使用4GB的虚拟地址空间，同时还从这些进程中充分保护内核，和保护相互不同的进程。请写出满足上述要求的内核设计大纲（相关技术可称为follow the bouncing kernel），明确指出处理器在内核和用户模式之间转换会发生什么，描述内核会如何访问物理内存和IO设备，以及如何通过系统调用访问用户环境的虚拟地址空间。最后从灵活性、性能、内核的复杂性等阐述该方案的优缺点**  </p>
<h2 id="Changeling4"><a href="#Changeling4" class="headerlink" title="Changeling4"></a>Changeling4</h2><p>jos系统是从页粒度上分配和释放内存，但没有通用的malloc/free工具。如果我们要支持某些类型的I/O设备，它们需要物理上大于4KB的连续缓冲区，或者如果我们为了最大的处理器效率，需要在用户级环境（不仅仅是内核）上分配和映射4MB的superpages，那么将会产生问题。请概括出一个内核内存分配系统，支持管理2的幂大小的页，分配单元大小从4KB至一个合理大小值。确保存在将大分配单元按需求切分为小单元和将小单元合并为大单元的方案。**</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记04-HW02-boot-xv6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记04-HW02-boot-xv6/" itemprop="url">笔记04 - HW02: boot xv6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:07:23+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JOS 是麻省理工学院(MIT)从 xv6 直接改过来的实验用工具，<a href="https://github.com/mit-pdos/xv6-public" target="_blank" rel="noopener">xv6-public</a> 是官方在 Github 上放出的最新 xv6 源代码。</p>
<h1 id="获取-xv6-源码"><a href="#获取-xv6-源码" class="headerlink" title="获取 xv6 源码"></a>获取 xv6 源码</h1><p>git://pdos.csail.mit.edu/xv6/xv6.git 不成功，git://github.com/mit-pdos/xv6-public.git 成功。</p>
<h1 id="构建-xv6"><a href="#构建-xv6" class="headerlink" title="构建 xv6"></a>构建 xv6</h1><p>以下是makefile的部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -O -nostdinc -I. -c bootmain.c</span><br><span class="line">gcc -nostdinc -I. -c bootasm.S</span><br><span class="line">ld -m    elf_i386 -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class="line">objdump -S bootblock.o &gt; bootblock.asm</span><br><span class="line">objcopy -S -O binary -j .text bootblock.o bootblock</span><br></pre></td></tr></table></figure></p>
<p>==以下是对 gcc 参数的解释：==<br><strong>-O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。具体如下：</strong><br>-O0：这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置 -O 等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。<br>-O1：这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。<br>-O2：-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。<br>-O3：这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。在gcc 4.x.中使用-O3是不推荐的。<br>-Os：这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。 </p>
<p><strong>-nostdinc：可能默认的头文件库会首先调用，而-I下面的目录由于名字相同，优先级可能低于默认所以没能被调用，于是需要gcc编译的时候不要在标准系统目录中找头文件。</strong>  </p>
<p><strong>-I：用来指定头文件目录，/usr/include目录一般是不用指定的，gcc知道去那里找，但是如果头文件不在/usr/include里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I/myinclude参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前目录，可以用-I.来指定。</strong></p>
<p><strong>-c：仅执行编译操作，不进行链接操作。将c语言文件bootmain.c（也可以是汇编输出文件*.S）编译输出bootmain.o文件。</strong></p>
<p>==以下是对ld（GNU linker连接器）参数的解释：==<br><strong>-m emulation：模仿 emulation 连接器。如-m elf_i386是模仿elf_i386连接器</strong>  </p>
<p><strong>-N 或 –omagic：把text和data节设置为可读写，同时取消数据节的页对齐。同时取消对共享库的连接。如果输出格式支持Unix风格的magic number，把输出标志为’OMAGIC’。</strong>  </p>
<p><strong>-e ENTRY：使用符号ENTRY作为程序的开始执行点，而不是使用缺省的进入点。如果没有叫做ENTRY的符号，连接器会企图把ENTRY作为一个数字进行分析，并使用它作为入口地址(数字会被解释为10进制的；可以使用前导的’0x’强制为16进制，或’0’作为8进制。)</strong></p>
<p><strong>-Tbss ORG，-Tdata ORG，-Ttext ORG：跟-section-start同义，不过把SECTIONNAME替换为’.bss’，’.data’或’.text’。-section-start的格式是：`–section-start SECTIONNAME=ORG’，通过指定ORG，指定节在输出文件中的绝对地址。可以多次使用这个选项来定位多个节。ORG必须是一个十六进制整数；为了跟其他连接器兼容，可以忽略前导’0x’。注意，在SECTIONNAME、等号、ORG之间不允许有空格出现。</strong></p>
<p><strong>-o OUTPUT：使用OUTPUT作为’ld’产生的程序的名字。如果这个选项没有指定，缺省的输出文件名是’a.out’。脚本命令’OUTPUT’也可以被用来指定输出文件的文件名。</strong></p>
<p>==以下是对objdump（查看目标文件或者可执行的目标文件的构成的gcc工具）参数的解释：==<br><strong>-S：尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</strong> </p>
<p>==以下是对objcopy（用于将object的部分或全部内容拷贝到另一个object，从而可以实现格式的变换。）参数的解释：==<br><strong>-S：去掉源文件的符号信息和relocation信息。</strong> </p>
<p><strong>-O bfdname：使用指定的格式来写输出文件（即目标文件），bfdname是BFD库中描述的标准格式名。</strong></p>
<p><strong>-j sectionname：只将由sectionname指定的section拷贝到输出文件。</strong></p>
<h1 id="探究堆栈内容"><a href="#探究堆栈内容" class="headerlink" title="探究堆栈内容"></a>探究堆栈内容</h1><p>bootasm.S 中在哪里初始化堆栈？<br>在 call bootmain 之前调用 movl $start, %esp 初始化堆栈，由于历史原因，boot loader 部分将会被加载到 0x7c00 的位置，即 $start 所代表的位置。此处将 0x7c00 赋值给 esp，而堆栈栈顶指针是向低地址方向增长的。  </p>
<p>bootmain 函数对堆栈所做的第一条汇编指令是什么（查看bootblock.asm）？<br>push %ebp，将 ebp 进栈，此后将当前的栈顶指针的值赋给 ebp，从而可以实现递归调用和返回。  </p>
<p>单步调试直到 call bootmain，堆栈的内容是什么？<br>设置断点到 0x10000c（内核程序入口地址），当执行该地址的指令后，堆栈发生什么变化？<br>以下是进入到内核程序入口后，以栈顶指针 esp 为指标查看到的内存内容(x/24x $esp，其中 esp 的值为0x7bcc)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0x7bcc:	        #进入内核后， esp 指向 0x7bcc</span><br><span class="line">0x00007db7	#7db7 是进入内核elf-&gt;entry指令的下一条指令地址</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000</span><br><span class="line">0x7bdc:	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000</span><br><span class="line">0x7bec:	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000	</span><br><span class="line">0x00000000</span><br><span class="line">0x7bfc:	</span><br><span class="line">0x00007c4d	# 7c4d 是 bootasm.S 调用 bootmain 函数时下一条指令的地址，即 call bootmain 后堆栈会存储 0x7c4d。</span><br><span class="line">0x7c00:         # !!! 此处即为栈顶指针的初始化位置，此后向低地址方向增长</span><br><span class="line">0x8ec031fa	</span><br><span class="line">0x8ec08ed8	</span><br><span class="line">0xa864e4d0</span><br><span class="line">0x7c0c:	</span><br><span class="line">0xb0fa7502	</span><br><span class="line">0xe464e6d1	</span><br><span class="line">0x7502a864	</span><br><span class="line">0xe6dfb0fa</span><br><span class="line">0x7c1c:	</span><br><span class="line">0x16010f60	</span><br><span class="line">0x200f7c78	</span><br><span class="line">0xc88366c0	</span><br><span class="line">0xc0220f01</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-5-Lab-1-Jos内核/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-5-Lab-1-Jos内核/" itemprop="url">笔记03.5 - Lab 1:Jos内核</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:06:51+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在保护模式下线性地址 = GDT 表项中段基址 + 偏移地址，而实际上指针的值通常就是偏移地址。在 Boot Loader 完成了将内核可执行文件加载到内存中的工作后，将用 ((void (*)(void)) (ELFHDR-&gt;e_entry))(); 这一句代码执行指令的跳转。内核程序在 kern/entry.S 中设置 CR0_PG 标识符，虚存硬件开始将线性地址映射为物理地址。在标识符设置之前，由于没有开启分页，逻辑地址通过段映射得到的线性地址都被当作物理地址。开启分页后，内核程序使用 [KERNBASE, KERNBASE+4MB) 的线性地址，该地址范围会被映射到物理地址 [0, 4MB)，线性地址 [0, 4MB) 也会映射到物理地址 [0, 4MB) ，其中 KERNBASE = 0xF0000000。</p>
<p><strong>也就是说，boot/boot.S切换到保护模式之后，开始了逻辑地址到线性地址的转换，但是没有开启分页，线性地址被当为物理地址，所以一般使用的是低地址。kern/entry.S开启分页之后，开始在保护模式下使用高线性地址，因此需要加载页表。此时还没开始内存管理，因此页表是手工静态文件。</strong></p>
<h1 id="部分内核代码解析"><a href="#部分内核代码解析" class="headerlink" title="部分内核代码解析"></a>部分内核代码解析</h1><p>首先来看看 kern/entry.S 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/* See COPYRIGHT for copyright information. */</span><br><span class="line"></span><br><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line">#include &lt;inc/memlayout.h&gt;</span><br><span class="line"></span><br><span class="line"># Shift Right Logical </span><br><span class="line">#define SRL(val, shamt)		(((val) &gt;&gt; (shamt)) &amp; ~(-1 &lt;&lt; (32 - (shamt))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###################################################################</span><br><span class="line"># The kernel (this code) is linked at address ~(KERNBASE + 1 Meg), </span><br><span class="line"># but the bootloader loads it at address ~1 Meg.</span><br><span class="line">#	</span><br><span class="line"># RELOC(x) maps a symbol x from its link address to its actual</span><br><span class="line"># location in physical memory (its load address).	 </span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line">#define	RELOC(x) ((x) - KERNBASE)</span><br><span class="line"></span><br><span class="line">#define MULTIBOOT_HEADER_MAGIC (0x1BADB002)</span><br><span class="line">#define MULTIBOOT_HEADER_FLAGS (0)</span><br><span class="line">#define CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))</span><br><span class="line"></span><br><span class="line">###################################################################</span><br><span class="line"># entry point</span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line"># The Multiboot header</span><br><span class="line">.align 4</span><br><span class="line">.long MULTIBOOT_HEADER_MAGIC</span><br><span class="line">.long MULTIBOOT_HEADER_FLAGS</span><br><span class="line">.long CHECKSUM</span><br><span class="line"></span><br><span class="line"># &apos;_start&apos; specifies the ELF entry point.  Since we haven&apos;t set up</span><br><span class="line"># virtual memory when the bootloader enters this code, we need the</span><br><span class="line"># bootloader to jump to the *physical* address of the entry point.</span><br><span class="line">.globl		_start</span><br><span class="line">_start = RELOC(entry)</span><br><span class="line"></span><br><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line"></span><br><span class="line">	# We haven&apos;t set up virtual memory yet, so we&apos;re running from</span><br><span class="line">	# the physical address the boot loader loaded the kernel at: 1MB</span><br><span class="line">	# (plus a few bytes).  However, the C code is linked to run at</span><br><span class="line">	# KERNBASE+1MB.  Hence, we set up a trivial page directory that</span><br><span class="line">	# translates virtual addresses [KERNBASE, KERNBASE+4MB) to</span><br><span class="line">	# physical addresses [0, 4MB).  This 4MB region will be</span><br><span class="line">	# sufficient until we set up our real page table in mem_init</span><br><span class="line">	# in lab 2.</span><br><span class="line"></span><br><span class="line">	# 注意到内核代码的执行是从KERNBASE+1MB开始的，而不是KERNBASE!!!</span><br><span class="line">	# 由于虚拟内存机制还没建立，所以在kern/entrypgdir.c里面手写了4MB的页表，</span><br><span class="line">	# 把[0,4MB)物理地址同时映射到线性地址[0, 4MB)和[KERNBASE, KERNBASE+4MB)中</span><br><span class="line">	</span><br><span class="line">	# Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><br><span class="line">	# is defined in entrypgdir.c.</span><br><span class="line">	# 此时还没开启分页，需要RELOC将线性地址转化为物理地址</span><br><span class="line">	movl	$(RELOC(entry_pgdir)), %eax</span><br><span class="line">	movl	%eax, %cr3</span><br><span class="line">	# Turn on paging.</span><br><span class="line">	movl	%cr0, %eax</span><br><span class="line">	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">	movl	%eax, %cr0</span><br><span class="line"></span><br><span class="line">	# Now paging is enabled, but we&apos;re still running at a low EIP</span><br><span class="line">	# (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line">	# C code.</span><br><span class="line">	# 线性地址[0, 4MB)和[KERNBASE, KERNBASE+4MB)同时映射到[0,4MB)物理地址</span><br><span class="line">	# 如果不映射线性地址[0, 4MB)，则low eip的线性地址不在可访问线性地址范围内，将出现非法访问</span><br><span class="line">	mov	$relocated, %eax</span><br><span class="line">	jmp	*%eax # jmp 之后eip将会加上KERNBASE !!!</span><br><span class="line">relocated:</span><br><span class="line"></span><br><span class="line">	# Clear the frame pointer register (EBP)</span><br><span class="line">	# so that once we get into debugging C code,</span><br><span class="line">	# stack backtraces will be terminated properly.</span><br><span class="line">	movl	$0x0,%ebp			# nuke frame pointer</span><br><span class="line"></span><br><span class="line">	# 可以看到在这里定义了两个全局变量 bootstack 和 bootstacktop， bootstack 标识了内存中</span><br><span class="line">	# 的一个位置，表示从这里开始的 KSTKSIZE 个字节的区域都是属于这个临时堆栈的</span><br><span class="line">	# (KSTKSIZE 在 inc/memlayout.h 中定义为 32k)，而 bootstacktop 则指向的是这段区域后的第</span><br><span class="line">	# 一个字节，由于刚开始的时候堆栈是空的，所以栈顶便是 bootstacktop 所指向的位置，于是</span><br><span class="line">	# 程序便将 bootstacktop 的值赋给了 esp 寄存器。该位置位于.data节内。</span><br><span class="line"></span><br><span class="line">	# Set the stack pointer</span><br><span class="line">	movl	$(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line">	# now to C code</span><br><span class="line">	call	i386_init</span><br><span class="line"></span><br><span class="line">	# Should never get here, but in case we do, just spin.</span><br><span class="line">spin:	jmp	spin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"># boot stack</span><br><span class="line">###################################################################</span><br><span class="line">	.p2align	PGSHIFT		# force page alignment</span><br><span class="line">	.globl		bootstack</span><br><span class="line">bootstack:</span><br><span class="line">	.space		KSTKSIZE</span><br><span class="line">	.globl		bootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></table></figure></p>
<p>在初始化堆栈指针后，程序调用了 i386_init 函数，这个函数是在 kern/init.c 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">i386_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	extern char edata[], end[];</span><br><span class="line"></span><br><span class="line">	// 在完成任何事之前，先完成 ELF 的加载过程。清除未初始化的全局数据 (BSS) 节，确保所有 static/global 变量置零。</span><br><span class="line">        // 可以看到两个外部字符数组变量 edata 和 end，其中 edata 表示的是 bss 节在内存中开始的位置，而 end 则是表示内核可执行程序在内存中结束的位置。由 2.1 节中对 ELF 文件的讲解我们可以知道 bss 节是文件在内存中的最后一部分，于是 edata 与 end 之间的部分便是 bss 节的部分，我们又知道 bss 节的内容是未初始化的变量，而这些变量是默认为零的，所以在一开始的时候程序要用 memset(edata, 0, end - edata)这句代码将这些变量都置为零。</span><br><span class="line">	memset(edata, 0, end - edata);</span><br><span class="line"></span><br><span class="line">	// 初始化控制台，有显存的初始化、键盘的初始化之类的</span><br><span class="line">	// Can&apos;t call cprintf until after we do this!</span><br><span class="line">	cons_init();       </span><br><span class="line">        // 测试输出</span><br><span class="line">	cprintf(&quot;6828 decimal is %o octal!\n&quot;, 6828);</span><br><span class="line">        // 通过堆栈来对函数调用进行回溯(lab 1 only) </span><br><span class="line">	test_backtrace(5);</span><br><span class="line"></span><br><span class="line">	// Drop into the kernel monitor.</span><br><span class="line">        // 无限循环的调用了 monitor 函数，这个函数的原型在 kern/monitor.c 中，它的功能是提示用户输入命令与操作系统进行交互。</span><br><span class="line">	while (1)</span><br><span class="line">		monitor(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义在 kern/monitor.c 中的 runcmd 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">runcmd(char *buf, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	int argc;</span><br><span class="line">	char *argv[MAXARGS];</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	// Parse the command buffer into whitespace-separated arguments</span><br><span class="line">	argc = 0;</span><br><span class="line">	argv[argc] = 0;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		// gobble whitespace</span><br><span class="line">		while (*buf &amp;&amp; strchr(WHITESPACE, *buf))</span><br><span class="line">			*buf++ = 0; //把所有空格字符都置为空字符</span><br><span class="line">		if (*buf == 0)</span><br><span class="line">			break;// 命令结束</span><br><span class="line"></span><br><span class="line">		// save and scan past next arg</span><br><span class="line">		if (argc == MAXARGS-1) &#123;</span><br><span class="line">			cprintf(&quot;Too many arguments (max %d)\n&quot;, MAXARGS);</span><br><span class="line">			return 0;// 参数个数超过最大个数的限制</span><br><span class="line">		&#125;</span><br><span class="line">		argv[argc++] = buf;// 指向相应的字符串</span><br><span class="line">		while (*buf &amp;&amp; !strchr(WHITESPACE, *buf))</span><br><span class="line">			buf++; // 跳过非空格的字符</span><br><span class="line">	&#125;</span><br><span class="line">	argv[argc] = 0;</span><br><span class="line"></span><br><span class="line">	// Lookup and invoke the command</span><br><span class="line">	if (argc == 0)</span><br><span class="line">		return 0;</span><br><span class="line">	for (i = 0; i &lt; NCOMMANDS; i++) &#123;</span><br><span class="line">		if (strcmp(argv[0], commands[i].name) == 0)</span><br><span class="line">			return commands[i].func(argc, argv, tf);</span><br><span class="line">	&#125;</span><br><span class="line">	cprintf(&quot;Unknown command &apos;%s&apos;\n&quot;, argv[0]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序让指针指向了每个子字符串并且把命令字符串中的空格都换成了空字符， 因为用户在输入命令的时候， 命令名和参数之间， 参数和参数之间都是由空格相隔开的，这样处理后每个子字符串的结尾便都是一个空字符，便可以方便之后读取这个字符串，就如下图所示：<br><img src="/2017/08/20/笔记03-5-Lab-1-Jos内核/1.PNG" title="命令字符串的读取"></p>
<h1 id="堆栈分析"><a href="#堆栈分析" class="headerlink" title="堆栈分析"></a>堆栈分析</h1><p>先进后出是堆栈的特点，内存中栈顶在内存的低地址处，而栈底是在高地址处。栈底是固定的，栈顶是可以变化的。假设我们需要堆栈出栈一个字的数据，即 4 个字节，这个时候我们需要当前 esp 指向位置开始的 4 个字节读出来，并且在这之后把 esp 加 4。当需要进栈一个字的数据时，将 esp 减 4，并把这个字存放在 esp 指向位置开始的 4 个字节处。<br><img src="/2017/08/20/笔记03-5-Lab-1-Jos内核/2.PNG" title="堆栈出栈一个字的数据的状况"><br><img src="/2017/08/20/笔记03-5-Lab-1-Jos内核/3.PNG" title="堆栈进栈一个字的数据的状况"><br>关键的寄存器： eip 存储当前执行指令的下一条指令在内存中的偏移地址， esp 存储指向栈顶的指针，而 ebp 则是存储指向当前函数需要使用的参数的指针。在程序中，如果需要调用一个函数，首先（1）会将函数需要的参数进栈，然后（2）将 eip 中的一个字进栈，也就是下一条指令在内存中的位置，这样在函数调用结束后便可以通过堆栈中的 eip 值返回调用函数的程序（CALL将下一条指令的CS:EIP压入堆栈，但真实的情况是，下一条指令的地址压入堆栈，但EIP装入跳转函数的地址）。而在一进入调用函数的时候，第一件事便是（3）将 ebp 进栈（调用本函数的过程的栈指针），然后将当前的 esp 的值赋给 ebp。（4）ebp 以下部分一般作为临时数据区（esp 下调），包含本函数要调用的过程的参数的空间。<br>当前函数的 ebp 设置在 3 和 4 之间的地址，因此 0x0[%ebp] 可以读出上个函数的栈指针， 0x4[%ebp] 可以读出返回地址 %eip， 0x8[%ebp] 可以读出第一个参数……<br><img src="/2017/08/20/笔记03-5-Lab-1-Jos内核/4.PNG" title="调用函数时堆栈的变化"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-4-Lab-1-控制台输出函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-4-Lab-1-控制台输出函数/" itemprop="url">笔记03.4 - Lab 1:控制台输出函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:06:18+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是 JOS 内核控制台输出代码关于 kern/printf.c、 lib/printfmt.c、 kern/console.c 的解析。摘抄自【系统的启动和初始化】一文。  </p>
<h1 id="C-语言中解决变参问题的一组宏"><a href="#C-语言中解决变参问题的一组宏" class="headerlink" title="C 语言中解决变参问题的一组宏"></a>C 语言中解决变参问题的一组宏</h1><p>1) 用 <code>va_list</code> 可以定义一个 <code>va_list</code> 型的变量，这个变量是指向参数的指针。<br>2) 用 <code>va_start</code> 宏可以初始化一个 <code>va_list</code> 变量，这个宏有两个参数，第一个是 <code>va_list</code> 变量本身，第二个是可变的参数的前一个参数，是一个固定的参数。<br>3) 用 <code>va_arg</code> 宏可以返回可变的参数，这个宏也有两个参数，第一个是 <code>va_list</code> 变量，即指向参数的指针，第二个是返回的参数类型。<br>4) 用 <code>va_end</code> 宏结束可变参数的获取。</p>
<h1 id="cprintf-函数原型"><a href="#cprintf-函数原型" class="headerlink" title="cprintf()函数原型"></a>cprintf()函数原型</h1><p>kern/printf.c 之 cprintf()函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">第一个参数 fmt 代表的是显示字符串的指针，诸如 “%d %c”。之后的参数值用来在显示的时候替代 %d、 %c,可以是常数、整形变量、浮点变量、字符、字符串指针。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">cprintf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	int cnt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">定义了 va_list 变量 ap 后马上就用 va_start 宏对其进行了初始化，用 va_start 宏进行初始化的时候第二个参数是 fmt，也就是 cprintf 函数的第一个参数，即可变参数之前的固定参数，于是这时 ap 便指向了后面的可变参数。函数的参数实际上都是存放在内存的堆栈中的，而且参数会按照先后顺序依次存放，靠前的参数会存放在较低的地址处，其中每个参数会根据其类型被分配相应大小的空间。于是 ap 在这个时候便指向了可变参数 1 的存放地址，这样我们就可以用 va_arg 宏依次读取之后的可变参数。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	cnt = vcprintf(fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line"></span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="vcprintf函数原型"><a href="#vcprintf函数原型" class="headerlink" title="vcprintf函数原型"></a>vcprintf函数原型</h1><p>kern/printf.c 之 cprintf 函数所调用的 vcprintf 函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">vcprintf(const char *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">	int cnt = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">第一个参数实际上是一个函数指针， putch 函数被当做成了一个参数， putch 函数的功能是输出一个字符在屏幕上</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">	vprintfmt((void*)putch, &amp;cnt, fmt, ap);</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="putch函数原型"><a href="#putch函数原型" class="headerlink" title="putch函数原型"></a>putch函数原型</h1><p>kern/printf.c 之 putch 函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">整形变量 ch 代表的是要输出的字符，因为 int 的变量是 32 位的，而一个字符的 ASCII 码只需要有 8 位，所以实际上 32 位整形变量的低八位代表的是字符的 ASCII 码，而第 8 位到 15 位代表的是输出字符的格式，因此 int 变量的高 16 位实际上没有用的；而 cnt 指针指向一个整形变量，这个整形变量每当用 putch 函数输出一个字符后就加 1。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">putch(int ch, int *cnt)</span><br><span class="line">&#123;</span><br><span class="line">	cputchar(ch); /*见 kern/console.c */</span><br><span class="line">	*cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="cputchar函数原型"><a href="#cputchar函数原型" class="headerlink" title="cputchar函数原型"></a>cputchar函数原型</h1><p>kern/console.c 之 cputchar 函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">cputchar(int c)</span><br><span class="line">&#123;</span><br><span class="line">	cons_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="cons-putc函数原型"><a href="#cons-putc函数原型" class="headerlink" title="cons_putc函数原型"></a>cons_putc函数原型</h1><p>kern/console.c 之 cons_putc 函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*将一个字符输出到控制台*/</span><br><span class="line">static void</span><br><span class="line">cons_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">	serial_putc(c);</span><br><span class="line">	lpt_putc(c); /*进行一些硬件初始化的工作*/</span><br><span class="line">	cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图表示的是整形参数的 8 到 15 位是如何确定字符输出的格式的：<br><img src="/2017/08/20/笔记03-4-Lab-1-控制台输出函数/1.PNG" title="字符显示属性字节"><br>可以看到高 4 位决定了字符的背景色，可以有 16 种颜色，同样低四位则决定了字符本<br>身的颜色，在这里， R 代表红色的色素， G 代表绿色的色素， B 代表蓝色的色素，这三个色素的组合就可以组成 8 种不同的颜色，而 I 则表示颜色是否是高亮的，于是这样便可以有 16 种颜色。<br>下图表示的是显存与显示屏的对应关系：<br><img src="/2017/08/20/笔记03-4-Lab-1-控制台输出函数/2.PNG" title="显存与显示屏的对应关系"></p>
<h1 id="cga-putc函数原型"><a href="#cga-putc函数原型" class="headerlink" title="cga_putc函数原型"></a>cga_putc函数原型</h1><p>kern/console.c 之 cga_putc 函数的原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">cga_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">整形参数 c 的低 8 位是字符的 ASCII 码，而 8 到 15 位则是字符输出的格式，函数首先判断字符的格式有没有事先设定，如果没有，即 8 到 15 位皆为 0，则系统将会将这个字符的设定为默认格式。</span><br><span class="line">*/</span><br><span class="line">	// if no attribute given, then use black on white</span><br><span class="line">	if (!(c &amp; ~0xFF))</span><br><span class="line">		c |= 0x0700;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">crt_buf 是一个指向 16 位无符号整形数的静态指针，它实际上指向的是内存中</span><br><span class="line">物理地址为 0xb8000 的位置，(物理内存的 0xa0000 到 0xc0000 这 128KB 的空间是留给 VGA 显示缓存的，实际上在我们的试验中从 0xb8000 这个位置开始的一部分内存空间便是可以直接与显示屏相关联的显存)</span><br><span class="line">在本实验中，显示屏规定为 CRT_ROWS = 25 行，每行可以输出 CRT_COLS = 80 个字符，由于每个字符实际上占据显存中的两个字节，于是物理内存中从 0xb8000 到 0xb8fa0 之间的内容都会以字符的形式在屏幕上显示出来。 crt_pos 是一个静态的 16 位无符号整形变量，如果把 crt_buf 指向的内存空间看做 16 位整形数的数组，则 crt_pos 则是数组的下标，在这里它实际上表示的是光标的位置，而 CRT_COLS 则是一个常量，表示一行可以输出的字符数，即为 25。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">	switch (c &amp; 0xff) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">把 crt_pos 减 1 表示光标向后退一格，并且将光标</span><br><span class="line">当前指向位置对应的显存中的两个字节的值置为(c &amp; ~0xff) | &apos; &apos;， 即把原来的字符替换为了一个空格，这样便完成了退格的操作。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">	case &apos;\b&apos;: // 表示退格</span><br><span class="line">		if (crt_pos &gt; 0) &#123;</span><br><span class="line">			crt_pos--;</span><br><span class="line">			crt_buf[crt_pos] = (c &amp; ~0xff) | &apos; &apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">/*把 crt_pos 加上 25，即将光标的位置换到下一行相同的位置。*/</span><br><span class="line"></span><br><span class="line">	case &apos;\n&apos;:  // 表示换行</span><br><span class="line">		crt_pos += CRT_COLS;</span><br><span class="line">		/* fallthru */</span><br><span class="line"></span><br><span class="line">/*将 crt_pos 减去 (crt_pos % CRT_COLS)。*/</span><br><span class="line"></span><br><span class="line">	case &apos;\r&apos;: // 表示光标退到这一行的开头处</span><br><span class="line">		crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">/*递归的调用 cons_putc 函数连续打印 5 个空格。*/</span><br><span class="line"></span><br><span class="line">	case &apos;\t&apos;: // 光标向前移动 5 格</span><br><span class="line">		cons_putc(&apos; &apos;);</span><br><span class="line">		cons_putc(&apos; &apos;);</span><br><span class="line">		cons_putc(&apos; &apos;);</span><br><span class="line">		cons_putc(&apos; &apos;);</span><br><span class="line">		cons_putc(&apos; &apos;);</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">/*不是以上的这些特殊字符时，程序便将其直接写入显存中，并且将光标的位置加 1，值得注意的是在这里 crt_buf[crt_pos++]表示的是内存中 16 位的空间，然而整形变量 c 是 32 位的，于是在写入内存的时候只取 c 的低 16 位。*/</span><br><span class="line"></span><br><span class="line">	default: // 往屏幕上打印一个字符</span><br><span class="line">		crt_buf[crt_pos++] = c;	 /* write the character */</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// What is the purpose of this?</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">在物理地址超过 0xb8fa0 的内存部分中存储字符数据，此时实际上显示屏就无法显示超过的部分，这个时候通常下显示屏都会滚屏好让最新输出的字符能够显示出来。在每输出一个字符后都先判断 crt_pos 是否大于或等于 CRT_SIZE，而 CRT_SIZE 实际上就是一个屏幕可以输出的字符数，即 80*25。当等于 CRT_SIZE 时，说明此时已经满屏，当大于 CRT_SIZE 时，说明有字符没有显示出来。当满足这两种情况的中的一种时，程序所做的处理是将屏幕上第二行到最后一行的的字符数据复制到第一行到倒数第二行去，然后将屏幕的最后一行输出为空格。</span><br><span class="line">*/</span><br><span class="line">	if (crt_pos &gt;= CRT_SIZE) &#123; // CRT_SIZE = (CRT_ROWS * CRT_COLS)</span><br><span class="line">		int i;</span><br><span class="line"></span><br><span class="line">		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); // 执行滚屏操作</span><br><span class="line">		for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">			crt_buf[i] = 0x0700 | &apos; &apos;;</span><br><span class="line">		crt_pos -= CRT_COLS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* move that little blinky thing */</span><br><span class="line">	outb(addr_6845, 14);</span><br><span class="line">	outb(addr_6845 + 1, crt_pos &gt;&gt; 8);</span><br><span class="line">	outb(addr_6845, 15);</span><br><span class="line">	outb(addr_6845 + 1, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="vprintfmt函数程序流程图"><a href="#vprintfmt函数程序流程图" class="headerlink" title="vprintfmt函数程序流程图"></a>vprintfmt函数程序流程图</h1><p>vcprintf （见 kern/printf.c） 函数所调用的 vprintfmt （见 lib/printfmt.c） 函数的程序流程图<br><img src="/2017/08/20/笔记03-4-Lab-1-控制台输出函数/3.PNG" title="vprintfmt程序流程图"><br>上图 5 个格式变量： padc、 width、 precision、 lflag、 altflag。 padc 代表的是填充字符，在初始化的时候 padc 变量会被初始化为空格符，而当程序在显示字符串的 ’%’ 字符后读到 ’-’ 或者 ’0’ 的字符时便会将 ’-’ 或者 ’0’ 赋值给 padc。 width 代表的是打印的一个字符串或者一个数字在屏幕上所占的宽度，而 precision 则特指一个字符串在屏幕上应显示的长度。当打印字符串的时候， padc = ’-’ 代表着字符串需要左对齐，右边补空格， padc =’ ’ 代表字符串右对齐， 而左边由空格补齐， padc = ’0’ 代表字符串右对齐， 左边由 0 补齐。在我们这个实验中当输出数字时会一律的右对齐，左边补 padc，数字显示长度为数字本身的长度。 lfag 变量则是专门在输出数字的时候起作用，在我们这个实验中为了简单起见实际上是不支持输出浮点数的，于是 vprintfmt 函数只能够支持输出整形数，，输出整形数时，当 lflag = 0 时，表示将参数当做 int 型的来输出，当 lflag = 1 时，表示当做 long 型的来输出，而当 lflag = 2 时表示当做 long long 型的来输出。最后， altflag 变量表示当 altflag = 1 时函数若输出乱码则用 ’?’ 代替。</p>
<h1 id="vprintfmt函数打印字符串"><a href="#vprintfmt函数打印字符串" class="headerlink" title="vprintfmt函数打印字符串"></a>vprintfmt函数打印字符串</h1><p>lib/printfmt.c 之 vprintfmt 函数打印一个字符串具体是如何实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case &apos;s&apos;:</span><br><span class="line">			if ((p = va_arg(ap, char *)) == NULL)</span><br><span class="line">				p = &quot;(null)&quot;; /* 当字符串指针为空时，将它指向&quot;(null)&quot;字符串*/</span><br><span class="line">			if (width &gt; 0 &amp;&amp; padc != &apos;-&apos;)</span><br><span class="line">				for (width -= strnlen(p, precision); width &gt; 0; width--)</span><br><span class="line">					putch(padc, putdat); /*字符串右对齐，左边补相应数量的空格或者 0*/</span><br><span class="line">			for (; (ch = *p++) != &apos;\0&apos; &amp;&amp; (precision &lt; 0 || --precision &gt;= 0); width--)</span><br><span class="line">				if (altflag &amp;&amp; (ch &lt; &apos; &apos; || ch &gt; &apos;~&apos;))</span><br><span class="line">					putch(&apos;?&apos;, putdat);</span><br><span class="line">				else</span><br><span class="line">					putch(ch, putdat);/*打印相应长度的字符串*/</span><br><span class="line">			for (; width &gt; 0; width--)</span><br><span class="line">				putch(&apos; &apos;, putdat); /*当字符串是左对齐的时候打印相应数量的空格*/</span><br><span class="line">			break;</span><br></pre></td></tr></table></figure></p>
<p>当程序识别了显示字符串中 ’%’ 后的 ’s’ 字符后便从可变参数中读入字符串指针，若指针为空，则让它指向一个 “(null)” 字符串。然后再判断输出是左对齐还是右对齐，若 padc = ’-’ ， 表示是左对齐， 否则是右对齐。确认是右对齐的话，按照我们之前所讲的， 用 width 减去字符串实际显示长度便得到需要在左边补空格或 0 的个数，注意到 int strnlen(char *str, int maxlen) 函数原型是计算字符串 str 的 (unsigned int 型）长度，不包括结束符NULL，该长度最大为 maxlen ， maxlen 传入 -1 的话会返回字符串的长度。在这之后程序便开始打印字符串本身，可以看到若 precision 大于 0 则显示长度等于 precision 与字符串长度之间的最小值， precision 小于 0 则显示长度等于字符串本身的长度（无论 width 多大）。最后程序判断如果字符串是左对齐的话则在右侧剩余空间补充空格。</p>
<h1 id="printnum函数原型"><a href="#printnum函数原型" class="headerlink" title="printnum函数原型"></a>printnum函数原型</h1><p>在打印数字的时候则会用到 printnum 这个函数，该函数的主体如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*参数 num 代表需要打印出来的整形数， base 代表整形数的进制，其它的参数和 vprintfmt 函数中代表同样的意思。当 num 超过 1 位时函数递归的调用自己本身，这样便可以先打印高位的数字，当 num 只有 1 位时，程序便首先按照右对齐的格式在左侧打印填充字符，然后打印这个数字。*/</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">printnum(void (*putch)(int, void*), void *putdat,</span><br><span class="line">	 unsigned long long num, unsigned base, int width, int padc)</span><br><span class="line">&#123;</span><br><span class="line">	// first recursively print all preceding (more significant) digits</span><br><span class="line">	if (num &gt;= base) &#123;</span><br><span class="line">		printnum(putch, putdat, num / base, base, width - 1, padc);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// print any needed pad characters before first digit</span><br><span class="line">		while (--width &gt; 0)</span><br><span class="line">			putch(padc, putdat);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// then print this (the least significant) digit</span><br><span class="line">	putch(&quot;0123456789abcdef&quot;[num % base], putdat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到无论是打印字符串还是数字，都是将它们分解成一个个单个的字符然后用<br>putch 函数一个一个的打印出来。所以 putch 函数可谓是显示输出的基本函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-3-Lab-1-bootmain-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-3-Lab-1-bootmain-c/" itemprop="url">笔记03.3 - Lab 1:bootmain.c</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:05:22+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解析main-c"><a href="#解析main-c" class="headerlink" title="解析main.c"></a>解析main.c</h1><p>以下是 JOS Boot Loader 部分关于 main.c 的解析，关于 main.c 的介绍请阅读【学习笔记03 - Lab 1:Booting a PC】<br><strong>以下内容摘抄自《系统的启动和初始化》一书</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/x86.h&gt;</span><br><span class="line">#include &lt;inc/elf.h&gt;</span><br><span class="line"></span><br><span class="line">/**********************************************************************</span><br><span class="line"> * 这是一个简单的引导加载程序，它的唯一工作是从第一个 IDE 硬盘引导 ELF 格式的</span><br><span class="line"> * 内核镜像</span><br><span class="line"> *</span><br><span class="line"> * DISK LAYOUT</span><br><span class="line"> *  * 本程序(boot.S and main.c)是开机引导程序</span><br><span class="line"> *    它必须被存储在硬盘的第一个扇区</span><br><span class="line"> *</span><br><span class="line"> *  * 从第二个扇区开始存储内核镜像</span><br><span class="line"> *</span><br><span class="line"> *  * 内核镜像必须是 ELF 格式</span><br><span class="line"> *</span><br><span class="line"> * 开机步骤</span><br><span class="line"> *  * CPU 启动时加载 BIOS 到内存并执行 BIOS</span><br><span class="line"> *</span><br><span class="line"> *  * BIOS 初始化设备，设置终端程序，</span><br><span class="line"> *    读取启动设备的第一个扇区到内存并跳转</span><br><span class="line"> *</span><br><span class="line"> *  * 假设本引导加载程序存储在硬盘的第一个扇区，这段代码接管控制权</span><br><span class="line"> *</span><br><span class="line"> *  * 由 boot.S 开始进行控制 -- 设置保护模式、堆栈指针，然后调用 bootmain()</span><br><span class="line"> *    执行 c 语言代码</span><br><span class="line"> *</span><br><span class="line"> *  * bootmain() 读取内核镜像并跳转</span><br><span class="line"> **********************************************************************/</span><br><span class="line"></span><br><span class="line">#define SECTSIZE    512</span><br><span class="line">#define ELFHDR      ((struct Elf *) 0x10000) // 定义一个指向内存中 ELF文</span><br><span class="line">//件头存放位置的结构体指针。定义 ELF 文件头应该存放在内存的 0x10000 处</span><br><span class="line"></span><br><span class="line">void readsect(void*, uint32_t); //读取磁盘上一个扇区</span><br><span class="line">void readseg(uint32_t, uint32_t, uint32_t); //读取 ELF 文件中一段</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bootmain(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct Proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // 将文件的前 4KB 读入内存，4KB 为一页，其中包括 ELF 文件头以及程序头表</span><br><span class="line">    readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</span><br><span class="line"></span><br><span class="line">    // 判断该文件是否为 ELF 文件</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">        goto bad;</span><br><span class="line"></span><br><span class="line">    // 将指针指向程序头表的首地址 (ignores ph flags)，其中的 (uint8_t *) 是为了让 ELFHDR 指针每 +1 增加 1 而不是 32 位指针默认的 +4。</span><br><span class="line">    ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;// 明确文件段的个数</span><br><span class="line">    for (; ph &lt; eph; ph++)</span><br><span class="line">        // p_pa是该段的加载地址（物理地址）</span><br><span class="line">        readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">     // 在将内核加载到内存中后转移到内核入口地址处执行，并且不会再返回（直接寻址方式）</span><br><span class="line">    ((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(0x8A00, 0x8A00);</span><br><span class="line">    outw(0x8A00, 0x8E00);</span><br><span class="line">    while (1)</span><br><span class="line">        /* do nothing */;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pa 代表该段的加载地址， count 代表该段在内存中所占字节数，</span><br><span class="line">// offset 代表该段在磁盘文件中的相对于文件首的偏移</span><br><span class="line">// 从内核的 offset 偏移处读取 count 字节到内存的 pa 地址上</span><br><span class="line">// 可能实际复制的字节数多于 count</span><br><span class="line">void</span><br><span class="line">readseg(uint32_t pa, uint32_t count, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t end_pa;</span><br><span class="line"></span><br><span class="line">    end_pa = pa + count; // 找到内存中加载地址的最末端</span><br><span class="line"></span><br><span class="line">    // 由于硬盘中的每一扇区加载到内存的时候都需要 512 字节对齐，</span><br><span class="line">    // 于是在这里把起始加载地址向下对齐到 512 字节的倍数的地址处</span><br><span class="line">    pa &amp;= ~(SECTSIZE - 1);</span><br><span class="line"></span><br><span class="line">    // 将在硬盘中的偏移由字节数转换成扇区数，由于内核可执行程序</span><br><span class="line">    // 是从磁盘的第二个扇区开始存储的，所以需要加 1</span><br><span class="line">    offset = (offset / SECTSIZE) + 1;</span><br><span class="line"></span><br><span class="line">    // 如果读取很慢，我们可以一次读取多个扇区</span><br><span class="line">    // 可能写入到内存的字节数多于要求的，但没有关系，因为我们是递增加载的</span><br><span class="line">    while (pa &lt; end_pa) &#123;</span><br><span class="line">        // 因为我们还没有启用分页，而是使用一致的段映射 (见 boot.S)</span><br><span class="line">        // 所以可以直接使用物理地址  一旦 JOS 允许 MMU 将不会是这种情况</span><br><span class="line">        readsect((uint8_t*) pa, offset);</span><br><span class="line">        pa += SECTSIZE;</span><br><span class="line">        offset++;// 用 readsect 函数一个扇区一个扇区地读取文件的这一段</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">waitdisk(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 循环直到硬盘准备好</span><br><span class="line">    while ((inb(0x1F7) &amp; 0xC0) != 0x40)</span><br><span class="line">        /* do nothing */;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">readsect(void *dst, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    // 等待直到硬盘准备好</span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(0x1F2, 1);     // count = 1</span><br><span class="line">    outb(0x1F3, offset);</span><br><span class="line">    outb(0x1F4, offset &gt;&gt; 8);</span><br><span class="line">    outb(0x1F5, offset &gt;&gt; 16);</span><br><span class="line">    outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);</span><br><span class="line">    outb(0x1F7, 0x20);  // cmd 0x20 - read sectors</span><br><span class="line"></span><br><span class="line">    // 等待直到硬盘准备好</span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    // 读取一个扇区的数据</span><br><span class="line">    insl(0x1F0, dst, SECTSIZE/4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-2-Lab-1-ELF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-2-Lab-1-ELF/" itemprop="url">笔记03.2 - Lab 1:ELF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:04:50+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>以下内容摘抄自《系统的启动和初始化》一书</strong>  </p>
<p>ELF = “Executable and Linkable Format”<br>在 JOS 操作系统实验中，内核的可执行程序实际上是一个 ELF 文件。 ELF 文件可以分为这样几个部分： ELF 文件头（定长）、程序头表(program header table)（不定长）、节头表(section header table)和文件内容。而其中文件内容部分又可以分为这样的几个节： .text 节、 .rodata 节、 .stab节、 .stabstr 节、 .data 节、 .bss 节、 .comment 节。程序头表实际上是将文件的内容分成了好几个段，而每个表项就代表了一个段，有可能就是同时几个节包含在同一个段里。  </p>
<p>加载 ELF 文件到内存中是先加载文件头信息，通过 ELF 文件头获取所有的程序头表项数据，然后按段的形式加载文件内容的，下面<strong>从段的角度</strong>介绍一下 ELF 文件结构。</p>
<p>我们先来看看 ELF 文件头的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Elf &#123;</span><br><span class="line">    uint32_t e_magic; // 标识文件是否是 ELF 文件</span><br><span class="line">    uint8_t e_elf[12]; // 魔数和相关信息</span><br><span class="line">    uint16_t e_type; // 文件类型</span><br><span class="line">    uint16_t e_machine;// 针对体系结构</span><br><span class="line">    uint32_t e_version; // 版本信息</span><br><span class="line">    uint32_t e_entry; // Entry point 程序入口点，是虚拟的链接地址</span><br><span class="line">    uint32_t e_phoff; // 程序头表偏移量，是程序头表的第一项相对于 ELF 文件的开始位置的偏移</span><br><span class="line">    uint32_t e_shoff; // 节头表偏移量</span><br><span class="line">    uint32_t e_flags; // 处理器特定标志</span><br><span class="line">    uint16_t e_ehsize; // 文件头长度</span><br><span class="line">    uint16_t e_phentsize;// 程序头部长度</span><br><span class="line">    uint16_t e_phnum; // 程序头部表项个数</span><br><span class="line">    uint16_t e_shentsize;// 节头部长度</span><br><span class="line">    uint16_t e_shnum; // 节头部个数</span><br><span class="line">    uint16_t e_shstrndx; // 节头部字符索引</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以用“ objdump -f 可执行文件”这样的命令来查看硬盘中 ELF 文件的文件头信息，如“ objdump -f obj/kern/kernel ”：<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/1.PNG" title="objdump -f obj/kern/kernel"><br>再看看程序头表项的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Proghdr &#123;</span><br><span class="line">    uint32_t p_type; // 段类型</span><br><span class="line">    uint32_t p_offset; // 段位置相对于 ELF 文件开始处的偏移量，标识出了磁盘位置(相对的位置，这里没有包括 ELF 文件之前的磁盘)</span><br><span class="line">    uint32_t p_va; // 段放置在内存中的地址(虚拟的链接地址)</span><br><span class="line">    uint32_t p_pa; // 段的物理地址</span><br><span class="line">    uint32_t p_filesz; // 段在文件中的长度</span><br><span class="line">    uint32_t p_memsz; // 段在内存中的长度</span><br><span class="line">    uint32_t p_flags; // 段标志</span><br><span class="line">    uint32_t p_align; // 段在内存中的对齐标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用 ELF 文件头与程序头表项如何找到 ELF 文件的第 i 段：<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/2.PNG" title="如何找到 ELF 文件的第 i 段"></p>
<p><strong>从段的角度</strong>介绍完 ELF 文件结构后，下面<strong>从节的角度</strong>介绍一下 ELF 文件结构：<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/3.PNG" title="ELF 文件结构"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text 节：可执行指令的部分。</span><br><span class="line">.rodata 节：只读全局变量部分，如 C 编译器产生的 ASCII string 常量。</span><br><span class="line">.stab 节：符号表部分，这一部分的功能是程序报错时可以提供错误信息。</span><br><span class="line">.stabstr 节：符号表字符串部分。</span><br><span class="line">.data 节：可读可写的全局变量部分，保存已初始化的数据，如已初始化的全局变量 int x = 5。</span><br><span class="line">.bss 节：未初始化的全局变量部分，如 int x，这一部分不会在磁盘有存储空间，因为这些变量并没有被初始化，全部默认为 0。内核代码编译时，链接器为未初始化全局变量保留了.bss 空间，并计算出.bss 的地址和大小。在将这节装入到内存的时候程序需要为其分配相应大小的初始值为 0 的内存空间。</span><br><span class="line">.comment 节：注释部分，这一部分不会被加载到内存。</span><br></pre></td></tr></table></figure></p>
<p>可以用“ objdump –h 可执行文件”这样的命令来查看硬盘中 ELF 文件的每个节的信息(不是内存布局)，如“ objdump -h obj/kern/kernel ”：<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/4.PNG" title="objdump -h obj/kern/kernel"><br>可以发现.bss 节与.comment 节在文件中的偏移是一样的，这就说明.bss 在硬盘中式不占用空间的，仅仅只是记载了它的长度。但是.bss 节在装入内存后是占据一定的空间的。<br>另一方面，“ VMA ”表示链接地址 link address ，“ LMA ”表示加载地址 load address ，节的 LMA 表示该节会被加载到内存中的 LMA 地址上。</p>
<p>可以用“ objdump –x 可执行文件”这样的命令来查看硬盘中 ELF 文件的文件头、段、节、符号表等信息(不是内存布局)，如“ objdump -x obj/kern/kernel ”：<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/5.PNG" title="objdump -x obj/kern/kernel"><br>从 start address 可以看出 kernel 的入口地址是 0x0010000c。<br>段信息部分，vaddr是线性地址，paddr是物理地址，可以看出，第一段在文件中的偏移是 0x1000，而在内存中占据的字节数是 0x717b，链接地址 0xf0100000，物理地址 0x100000，包括了.text 、.rodata 、.stab 、.stabstr 节；第二段在文件中的偏移是 0x9000，而在内存中占据的字节数是 0xa944，链接地址 0xf0108000，物理地址 0x108000，包含了.data 节以及在硬盘上不占用空间但在内存中占据 644 字节的.bss 节。在这里程序头表的第二项会用p_filesz 成员变量标注该段在文件占用的字节数并且同时用 p_memsz 标注在内存中占用的字节数，这样 Boot Loader 便会在从硬盘读入第二段的同时为.bss 节在内存中分配空间。我们可以看到，.comment 节没有被包含在任意一段中，这表明它没有被装入内存。<br><strong>注意到：</strong>链接地址是高地址，而加载地址是低地址。这表示内核代码告诉 Boot Loader 在加载它时要加载到内存低地址(1M)，而它将从内存高地址执行。  </p>
<p>stab 节在 ELF 文件结构为符号表部分，stabstr 是符号表的字符串部分。可以通过 objdump -G obj/kern/kernel 查看 stab 节的内容，jos 中解析 stab 节的数据结构见于 inc/stab.h。其中，n_type 有几种类型，SO 表示主函数的文件名，SOL 表示包含进的文件名，SLINE 表示代码段的行号，FUN 表示函数的名称。结合 grep SO、 grep FUN 等可以对结果进行分类。objdump -G 命令还可以看到每个文件在编译后在 ELF 文件中的链接地址，从小到大依次排列。objdump -G obj/kern/kernel | grep FUN 可以发现函数也是按照它们属于各自文件的顺序 ，依次排列在链接地址空间里。<br><img src="/2017/08/20/笔记03-2-Lab-1-ELF/6.PNG" title="objdump -G obj/kern/kernel | grep FUN"><br>kern/kdebug.c 中有二分查找函数 stab_binsearch，实现了在 stab 中查找 addr 对应表项的过程（根据链接地址查找）。根据 %eip 读取当前指令所在文件、所在行、所在函数的实现过程则见于 kern/kdebug.c 的 debuginfo_eip 函数。其中，stab 节的位置 __STAB_BEGIN__ 是链接器在链接时得到的，在 kern/kernel.ld 中可以看到用于初始化 stabs 和 stab_end 两个变量的部分。调用 stab_binsearch 的两个参数 int <em>region_left, int </em>region_right 是表项序号，不是内存地址，<strong>使用 stab_end - stabs 即可，因为同类型指针相减会自动除去该类型的 size 的，即这里可以获取相隔的元素个数之差。</strong></p>
<p>最后，我们介绍一下节头表。<br>节头表的功能是让程序能够找到特定的某一节，通过 ELF 文件头与节头表找到文件的某一节的方式和之前所说的找到某一段的方式是类似的。我们来看看节头表项的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Secthdr &#123;</span><br><span class="line">    uint32_t sh_name; // 节名称</span><br><span class="line">    uint32_t sh_type; // 节类型</span><br><span class="line">    uint32_t sh_flags; // 节标志</span><br><span class="line">    uint32_t sh_addr; // 节在内存中的线性地址</span><br><span class="line">    uint32_t sh_offset; // 相对于文件首部的偏移</span><br><span class="line">    uint32_t sh_size; // 节大小(字节数)</span><br><span class="line">    uint32_t sh_link; // 与其它节的关系</span><br><span class="line">    uint32_t sh_info; // 其它信息</span><br><span class="line">    uint32_t sh_addralign; // 字节对齐标志</span><br><span class="line">    uint32_t sh_entsize; // 表项大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-1-Lab-1-boot-S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-1-Lab-1-boot-S/" itemprop="url">笔记03.1 - Lab 1:boot.S</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:04:14+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解析boot-S"><a href="#解析boot-S" class="headerlink" title="解析boot.S"></a>解析boot.S</h1><p>以下是 JOS Boot Loader 部分关于 boot.S 的解析，关于 boot.S 的介绍请阅读【学习笔记03 - Lab 1:Booting a PC】<br><strong>以下内容摘抄自《系统的启动和初始化》一书</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt; </span><br><span class="line"></span><br><span class="line"># 启动 CPU ，切换到 32 位保护模式，跳转到 C 代码</span><br><span class="line">  BIOS 将这份代码从硬盘的第一个扇区读取到内存的 0x7c00 物理地址上</span><br><span class="line"># 设置 %cs=0 %ip=7c00 并在 real mode 下开始执行</span><br><span class="line"></span><br><span class="line">  # 首先 boot 程序会进行初始化，先把代码段选择子与数据段选择子以及保护模式</span><br><span class="line">  # 启动标识设置为常量，然后关中断并且将 ds、 es、 ss 这些段寄存器全部清零</span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # 内核代码段选择子常量，gdt 表中第二项</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # 内核数据段选择子常量，gdt 表中第三项</span><br><span class="line">.set CR0_PE_ON,      0x1         # 内核保护模式启动标识位 常量</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # 16 位模式</span><br><span class="line">  cli                         # 关中断，只能在内核模式下执行</span><br><span class="line">  cld                         # 使方向标识位 DF 复位，内存地址向高地址增加</span><br><span class="line"></span><br><span class="line">  # 设置重要的数据段寄存器(DS, ES, SS)</span><br><span class="line">  xorw    %ax,%ax             # ax 清零</span><br><span class="line">  movw    %ax,%ds             # 数据段寄存器清零</span><br><span class="line">  movw    %ax,%es             # 附加段寄存器清零</span><br><span class="line">  movw    %ax,%ss             # 堆栈段寄存器清零</span><br><span class="line"></span><br><span class="line">  # A20对实模式和保护模式的影响:</span><br><span class="line">  # 实模式下：在8086/8088中，分段模式能够表示的最大内存为FFFFh:FFFFh=FFFF0h+FFFFh=10FFEFh=1M+64K-16Bytes（1M多余出来的部分被称做高端内存区HMA）。但8086/8088只有20位地址线，如果访问100000h~10FFEFh之间的内存，则必须有第21根地址线。所以当程序员给出超过1M（100000H-10FFEFH）的地址时，系统并不认为其访问越界而产生异常，而是自动从重新0开始计算，系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap-around。到了80286，系统的地址总线发展为24根，如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域；如果A20 Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式。在80286以及更高系列的PC中，即使A20 Gate被打开，在实模式下所能够访问的内存最大也只能为10FFEFH，尽管它们的地址总线所能够访问的能力都大大超过这个限制。</span><br><span class="line">  # 保护模式下：如果A20 Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0；如果A20 Gate被打开，则其第20-bit是有效的，其值既可以是0，又可以是1。所以，在保护模式下，如果A20 Gate被禁止，则可以访问的内存只能是奇数1M段，即1M,3M,5M…，也就是00000-FFFFF, 200000-2FFFFF,300000-3FFFFF…。如果A20 Gate被打开，则可以访问的内存则是连续的。</span><br><span class="line">  #   下面的代码打开 A20 地址线</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # 从 0x64 端口读入一个字节的数据到 al 中</span><br><span class="line">                                  # 等待空闲的时候</span><br><span class="line"></span><br><span class="line">  testb   $0x2,%al                # 测试 al 的第 2 位是否为 0</span><br><span class="line">  jnz     seta20.1                # 如果 al 的第 2 位不为 0，循环检查</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 将 0xd1 写入到 al 中</span><br><span class="line">  outb    %al,$0x64               # 将 al 中的数据写入到端口 0x64 中</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # 从 0x64 端口读入一个字节的数据到 al 中</span><br><span class="line">                                  # 等待空闲的时候</span><br><span class="line"></span><br><span class="line">  testb   $0x2,%al                # 测试 al 的第 2 位是否为 0</span><br><span class="line">  jnz     seta20.2                # 如果 al 的第 2 位不为 0，循环检查</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 将 0xdf 写入到 al 中</span><br><span class="line">  outb    %al,$0x60               # 将 al 中的数据写入到端口 0x60 中</span><br><span class="line"></span><br><span class="line">  # 将系统从实模式切换到保护模式</span><br><span class="line">  # 首先用 “lgdt gdtdesc” 这条指令将 GDT 表的首地址加载到 GDTR， 然后将 cr0 寄存器的最低位置 1， 标志着系统进入保护模式，最后用一个跳转指令让系统开始使用 32 位的寻址模式。</span><br><span class="line"></span><br><span class="line">    # 在装载 cr0 之前需要先使用指令 lgdt gdtdesc 加载段表，原因是：</span><br><span class="line">    # 开启保护模式之后，基址：偏移 这种寻址方式就变成了 段选择子：偏移 这种方</span><br><span class="line">    # 式，而所谓的段选择子就是段表中的索引，因此为了正确的进行段式地址变换，还</span><br><span class="line">    # 需要加载段表。</span><br><span class="line">  lgdt    gdtdesc              # 将全局描述符表标识符加载到全局描述符表寄存器</span><br><span class="line"></span><br><span class="line">    # 开启保护模式</span><br><span class="line">    # cr0 中的第 0 位为 1 表示处于保护模式</span><br><span class="line">    # cr0 中的第 0 位为 0 表示处于实模式</span><br><span class="line">  movl    %cr0, %eax           # 把控制寄存器 cr0 的数据加载到 eax 中</span><br><span class="line">  orl     $CR0_PE_ON, %eax     # 将 eax 中的第 0 位设置为 1</span><br><span class="line">  movl    %eax, %cr0           # 将 eax 中的值装入 cr0 中</span><br><span class="line"></span><br><span class="line">    # 跳转到 32 位模式中的下一条指令，将处理器切换为 32 位工作模式</span><br><span class="line">    # 由于是在保护模式中，所以 $PROT_MODE_CSEG 被当作段选择子，而 $protcseg 是偏移地址。从后面的 GDT 表中可以看到，段选择子的值是 0x8，于是对应的段描述符会是表中的第二项（因为段选择子的低三位表示了RPL和TI），即是 SEG(STA_X|STA_R, 0x0, 0xffffffff)这一项，0x0 表示段首地址是 0，所以最终得到的线性地址为 0+$protcseg，程序便会跳到 protcseg 所标识的位置来执行。由于此时尚未开启分页，因此该链接地址会被当做加载地址，所以 boot loader 的加载地址必须和链接地址保持一致。 lab1 中的 boot/Makefrag 文件的第 28 行实际上规定了 Boot Loader 的固定链接地址是 0x7C00 。</span><br><span class="line">    # 将代码段选择子常量 $PROT_MODE_CSEG 加载到 cs 中，cs 对应的高速缓冲存储器会自动加载代码段描述符，同样将 $protcseg 加载到 ip 中（此后如果没有修改段寄存器的内容，cs 的内容将不会改变）。</span><br><span class="line"></span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg </span><br><span class="line"></span><br><span class="line">  # 进入保护模式后，程序重新对段寄存器进行初始化并且赋值堆栈指针，然后调用</span><br><span class="line">  # bootmain 函数。可以看到，在 “call bootmain” 之后便是一个无限循环的跳转指令，</span><br><span class="line">  # 之所以是无限循环就是这个函数调用永远都不会有返回的可能性，这句程序仅仅只是</span><br><span class="line">  # 让整个代码看起来有完整性。</span><br><span class="line">  .code32                     # 32 位模式</span><br><span class="line">protcseg:</span><br><span class="line">    # 设置保护模式下的数据寄存器</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # 将数据段选择子常量装入到 ax 中</span><br><span class="line">    # 将 ax 装入到其他数据段寄存器中，在装入的同时，这些段寄存器对应的高速缓冲</span><br><span class="line">    # 寄存器会自动加载数据段描述符</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # 设置栈指针，并且调用 main.c 中的 bootmain 函数 </span><br><span class="line">    # 值得注意的是，这是进入保护模式之后第一个栈顶，在任何函数调用前都要初始化栈，boot.S 里很巧妙的将 start 作为栈的基址，因为栈空间是向下增长的，$start 的地址是 0x7c00，在正式的设定之前，0-start 这段空间做为栈，应该足够了。</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">    # 如果 bootmain 返回的话，就一直循环</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line">.p2align 2                          # 强制 4 字节对齐</span><br><span class="line">                                    # GDT 表的存放位置是 4 字节对齐的，也</span><br><span class="line">                                    # 就是说 GDT 表的物理首地址是 4 的倍数</span><br><span class="line">  # GDT 全局描述符表描述符</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL                          # 空表项，连续 8 个值为 0 的 字节</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff) # 代码段表项</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)       # 数据段表项</span><br><span class="line">                                    # SEG 宏的第一个参数是 type，第二个是base，</span><br><span class="line">                                    # 第三个是 limit，所以我们可知定义的第二、</span><br><span class="line">                                    # 第三个段均是基址为 0，长度是 4G 的段</span><br><span class="line"></span><br><span class="line">  # 全局描述符表对应的描述符</span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                      # gdt 表长度 - 1，说明 gdt 表长度为 24 字节</span><br><span class="line">  .long   gdt                       # gdt 表物理地址</span><br></pre></td></tr></table></figure></p>
<h1 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h1><p><strong>物理地址：</strong>将主板上的物理内存条所提供的内存空间定义为物理内存空间，把内存看成一个从 0 字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址。<br><strong>逻辑地址：</strong>逻辑地址指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。Intel中段式管理中，对逻辑地址要求：一个逻辑地址，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]，也就是说，给定 0xFFFFFFFF ，应该表示为[A的代码段标识符:  0xFFFFFFFF]，这样才完整一些。<br><strong>线性地址：</strong>也叫<strong>链接地址</strong>。Intel为了兼容，将远古时代的段式内存管理方式保留了下来。程式代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址（这种情况下，个人认为逻辑地址的概念已经由[段标识符：段内偏移量]变为[段内偏移量]了）。Linux中逻辑地址等于线性地址。jos 的代码段和数据段基址都是从 0x0 开始，长度 4G（内核gdt指定），这样<strong>线性地址=逻辑地址+ 0x0</strong>，相当于禁用了段机制的寻址功能，也就是说逻辑地址等于线性地址了。这样的情况下Linux只用到了GDT，不论是用户任务还是内核任务，都没有用到LDT。线性地址空间是指一段连续的、不分段的、范围为 0~4GB 的地址空间。一个线性地址就是线性地址空间的一个绝对地址。<br><strong>虚拟内存空间中的地址转换为物理地址：</strong>  CPU 将一个虚拟内存空间中的地址转换为物理地址，需要进行两步：首先将给定一个逻辑地址<strong>（其实是段内偏移量，这个一定要理解！！！）</strong>，逻辑地址实际上就是程序自己假设在内存中存放的位置，即编译器在编译的时候会认定程序将会连续的存放在从起始处的线性地址开始的内存空间，于是像 protcseg 这样的地址标识符就被编译成了那段代码开始处的偏移地址。 CPU 要利用其段式内存管理单元，先将逻辑地址加上基址，转换成一个线性地址，再利用其页式内存管理单元，转换为最终物理地址。JOS 实验的 Boot Loader 阶段段基地址为0，偏移量即为逻辑地址，由于没有启用分页，线性地址甚至直接使用为物理地址。后续操作中，内核将被加载到低地址，但使用高地址进行访问，其映射工作就是通过开启分页机制来完成的。  </p>
<p><strong>Boot Loader 的起始链接地址：</strong>lab1 中的 boot/Makefrag 文件的第 28 行实际上规定了 Boot Loader 的链接地址：$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^。其中“ 0x7C00”便是规定的链接地址。假设我们修改了 Boot Loader 的起始链接地址（不再是固定的 7c00 ），重新编译代码后，boot.asm 反汇编文件展示的指令代码地址和指令跳转全是按照链接地址重新计算过的。首先我们先在物理内存的 0x7c00 处设置一个断点，因为 Boot Loader 一定会加载在这个位置，所以 0x7c00 处的第一条指令便是 boot.S 的第一条可执行指令。gdb 对应的是物理地址，单步调试时每一行显示的是物理地址。 Boot Loader 加载到 0x7c00 后，由于尚未涉及到跳转，因此取下一条指令时只要 ip 累加即可继续正确执行。涉及到 jne 等跳转指令时，如果条件未满足，仍然继续向下取指令执行。当碰上如 ljmp 等指令进行跳转时，目标链接地址是重新计算过的，该地址在 boot.asm 中对应的指令并不同于此时内存中相应位置的指令，因此当以该地址取内存中的指令时，导致出错。综上，为了正确地跳转到下一条指令的位置，需要使加载地址等于链接地址，因此 Boot Loader 的起始链接地址必须固定为 0x7c00 。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记03-Lab-1-Booting-a-PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记03-Lab-1-Booting-a-PC/" itemprop="url">笔记03 - Lab 1:Booting a PC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:03:34+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装仿真环境"><a href="#安装仿真环境" class="headerlink" title="安装仿真环境"></a>安装仿真环境</h1><p>课程内核程序git仓库地址：<a href="https://pdos.csail.mit.edu/6.828/2014/jos.git" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2014/jos.git</a>  运行机器要求：i386 Athena 机器（uname -a 提示 i386 GNU/Linux 或者 i686 GNU/Linux）。可使用<a href="https://pdos.csail.mit.edu/6.828/2014/tools.html#qemu" target="_blank" rel="noopener">qemu</a>模拟器运行内核程序和<a href="https://pdos.csail.mit.edu/6.828/2014/tools.html#chain" target="_blank" rel="noopener">Compiler Toolchain</a>工具。虽然qemu的内置监控只提供了有限的调试支持,qemu可以作为GNU调试器(GDB)的远程调试目标。课程项目包含了一个分级评分项目，运行 make grade 可以测试自己的解决方案。 </p>
<p>本课程提供的qemu源码安装步骤：<br>1、Clone the IAP 6.828 QEMU git repository<br><strong>git clone <a href="https://github.com/geofft/qemu.git" target="_blank" rel="noopener">https://github.com/geofft/qemu.git</a> -b 6.828-1.7.0</strong><br>2、Configure the source code<br><strong>Linux:</strong><br><strong>./configure –disable-kvm [–prefix=PFX] [–target-list=”i386-softmmu x86_64-softmmu”]</strong><br><strong>OS X:</strong><br><strong>./configure –disable-kvm –disable-sdl [–prefix=PFX] [–target-list=”i386-softmmu x86_64-softmmu”]</strong><br>The <strong>prefix</strong> argument specifies where to install QEMU; without it QEMU will install to <strong>/usr/local</strong> by default. The <strong>target-list</strong> argument simply slims down the architectures QEMU will build support for.<br>3、Run <strong>make &amp;&amp; make install</strong></p>
<p>执行 <strong>./configure –disable-kvm</strong> 安装qemu 1.7.0过程可能出现依赖错误，提前安装的软件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev</span><br><span class="line">sudo apt-get install libglib2.0</span><br><span class="line">sudo apt-get install autoconf</span><br><span class="line">sudo apt-get install libtool</span><br><span class="line">sudo apt-get install libsdl-console</span><br><span class="line">sudo apt-get install libsdl-console-dev</span><br></pre></td></tr></table></figure></p>
<p>如果出现以下错误的话，按照提示执行，如执行（2） <strong>git submodule update –init pixman</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR: pixman not present. Your options:</span><br><span class="line">    (1) Preferred: Install the pixman devel package (any recent distro should have packages as Xorg needs pixman too).</span><br><span class="line">    (2) Fetch the pixman submodule, using:</span><br><span class="line">        git submodule update --init pixman</span><br></pre></td></tr></table></figure></p>
<p>执行 <strong>make install</strong> 的时候，可能会出现 以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[1]: bison: Command not found</span><br></pre></td></tr></table></figure></p>
<p>解决方案是执行 <strong>sudo apt-get install bison</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make[4]: Nothing to be done for `all-am&apos;.</span><br><span class="line">install -d -m 0755 &quot;/usr/local/share/qemu/keymaps&quot;</span><br><span class="line">...提示不存在相关qemu目录...</span><br></pre></td></tr></table></figure></p>
<p>解决方法是以root的方式执行 <strong>sudo make install</strong></p>
<h1 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h1><p>搭建并熟悉实验环境，包括QEMU虚拟机、以及GDB调试器</p>
<h2 id="仿真xv6"><a href="#仿真xv6" class="headerlink" title="仿真xv6"></a>仿真xv6</h2><p>安装完qemu并下载课程内容后，进入课程目录并执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd lab</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>上述步骤会生成obj/kern/kernel.img文件，这是仿真PC的虚拟硬盘内容，包括引导加载程序boot loader (obj/boot/boot)和内核kernel (obj/kernel)。<br>返回到lab目录，执行以下命令启动qemu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/1.PNG" title="启动qemu"> 
<p>‘Booting from Hard Disk…’之后的内容都是由JOS内核程序输出。K&gt;是内核的交互式控制程序打印的提示。为了测试和实验分级的目的，JOS内核的控制台输出被设置为写到虚拟VGA显示(见qemu窗口)和模拟PC的虚拟串口（见终端）。JOS内核从键盘和串行端口接收输入，可以在VGA显示窗口或运行QEMU的终端输入命令，<strong>Ctrl-Alt 可以切换终端和VGA显示窗口</strong>，VGA显示窗口输入如下所示：<br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/2.PNG" title="qemu执行命令"><br>执行kerninfo命令时，内核监控程序将运行在仿真PC的“原生（虚拟）硬件”上。</p>
<h2 id="PC的物理地址空间"><a href="#PC的物理地址空间" class="headerlink" title="PC的物理地址空间"></a>PC的物理地址空间</h2><p>以32位地址空间为例<br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/3.PNG" title="32-bit 物理地址空间"><br>早期PC基于16位的因特尔8088处理器，只有1MB物理内存，地址范围是0x0000000 - 0x000fffff，非上图所示的0x0000000 - 0xffffffff。<strong>Low Memory</strong>是早期PC唯一能使用的随机存取存储器RAM，占了640KB。事实上，非常早期的PC仅仅只能使用16KB、32KB或者64KB的RAM。剩余的384KB空间有诸如作为视频显示缓冲区和非易失性内存保存固件等特殊用途。从0x000A0000到0x000FFFFF的384kB的区域是被硬件保留着用于特殊通途的，比如像作为VGA的显示输出的缓存或者是被当作保存系统固化指令的非易失性存储器。这一部分内存区域中最重要的应该是保存在0x000F0000到0x00100000处占据64KB的基本输入输出系统(BIOS)。早期PC使用只读存储器ROM存储BIOS，而不是现今的可更新闪存。<strong>BIOS作用是：</strong>执行基本的系统初始化，如激活显卡和检查已装置的内存总量；执行初始化后，BIOS从一个适当的位置加载操作系统到内存，这些位置可以是如软盘、硬盘、CD-ROM或网络，将机器控制权移交给操作系统。<br>因特尔80286处理器支持16MB地址空间，80386处理器支持4G地址空间，为了软件的向后兼容，仍然保留1MB的低地址空间。因此PC的RAM被0x000A0000 - 0x00100000这块物理内存（第一个<strong>hole</strong>）分为两部分，前640KB成为常规内存，0x00100000以上部分成为扩展内存。另外，现在一般由BIOS保留32位物理地址空间的高地址部分（所有物理RAM之上），供32位PCI设备使用。现有x86处理器能支持4G以上地址空间，0xFFFFFFFF以上地址能继续扩展RAM，因此，BIOS必须绕过上述32位设备映射空间（第二个<strong>hole</strong>）。本课程的内核程序基于80386处理器，只使用PC物理内存的<strong>前256MB</strong>，因此只考虑PC只支持32位物理地址空间。</p>
<h2 id="使用qemu调试工具研究IA-32兼容计算机的启动过程"><a href="#使用qemu调试工具研究IA-32兼容计算机的启动过程" class="headerlink" title="使用qemu调试工具研究IA-32兼容计算机的启动过程"></a>使用qemu调试工具研究IA-32兼容计算机的启动过程</h2><p>开启两个终端，分别进入lab目录后，一个终端执行 <strong>make qemu-gdb (或 make qemu-nox-gdb)</strong> 命令开启qemu，qemu在处理器执行第一条指令之前将停止并等到GDB的调试连接；另一个终端执行 <strong>gdb</strong> 命令，该命令使用已提供的.gdbinit文件来设置GDB，.gdbinit文件确保GDB能在早期引导期间进行16位代码调试工作，并引导它附属到监听的qemu，如若出现gdb无法执行.gdbinit文件的情况，按照提示添加add-auto-load-safe-path到主目录。<br>实验证明，启动qemu监听以后，开启gdb连接，如果gdb断开并重新开启，会出现类似以下错误，解决方法是重新开启qemu。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ignoring packet error, continuing...</span><br><span class="line">warning: unrecognized item &quot;timeout&quot; in &quot;qSupported&quot; response</span><br></pre></td></tr></table></figure></p>
<img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/4.PNG" title="启动gdb连接qemu"> 
<p>注意到这一行：<strong>[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b</strong>，它是GDB对第一条执行指令的反汇编结果（GDB连接qemu后qemu执行的第一条指令），表示的意思是：IBM PC开启时CS段寄存器内容是0xf000，IP段寄存器是0xfff0，执行的物理地址是0x000ffff0（BIOS 64KB地址范围内），第一条执行的指令是jmp，跳转的段寄存器地址是CS = 0xf000 和 IP = 0xe05b。由于BIOS物理地址范围是0x000f0000-0x000fffff（“硬连线的”），IBM早期的PC沿用以上因特尔8088处理器的设计，确保开启电源或重启后BIOS能控制机器。qemu仿真器附带的BIOS也安置在这个位置（位于处理器模拟的物理地址空间上）。一旦处理器复位，模拟的处理器将进入<strong>实地址模式</strong>并设置CS = 0xf000 和 IP = 0xe05b，在（CS:IP）段地址开始执行。实模式下，PC启动时段地址转换为物理地址过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">physical address = 16 * segment + offset</span><br><span class="line">   16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is</span><br><span class="line">   = 0xf0000 + 0xfff0     # easy--just append a 0.</span><br><span class="line">   = 0xffff0</span><br></pre></td></tr></table></figure></p>
<p>这个位置距离BIOS结束地址0x100000只有16字节空间，因此BIOS执行的第一条指令是跳转到BIOS地址空间更靠前的位置。BIOS运行时，设置一个中断描述符表，初始化VGA显示器等各种设备。初始化PCI总线和BIOS知道的所有重要设备后，BIOS搜索软盘、硬盘或光盘等可引导设备。最终，当它发现一个引导盘时，BIOS从磁盘读取引导加载程序并将控制权移交给引导加载程序。<strong>此BIOS部分的其他解释见博客【计算机原理-计算机启动】</strong></p>
<h1 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h1><p>了解PC启动过程以及内核装载过程</p>
<h2 id="启动扇区和引导程序"><a href="#启动扇区和引导程序" class="headerlink" title="启动扇区和引导程序"></a>启动扇区和引导程序</h2><p>硬盘由于传统的原因被默认分割成了一个个大小为 512 字节的扇区，而扇区则是硬盘最小的读写单位，即每次对硬盘的读写操作只能够对一个或者多个扇区进行并且操作地址必须是 512 字节对齐的。如果说操作系统是从磁盘启动的话，则磁盘的第一个扇区就被称作“启动扇区”，因为 Boot Loader 的可执行程序就存放在这个扇区。在本实验中，当 BIOS 找到启动的磁盘后，便将 512 字节的启动扇区的内容装载到物理内存的 0x7c00 到 0x7dff 的位置，紧接着再执行一个跳转指令将 CS 设置为 0x0000， IP 设置为 0x7c00，这样便将控制权交给了 Boot Loader 程序。<br>PC 发展到很后来的时候才能够从 CD-ROM 启动，而 PC 架构师也重新考虑了 PC 的启动过程。然而从 CD-ROM 启动的过程略微有点复杂。 CD-ROM 的一个扇区的大小不是 512 字节而是 2048 字节，并且 BIOS 也能够从 CD-ROM 装载更大的 BootLoader 程序到内存。在本实验中由于规定是从硬盘启动，所以我们暂且不考虑从 CD-ROM启动的问题。<br>本实验 Boot Loader 的源程序是由一个叫做的 boot.S 的 AT&amp;T 汇编程序与一个叫做 main.c 的 C 程序组成的。这两部分分别完成两个不同的功能。其中 boot.S 主要是将处理器从实模式转换到 32 位的保护模式，这是因为只有在保护模式中我们才能访问到物理内存高于 1MB 的空间，保护模式下段地址（段：偏移）到物理地址的转化不同于实模式，模式转化后偏移是 32 bits 而不是 16 bits 。main.c 的主要作用是将内核的可执行代码从硬盘镜像中读入到内存中，具体的方式是运用 x86 专门的 I/O 指令。<br>obj/boot/boot.asm是引导程序的反汇编结果，obj/kern/kernel.asm是内核程序的反汇编结果，可被用于调试参考。比如使用 b *0x7c00 命令在0x7c00处设置断点，并使用 c 命令跳转到该断点，参考obj/boot/boot.asm进行追踪。</p>
<h2 id="引导程序之模式转换"><a href="#引导程序之模式转换" class="headerlink" title="引导程序之模式转换"></a>引导程序之模式转换</h2><p><strong>以下分析尝试解决的问题是： 1.什么原因导致了 16-bit 模式转换为 32-bit 模式？ 2.处理器什么时候开始执行 32-bit 代码？</strong><br>Boot Loader 会被加载到 0x7c00 处，设置断点可看出改为知道第一条指令是 boot.S 的第一条可执行指令。<br><strong>gdb 图示</strong><br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/5.PNG" title="gdb 图示"><br><strong>boot.S 图示</strong><br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/6.PNG" title="boot.S 图示"><br><strong>boot.S 的具体分析请阅读【学习笔记03.1 - Lab 1:boot.S】</strong><br><strong>16位模式和32位模式的区别请阅读【计算机原理 - Intel 32 位处理器的工作模式】</strong><br>《x86汇编语言：从实模式到保护模式》一书把实模式和 16 位的保护模式统称为 “ 16 位模式”；把 32 位保护模式称为 “ 32 位模式”。简单来讲， 16 位模式下，处理器把所有指令都看成是 16 位的，数据的大小是 8 位或者 16 位的，控制转移和内存访问时偏移量是 16 位的；32 位模式下，数据的大小是 8 位或者 32 位的，但兼容 80286 的 16 位保护模式。<br>8086 CPU（16位）实模式下数据总线为16位（一次最多能取2^16＝64KB数据，实模式下每个段最大只有64KB），地址总线为20位（寻址的能力是2^20=1MB，实模式下CPU的最大寻址能力），实模式下所有寄存器都是16位。<br>从80386开始CPU数据总线和地址总线均为32位，而且寄存器都是32位。<br><strong>问题 1.什么原因导致了 16 位模式转换为 32 位模式？：</strong> boot.S 首先在实模式下执行 16 位代码，然后切换到保护模式，通过跳转执行 32 位代码。转换到 32 位模式（这里指保护模式）才能访问 1M 以上的地址空间，同时更灵活地进行存储管理，并且对程序能够访问的物理地址进行限制。具体改变是ljmpl指令改变了%cs寄存器，其对应的段描述符由16位变为32位。<br><strong>问题 2.处理器什么时候开始执行 32 位代码？：</strong> 处理器开A20地址线，装载 GDT 表，装载 cr0 为1开启保护模式后，就跳转到 32 位模式中的下一条指令，将处理器切换为 32 位工作模式，从而执行 32 位代码。跳转代码以及执行的第一条 32 位代码见下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    ljmp    $PROT_MODE_CSEG, $protcseg </span><br><span class="line">    ...</span><br><span class="line">    .code32                     # 32 位模式</span><br><span class="line">protcseg: </span><br><span class="line">    movw    $PROT_MODE_DSEG, %ax </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h2 id="引导程序之内核装载"><a href="#引导程序之内核装载" class="headerlink" title="引导程序之内核装载"></a>引导程序之内核装载</h2><p><strong>以下分析尝试解决的问题是：1. boot loader 如何决定读取多少个扇区，而不是从磁盘上获取整个内核，它是从哪里取得信息进行判断的？2.内核程序的第一条指令在哪里？3.boot loader 执行的最后一句指令是什么？4.内核程序装载后执行的第一条指令是什么？</strong><br><strong>bootmain.c 的具体分析请阅读【学习笔记03.3 - Lab 1:bootmain.c】</strong><br><strong>问题 1.boot loader 如何决定读取多少个扇区，而不是从磁盘上获取整个内核，它是从哪里取得信息进行判断的？：</strong> bootmain.c 首先将磁盘第二个扇区文件的前 4KB 读入内存，4KB 为一页，其中包括 ELF 文件头以及程序头表。根据程序头表的信息明确文件段的个数，然后将文件逐段读入内存。逐段读入时，将段在硬盘中的偏移由字节数转换成扇区数，并找到段在内存中加载地址的最末端 end_pa ，以当前加载的物理地址小于 end_pa 为循环条件逐扇区读取。<br><strong>问题 2.内核程序的第一条指令在哪里？：</strong> 装载内核文件到内存后，内核程序的第一条指令在物理地址 0x10000c 处。（eip 为 0x10000c，cs 为 0x8 不变！）（boot loader 的入口地址为 0x7c00，内核文件 ELF 文件读写到内存 0x10000 开始的地方， kernel 的入口地址为 0x10000c，0x10000C 是系统内核的第一条<strong>指令</strong>所在的物理地址处）<br><strong>问题 3.boot loader 执行的最后一句指令是什么？：</strong> 在将内核装载到内存中后转移到内核入口地址处执行，c语言是 ((void (<em>)(void)) (ELFHDR-&gt;e_entry))(); ，指令是 **=&gt; 0x7d61:    call   </em>0x10018<strong>，执行该指令会转移到物理地址 0x10000c 处（直接寻址方式）。   
</strong>问题 4.内核程序装载后执行的第一条指令是什么？：<strong> 通过 gdb 调试，可知内核程序装载后执行的第一条指令是 </strong>=&gt; 0x10000c:    movw   $0x1234,0x472**。  </p>
<h1 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h1><p>了解页表机制、库函数实现机制、内核堆栈<br>内核程序也是通过部分汇编代码进行一些设置，然后跳转到 C 语言代码执行函数。kern/entry.S 第 80 行通过 call i386_init 调用了 kern/inic.c 的 i386_init 函数。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>操作系统内核通常会链接和运行在非常高的线性地址上，这是为了留出处理器的线性地址空间的中低部分给用户程序使用。许多机器没有 0xf0100000 的物理地址，因此不能指望将内核装载在这里。相反，将使用处理器的内存管理硬件映射线性地址 0xf0100000 （内核代码将在该链接地址运行）到物理地址 0x00100000 （引导加载程序加载内核到该物理内存）。这种情况下，内核代码将被装载到物理内存中 1MB 的内存，略高于 BIOS ROM。<br>下次实验将会映射物理地址空间的低 256MB （0x00000000 - 0x0fffffff） 到线性地址（0xf0000000 - 0xffffffff）。现在只需映射物理内存的前 4MB 就足以启动和运行 JOS 内核，这部分工作将通过手写、静态初始化页目录和页表来完成，详见 kern/entrypgdir.c。 kern/entry.S 将设置 CR0_PG 标识符，虚存硬件开始将线性地址映射为物理地址。在标识符设置之前，由于没有开启分页，逻辑地址通过段映射得到的线性地址都被当作物理地址。<strong>（能访问的到的 0 到 4G 的地址空间实际上是线性地址空间，在开启分页机制后，还要经过页表转换才能得到真实地址，而在开启分页之前系统一般会控制只访问低地址。）</strong> entry_pgdir 将 0xf0000000 - 0xf0400000 和 0x00000000 - 0x00400000 的虚拟空间映射到物理空间 0x00000000 - 0x00400000 。使用 qemu 和 gdb 调试，当开始执行内核代码到 <strong>=&gt; 0x100025:    mov    %eax,%cr0</strong> 处后，查看 0x00100000 和 0xf0100000 位置上的内容，将会发现内容一样(注意观察前后的movl汇编指令，可以发现开启分页后就开始使用程序内 KERNBASE 开始的线性地址。):  <a href="http://www.cnblogs.com/tekkaman/p/3506120.html" target="_blank" rel="noopener">gdb之x命令</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/3xw 0x100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe</span><br><span class="line">(gdb) x/3xw 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;:	0x1badb002	0x00000000	0xe4524ffe</span><br></pre></td></tr></table></figure></p>
<p>如果停用页表机制，即注释掉 kern/entry.S 的 movl %eax, %cr0 再重新编译执行，将会在 <strong>=&gt; 0x10002d:    jmp    *%eax</strong> 处出现错误，因为这里存放的是线性地址。<br>为了在进程地址空间中保证多个进程能够读写同样的地址数值，并且保证不同的进程的地址空间不会相互影响，硬件 TLB （Translation Lookaside Buffer）提供了从物理地址到线性地址的抽象映射，称为“页表”。在这里， boot loader 将内核装载进物理地址的低位，而在进程空间模型当中则将内核置于高位，页表正好可以解决此冲突，将物理地址在低位的页表映射到线性地址的高位当中去。<br>在 CPU 当中 %cr0 控制着是否使用页表寻址方式；而 %cr3 则存放页表一级目录基地址。 entry.S 当中第 57~62 行代码就通过修改 %cr3 与 %cr0 寄存器开启了页表机制。</p>
<h2 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h2><p><strong>以下分析尝试解决的问题是：</strong><br>1.在 lab1 中，与实现显示输出相关的文件有 3 个，它们分别是 kern/printf.c、 lib/printfmt.c、 kern/console.c，了解它们之间的关系以及将 printfmt.c 独立到一个库目录的原因。<br>详细信息请阅读【笔记03.4 - Lab 1:控制台输出函数】，一言以蔽之， kern/console.c 完成“如何打印”的逻辑，而 lib/printfmt.c 完成“打印什么”的逻辑，它们的链接纽带就是 kern/printf.c。 kern/printf.c 定义了 cprintf、vcprintf、putch 三个函数， cprintf 功能类似于 C 语言的 printf 函数。 cprintf 初始化后调用 vcprintf， vcprintf 调用了 lib/printfmt.c 定义的 vprintfmt 函数进行输出，并将 kern/printf.c 定义的 putch 函数指针传递给 vprintfmt 函数作为第一个参数， putch 函数的功能是通过调用 kern/console.c 定义的 cputchar 函数将一个字符输出在屏幕上。   </p>
<p>2.解释 printf.c 和 console.c 的接口，特别是 console.c 暴露了什么函数，这些函数又如何被 printf.c 所使用？<br>详细信息请阅读【笔记03.4 - Lab 1:控制台输出函数】， kern/printf.c 中的 putch 函数调用了 kern/console.c 定义的 cputchar 函数， cputchar 函数又调用了 serial_putc(c)、 lpt_putc(c)、 cga_putc(c) 三个函数，分别对应于写串口、写并口、写显示器。（写了串口/并口后，再由 qemu 将串口/并口输出信息打印到控制台，所以输出信息既可以在 qemu 中显示，也可以在控制台显示） </p>
<p>3.解释 console.c 中的代码段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1      if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">2              int i;</span><br><span class="line">3              memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">5                      crt_buf[i] = 0x0700 | &apos; &apos;;</span><br><span class="line">6              crt_pos -= CRT_COLS;</span><br><span class="line">7      &#125;</span><br></pre></td></tr></table></figure></p>
<p>crt_buf 是一个指向 16 位无符号整形数的静态指针，它实际上指向的是内存中物理地址为 0xb8000 的位置，（物理内存的 0xa0000 到 0xc0000 这 128KB 的空间是留给 VGA 显示缓存的，实际上在我们的试验中从 0xb8000 这个位置开始的一部分内存空间便是可以直接与显示屏相关联的显存）。在物理地址超过 0xb8fa0 的内存部分中存储字符数据，此时实际上显示屏就无法显示超过的部分，这个时候通常下显示屏都会滚屏好让最新输出的字符能够显示出来。在每输出一个字符后都先判断 crt_pos 是否大于或等于 CRT_SIZE，而 CRT_SIZE 实际上就是一个屏幕可以输出的字符数，即 80*25。当等于 CRT_SIZE 时，说明此时已经满屏，当大于 CRT_SIZE 时，说明有字符没有显示出来。当满足这两种情况的中的一种时，程序所做的处理是将屏幕上第二行到最后一行的的字符数据复制到第一行到倒数第二行去，然后将屏幕的最后一行输出为空格（并通过 crt_buf[i] = 0x0700 | ‘ ‘; 设置默认字符格式）。  </p>
<p>4.追踪以下代码，了解 x86 平台 GCC 的调用约定。当调用 cprintf() 时， fmt 指向什么？ ap 指向什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure></p>
<p>GCC 的默认函数调用约定是 stdcall。 stdcall 调用约定声明的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int __stdcall function(int a,int b)</span><br></pre></td></tr></table></figure></p>
<p>stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈，3)函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。<br>以上述这个函数为例，参数 b 首先被压栈，然后是参数 a，函数调用 function(1,2) 调用处。  </p>
<p>查看 /obj/kern/kernel.asm 第 61 行，可以看到 /kern/entry.S 最后调用 kern/inic.c 的 i386_init 函数的反汇编结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">61:	call	i386_init</span><br><span class="line">62:f0100039:	e8 5f 00 00 00       	call   f010009d &lt;i386_init&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们可以将上述代码添加到 i386_init 函数入口处（切记需要在调用 cons_init() 之后），删除 obj 目录后重新在 lab 目录下 make，然后启动 qemu 和 gdb。设置断点到 f0100039 处，然后一步一步调试获取结果。在这里 “x %d, y %x, z %d\n” 便是显示字符串，整形变量 x、 y、 z 便是可变参数。在初始化了 va_list 变量 ap 后， ap 便指向了 x 所存放的位置，之后便可以通过 va_arg 宏依次得到变量 x、 y、 z。 %x 代表以无符号 16 进制整数的形式打印出来，如果设置 y = -3，输出 fffffffd，因为 -3 在内存中是以补码的形式存储的，于是在内存中-3 实际上是 fffffffd，所以将它看做是一个无符号数时，打印出来的结果便是 fffffffd。<br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/7.PNG" title="GCC 的调用协定调试"></p>
<p>5.执行以下代码，它的输出是什么？ X86 系列 CPU 都是 little-endian 的字节序，如果你设定了 big-endian ，输出是什么？需要修改 57616 吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure></p>
<p>大小端分析请阅读【计算机原理-大端和小端】。<br>输出 He110 World。因为十进制数 57616 用 16 进制数来表示便是 0xe110。由于无符号整形数 i 是占 4 个字节，而低位数字是存在低地址处。若将这四个字节看做一个字符串，则每个字节代表的就是一个字符的 ASCII 码，所以低位的 0x72 代表的是字符 ‘r’，而最高位的 0x00 代表就是空字符，即标识字符串的结束。于是字符串与 “Wo” 组成了 “World”，所以最终在屏幕上输出了 “He110 World”。如果要想在大端法机器上运行得到相同的结果，i 的值应为 0x726c6400。57616 不需要更改顺序，因为存储时也会采用大端法，所以读出来的十六进制数的顺序不会改变。(注意%x是一次性读出57616并以16进制形式打印，所以即使存储方式不同，读出后仍然一样。而%s是一字节一字节从低地址取出并输出，存储顺序不同则打印顺序不同。)   </p>
<p>6.以下代码在 “y=” 之后将打印什么内容（提示：答案不是一个特殊值）？为什么会出现这种现象？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure></p>
<p>显示出来 y = 1604，是个随机的数字，这是因为可变参数只有一个，而可变参数指针指向的是这一个参数存放的位置，当函数试图去在内存中寻找不存在的第二个参数的时候便会在内存中存放第一个参数之后的位置中去取，而这个位置存放的内容我们无法确定，因此打印出来的便是一个随机的数字。  </p>
<p>7.假设 GCC 修改了调用约定，按照声明顺序将参数进栈，最后声明的参数就最后进栈。如何修改接口使得仍能给 cprintf 传递数量可变的参数？<br><strong>需要注意的是， gcc 的默认调用约定有两个事实，一是 C 程序栈的内存生长方式是往低地址内存生长，这也说明为什么局部变量无法申请太大内存，因为栈内容有限；二是函数参数的入栈的顺序是从右往左的。</strong>  因此，默认情况下，调用 va_start(ap, fmt) 函数时，ap 指向的地址是在 fmt 地址的基础上使用加法得到的（传入的参数在 fmt 字符串的高地址处），va_arg 则是在 ap 地址的基础上使用加法得到的。 jos 系统中，inc/stdarg.h 定义的 va_start 等宏都是使用了编译器内置函数。当进栈顺序变为按照声明顺序时，应该需要修改 inc/stdarg.h 中的宏定义，将 va_start 和 va_arg 改成用减法获得新地址（va_start 仍是基于 fmt 的地址，只是获取 ap 的地址时是通过做减法）。  </p>
<p>8.如何修改 qemu 的控制台颜色？<br>添加 kern/color.h 定义颜色值，kern/monitor.c 添加 setcolor 指令和 mon_setcolor 函数，mon_setcolor 函数接收指令为：setcolor bg=[背景颜色] ch=[字符颜色]，其中字符颜色见新增的 kern/color.h。mon_setcolor 函数去除 “bg=” 和 “ch=” 后调用 kern/console.c 新增的 setcolor(const char <em>bg, const char </em>ch) 函数，判断字符串的值并根据 CGA 的文本模式修改背景颜色和字体颜色，并保存结果，用于设置新输入的字符。    </p>
<p>9.补充使用 “%o” 形式打印八进制数字的部分代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putch(&apos;0&apos;, putdat);</span><br><span class="line">num = getuint(&amp;ap, lflag);</span><br><span class="line">base = 8;</span><br><span class="line">goto number;</span><br></pre></td></tr></table></figure></p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><strong>以下分析尝试解决的问题是：</strong><br>1.内核在哪里初始化堆栈，内核如何给自己的栈留出空间？栈指针一开始在内核栈的哪端？<br>内核在 kern/entry.S 中初始化堆栈。内核初始化堆栈的时候将寄存器 ebp 初始化为 0， esp 初始化为 bootstacktop。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"># boot stack</span><br><span class="line">###################################################################</span><br><span class="line">	.p2align	PGSHIFT		# force page alignment</span><br><span class="line">	.globl		bootstack</span><br><span class="line">bootstack:</span><br><span class="line">	.space		KSTKSIZE</span><br><span class="line">	.globl		bootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></table></figure></p>
<p>栈的空间定义在 ELF 的 data 字段，载入内核时根据 data 段在 ELF 文件中的相对位置被载入内存。栈有两部分，第一部分是实际栈空间，一共 <code>KSTKSIZE = 8*PGSIZE = 8*4096B = 32KB</code>。 第二部分是栈底指针 bootstacktop， 指向栈空间定义以后的高地址位置。  </p>
<p>2.熟悉 Linux 的 c 语言调用约定，在 obj/kern/kernel.asm 中找到 test_backtrace 函数的地址，设置断点，检查在内核启动后该函数每次被调用时的变化。test_backtrace 每次递归嵌套会将什么内容进栈？请按照以下形式输出，其中第一行映射到当前执行函数，第二行映射到调用它的函数，以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>查看 test_backtrace 函数的汇编代码，如下：<br><img src="/2017/08/20/笔记03-Lab-1-Booting-a-PC/8.PNG" title="汇编代码"><br>可以看出一共有四类栈空间被使用，分别是：77 行 %ebp 入栈；79 行 %ebx 入栈以保护现场；80 行出栈顶指针下移 20 字节，作为临时变量存储，包括 call 其他函数时，传给该函数的参数也放在这部分空间里；92 行 call 时（递归）自动将 eip 入栈。共 4 + 4 + 20 + 4 = 32 byte 空间压栈。<strong>可阅读【笔记03.5 - Lab 1:Jos内核】进一步了解。</strong>为了输出  kern/monitor.c 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">mon_backtrace(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	// Your code here.</span><br><span class="line">	uint32_t *ebp, eip;</span><br><span class="line">	uint32_t arg0, arg1, arg2, arg3, arg4;</span><br><span class="line">	ebp = (uint32_t*)read_ebp();</span><br><span class="line">	eip = ebp[1];</span><br><span class="line">	arg0 = ebp[2];</span><br><span class="line">	arg1 = ebp[3];</span><br><span class="line">	arg2 = ebp[4];</span><br><span class="line">	arg3 = ebp[5];</span><br><span class="line">	arg4 = ebp[6]; </span><br><span class="line">	cprintf(&quot;Stack backtrace:\n&quot;);</span><br><span class="line">	/*</span><br><span class="line">	当发现 ebp 的值为 0 时便停止循环。</span><br><span class="line">	因为最外层的程序是 kern/entry.S 中的入口程序，记得在之前我们看到过入口程序中有一句代码是“ movl $0x0,%ebp”，也就是说在入口程序调用 i386_init 函数之前便把 ebp 的值置为 0，也就是说入口程序的 ebp 实际上为 0</span><br><span class="line">	*/</span><br><span class="line">	while(ebp != 0)&#123;</span><br><span class="line">		cprintf(&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;,</span><br><span class="line">			ebp,eip,arg0,arg1,arg2,arg3,arg4);</span><br><span class="line">		ebp = (uint32_t*)ebp[0]; // 0x0[%ebp] 可以读出上个函数的栈指针</span><br><span class="line">		eip = ebp[1];</span><br><span class="line">		arg0 = ebp[2];</span><br><span class="line">		arg1 = ebp[3];</span><br><span class="line">		arg2 = ebp[4];</span><br><span class="line">		arg3 = ebp[5];</span><br><span class="line">		arg4 = ebp[6]; </span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.如何实现“输出函数调用者的栈地址，并输出跟这些地址关联的函数名”？请完成 kern/kdebug.c 中 debuginfo_eip 的实现过程，加入调用 stab_binsearch 的实现。在内核监视部分添加 backtrace 命令，完成 mon_backtrace 的实现过程，加入调用 debuginfo_eip 以实现输出关联的函数名和行号。<br>这里需要看一下符号表里的结构。用 objdump -G obj/kern/kernel 指令查看 stab，发现在每一种类型（SO/SLINE/…）中都会按照地址的顺序逐渐有行号的递增。仿照 debuginfo_eip 函数里对 SO/FUN （文件名/函数名）的写法，使用 stab_binsearch 这个给定的二分查找方法，找到对应的行数，然后取出行号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">if (lline &gt; rline)</span><br><span class="line">    info-&gt;eip_line = -1;</span><br><span class="line">else</span><br><span class="line">    info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure></p>
<p>修改后的 kern/monitor.c 文件的 mon_backtrace 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">mon_backtrace(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123; </span><br><span class="line">	// Your code here.</span><br><span class="line">	uint32_t *ebp, eip;</span><br><span class="line">	uint32_t arg0, arg1, arg2, arg3, arg4;</span><br><span class="line">	ebp = (uint32_t*)read_ebp();</span><br><span class="line">	eip = ebp[1];</span><br><span class="line">	arg0 = ebp[2];</span><br><span class="line">	arg1 = ebp[3];</span><br><span class="line">	arg2 = ebp[4];</span><br><span class="line">	arg3 = ebp[5];</span><br><span class="line">	arg4 = ebp[6]; </span><br><span class="line">	cprintf(&quot;Stack backtrace:\n&quot;);</span><br><span class="line">	/*</span><br><span class="line">	当发现 ebp 的值为 0 时便停止循环。</span><br><span class="line">	因为最外层的程序是 kern/entry.S 中的入口程序，记得在之前我们看到过入口程序中有一句</span><br><span class="line">	代码是“ movl $0x0,%ebp”，也就是说在入口程序调用 i386_init 函数之前便把 ebp 的值置</span><br><span class="line">	为 0，也就是说入口程序的 ebp 实际上为 0</span><br><span class="line">	*/</span><br><span class="line">	while(ebp != 0)&#123;</span><br><span class="line">		cprintf(&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;,</span><br><span class="line">			ebp,eip,arg0,arg1,arg2,arg3,arg4);</span><br><span class="line">		struct Eipdebuginfo info;</span><br><span class="line"></span><br><span class="line">		if(debuginfo_eip(eip, &amp;info) == 0)&#123;</span><br><span class="line">			//file name : line</span><br><span class="line">	    	cprintf(&quot;\t%s:%d: &quot;, info.eip_file, info.eip_line);</span><br><span class="line">	    	//function name + the offset of the eip from the first instruction of the function</span><br><span class="line">	    	//注意：printf(&quot;%.*s&quot;, length, string)打印string的至多length个字符</span><br><span class="line">	      	cprintf(&quot;%.*s+%d\n&quot;, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">	    &#125; </span><br><span class="line"></span><br><span class="line">		ebp = (uint32_t*)ebp[0];</span><br><span class="line">		eip = ebp[1];</span><br><span class="line">		arg0 = ebp[2];</span><br><span class="line">		arg1 = ebp[3];</span><br><span class="line">		arg2 = ebp[4];</span><br><span class="line">		arg3 = ebp[5];</span><br><span class="line">		arg4 = ebp[6]; </span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记02-HW01-x86-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记02-HW01-x86-shell/" itemprop="url">笔记02 - HW01: x86 shell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:02:52+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MIT 6.828 LEC1作业部分，实现shell重定向&lt;&gt;和管道|。<br>代码详见：<a href="https://github.com/jianzzz/6.828-HW/tree/master/homework01/shellCommandsParser" target="_blank" rel="noopener">github: jianzzz</a> </p>
<h1 id="使用方式1"><a href="#使用方式1" class="headerlink" title="使用方式1"></a>使用方式1</h1><p>$ gcc sh.c 编译以后产生 a.out 文件<br>执行$ ./a.out<br>分别输入以下命令：<br>ls &gt; y<br>cat &lt; y | sort | uniq | wc &gt; y1<br>cat y1<br>rm y1<br>ls |  sort | uniq | wc<br>rm y  </p>
<h1 id="使用方式2"><a href="#使用方式2" class="headerlink" title="使用方式2"></a>使用方式2</h1><p>将上述命令复制到 t.sh 中，执行$ ./a.out &lt; t.sh  </p>
<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="解析命令过程"><a href="#解析命令过程" class="headerlink" title="解析命令过程"></a>解析命令过程</h2><p>main函数按行读取命令，对于每一条命令，先创建子进程，然后调用parsecmd函数解析命令，并对parsecmd函数解析结果调用runcmd执行命令。  </p>
<p>parsecmd函数处理命令字符串首尾指针后调用parseline函数，parseline函数调用parsepipe解析命令。  </p>
<p>parsepipe函数首先调用parseexec函数解析第一个子命令（如果存在管道符号，则是第一个管道符号前的命令），返回解析的cmd结构体；如果存在管道符号，则递归调用parsepipe自身解析后面的命令，返回解析的cmd结构体；然后调用pipecmd命令将前后的两个结构体整合为管道cmd结构体。  </p>
<p>parseexec函数解析子命令的退出条件是遇到管道符号。如果没有碰到管道符号，则解析紧接着的参数，如上述第二条命令的cat，接着调用parseredirs函数判断当前是否是I/O重定向（是否遇到了&lt;&gt;符号），是的话则读取重定向符号右端的参数（重定向文件），然后将重定向符号左端的cmd对象、重定向符号、重定向符号右端的重定向文件整合为重定向cmd结构体。    </p>
<p>仔细阅读parseexec函数，cmd结构体强制转换为execcmd结构体，存储到execcmd结构体指针所指地址的数据实际上都存到了cmd结构体指针所指地址。在while循环中，如果碰到了重定向符&lt;&gt;，cmd结构体指针将被包含于redircmd结构体中（redircmd函数），redircmd结构体强制转换为cmd结构体后返回，此刻parseexec函数中cmd结构体指针真正指向的数据其实是redircmd结构体的数据，并且该redircmd结构体中的cmd指针真正指向的数据其实是execcmd结构体的数据；如果parseexec函数的while循环执行到此还没遇到到管道符|，则表示重定向符&lt;&gt;右端的参数个数大于1（如：cat &lt; file -n），新读入的参数继续存储到execcmd结构体中，即cmd结构体指针所指的内存地址，即redircmd结构体中的cmd指针所指的内存地址。注意到：redircmd结构体只是存储了cmd结构体指针，因此新读入的参数继续存储到execcmd结构体中（即redircmd结构体中的cmd指针所指）并不会影响到redircmd结构体其他值的存储。    </p>
<p>另一方面，可以观察出，pipecmd、redircmd等复杂结构体包含的命令对象指针是最简单的cmd结构体类型，而在传参和返回值方面，都会转换成cmd类型。这是可以学习的编程设计技巧。    </p>
<h2 id="执行命令过程"><a href="#执行命令过程" class="headerlink" title="执行命令过程"></a>执行命令过程</h2><p>以cat &lt; y | sort | uniq | wc &gt; y1简要说明：<br>判断命令的类型，<br>1、如果是管道命令，则开启两个子线程分别负责管道左端和右端命令，父进程负责wait。fork之后，父进程和子进程都有指向管道的文件描述符。子线程c1关闭管道读端，将标准输出指向管道写端，然后执行左端命令如cat &lt; y，执行结果将缓冲到标准输出即管道写端。子线程c2关闭管道写端，将标准输入指向管道读端，然后c2调用runcmd执行右端命令，如sort | uniq | wc &gt; y1。c2子线程将作为父进程创建新的管道和新的两个子线程，c21将标准输出指向管道写端后执行sort，c22将标准输入指向管道读端后执行uniq | wc &gt; y1。由于c1、c2，c21、c22执行顺序是不一定的，有可能出现c1进程还没执行完cat &lt; y（还没写入到标准输出），c21已经重定向了标准输出，则c21执行sort时无法从标准输入读取到cat的结果；又或者是，sort命令还没从标准输入读取数据，c22线程已经重定向了标准输入，导致sort无法读取结果。<strong>个人解决方案是先调用wait让第一个线程完成工作。</strong><br>2、如果是重定向命令，则根据命令的模式打开文件，注意如果是写入到文件，需要保证所有者可以读写文件；根据命令fd重定向标准输入/输出符后执行命令。<br>3、如果是普通执行命令，则调用execv，注意到exec函数执行成功后不返回到调用程序，所以可在exec函数调用后面编写执行失败检查代码。execv命令对象需要完整执行路径。也可以使用execvp函数，则无需完整执行路径。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/20/笔记01-x86-v6-book-Chapter-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/笔记01-x86-v6-book-Chapter-0/" itemprop="url">笔记01 - x86 v6 book | Chapter 0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T21:00:13+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MIT6-828-Operating-System-Engineering/" itemprop="url" rel="index">
                    <span itemprop="name">MIT6.828 Operating System Engineering</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是xv6"><a href="#什么是xv6" class="headerlink" title="什么是xv6?"></a>什么是xv6?</h1><p>xv6是Dennis Ritchie 和 Ken Thompson的Unix Version 6再实现版本。xv6大致延续v6的结构和风格，但使用ANSI C，并基于x86−多处理器被重新设计。</p>
<h1 id="什么是OS"><a href="#什么是OS" class="headerlink" title="什么是OS?"></a>什么是OS?</h1><p>An operating system is a program that manages a computer’s hardware. 一个操作系统是用来管理计算机硬件的一种程序。 The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. 操作系统的工作是保证在多个程序间共享一台计算机并提供一个比单独硬件支持更有用的服务。It also multiplexes the hardware, allowing many programs to share the computer and run (or appear to run) at the same time. 它还多路传输硬件资源,允许许多程序在同一时间共享电脑和运行(或出现运行)。Finally, operating systems provide controlled ways for programs to interact, so that they can share data or work together. 最后,操作系统提供程序交互的控制方法,确保程序可以共享数据或一起工作。<br>看待OS的两种视图：<br>The small view: a h/w management library. 小视图：OS是一个硬件管理库。<br>The big view: physical machine -&gt; abstract one w/ better properties. 大视图：对物理机的抽象，使其具备更好写性能。</p>
<h1 id="system-call-系统调用是什么？"><a href="#system-call-系统调用是什么？" class="headerlink" title="system call 系统调用是什么？"></a>system call 系统调用是什么？</h1><p>When a process needs to invoke a kernel service, it invokes a procedure call in the operating system interface. Such a procedure is called a system call. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in user space and kernel space. 当一个进程需要调用内核服务时，它会在操作系统接口调用一个过程调用。这样的过程称为系统调用。该系统调用进入内核，内核执行服务和返回。这样一个过程在用户空间和内核空间之间的交替执行。The kernel uses the CPU’s hardware protection mechanisms to ensure that each process executing in user space can access only its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel. 内核使用CPU的硬件保护机制，确保每个在用户空间执行的过程只能访问自己的内存。内核执行有硬件特权，以实现这些保护；用户程序执行没有这些特权。当一个用户程序调用系统调用，硬件提高特权水平并开始在内核中执行一个预先安排的函数。</p>
<h1 id="xv6-process-进程"><a href="#xv6-process-进程" class="headerlink" title="xv6 process 进程"></a>xv6 process 进程</h1><p>An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. 一个xv6进程由用户空间内存(指令、数据和堆栈)和进程状态组成，进程状态相对于内核来说是私有的。The instructions implement the program’s computation. The data are the variables on which the computation acts. The stack organizes the program’s procedure calls.指令实现了程序计算。数据是计算行为过程中的变量。堆栈组织了程序的过程调用。 Xv6 can time-share processes: it transparently switches the available CPUs among the set of processes waiting to execute. xv6进程是分时共享的，可以在等待执行的进程集合中透明地转变可用的CPU资源。When a process is not executing, xv6 saves its CPU registers, restoring them when it next runs the process. 当一个进程没被执行，xv6保存它的CPU寄存器并在下次执行的时候进行重建。The kernel associates a process identifier, or pid, with each process. 内核通过进程标识符或pid来关联一个进程。A process may create a new process using the fork system call.一个进程可通过fork系统调用来创建一个新进程。  </p>
<h1 id="fork-函数做了什么？"><a href="#fork-函数做了什么？" class="headerlink" title="fork()函数做了什么？"></a>fork()函数做了什么？</h1><p>复制用户内存<br>&#160; &#160; &#160; &#160;复制进程内核状态（e.g. user id）<br>子进程得到不同的PID<br>子进程状态包含父进程PID<br>以不同的值返回两次（在父进程中，fork返回新创建子进程的进程ID；在子进程中，fork返回0；如果出现错误，fork返回一个负值）</p>
<h1 id="exec-函数做了什么？"><a href="#exec-函数做了什么？" class="headerlink" title="exec()函数做了什么？"></a>exec()函数做了什么？</h1><p>用新内存镜像（从特定格式文件加载而来）替代当前正执行的进程内存<br>&#160; &#160; &#160; &#160;xv6使用ELF格式的文件<br>执行成功后不返回到调用程序，相反，由文件加载而来的指令开始在ELF头声明的入口点处开始执行<br>包含两个参数:可执行文件的名称和字符串数组参数</p>
<p>fork allocates the memory required for the child’s copy of the parent’s memory, and exec allocates enough memory to hold the executable file. fork从父进程内存中复制，分配了子进程需要的内存。exec分配了足够的内存以控制可执行文件。</p>
<h1 id="file-descriptor-文件描述符是什么？"><a href="#file-descriptor-文件描述符是什么？" class="headerlink" title="file descriptor 文件描述符是什么？"></a>file descriptor 文件描述符是什么？</h1><p>A file descriptor is a small integer representing a kernel-managed object that a process may read from or write to.一个文件描述符是一个非负小整数，代表了一个内核管理对象。进程可通过文件描述符进行读写。Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. xv6内核内部使用文件描述符作为每个进程表的索引，每个进程都拥有文件描述符的私有空间（由0开始），（实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。）。By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). 习惯上，标准输入的文件描述符是 0，标准输出是 1，标准错误是 2。The shell ensures that it always has three ﬁle descriptors open, which are by default ﬁle descriptors for the console. Shell确保总是有三个文件描述符打开，这也是控制台的默认文件描述符。The close system call releases a ﬁle descriptor, making it free for reuse by a future open, pipe, or dup system call. close系统调用会释放文件描述符，使其可被<strong>open， pipe或者dup</strong>系统调用所重用。 A newly allocated ﬁle descriptor is always the lowest-numbered unused descriptor of the current process. <strong>一个新分配的文件描述符总是当前进程序号最小的未使用的描述符。</strong></p>
<p><a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">以下内容来自wiki</a><br><img src="/2017/08/20/笔记01-x86-v6-book-Chapter-0/1.png" title="文件描述符"><br>上图是一个进程的文件描述符表、file表和inode表。注意到不同的文件描述符可以指向相同的file表项(比如dup系统调用的结果)，以及多个不同的file表项可以指向相同的inode(比如文件被多次打开，inode表仍然保持精简，因为inode表通过文件名来标识inodes–即使inode可以有多个名字)。File descriptor 3不指向任何file，表明它被关闭了。</p>
<p>对于virtual file system (VFS)，以上结构则有所变化。VFS是具体文件系统之上的一个抽象层，其目的是允许客户机应用程序以统一的方式访问不同类型的具体文件系统。参考<a href="http://www.makelinux.net/books/lkd2/ch12lev1sec7" target="_blank" rel="noopener">Linux kernel map in printable PDF</a>，可知VFS将目录当作files。在路径/bin/vi下，bin和vi都是files。bin是特殊的directory file，vi是regular file，存在一个inode同时代表这两个components。尽管存在这种统一，VFS经常需要执行一些目录操作，比如路径名查询。路径名查询涉及转换每个component的路径，确保它是有效的，然后继续查询下一个component。因此，VFS提出了目录条目(dentry)的概念，一个dentry是一个路径下的一个特定组件。比如说，/、bin、vi都是dentry对象。/和bin是directory，vi是regular file。这存在一个很重要的观点：<strong>dentry objects are all components in a path，including files。</strong>解析一个路径并遍历它的组件耗时且充斥着字符串比较，dentry对象使得整个过程变得更加容易。dentry还可能包括挂载点。路径/mnt/cdrom/foo下，组件/、mnt、cdrom\foo都是dentry对象。当执行目录操作时，VFS根据需要构造出dentry对象。</p>
<p><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html" target="_blank" rel="noopener">以下是某篇博客对上述内容的简介</a><br>&#160; &#160; &#160; &#160;内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程.<br>&#160; &#160; &#160; &#160;file对象中包含一个指针，指向dentry对象。dentry对象代表一个独立的文件路径，如果一个文件路径被打开多次，那么会建立多个file对象，但它们都指向同一个dentry对象。<br>&#160; &#160; &#160; &#160;dentry对象中又包含一个指向inode对象的指针。inode对象代表一个独立文件。因为存在硬链接与符号链接，因此不同的dentry对象可以指向相同的inode对象。inode 对象包含了最终对文件进行操作所需的所有信息，如文件系统类型、文件的操作方法、文件的权限、访问日期等。<br>&#160; &#160; &#160; &#160;打开文件后，进程得到的文件描述符实质上就是文件描述符表的下标，内核根据这个下标值去访问相应的文件对象，从而实现对文件的操作。<br><img src="/2017/08/20/笔记01-x86-v6-book-Chapter-0/2.jpg" title="文件描述符表"><br>&#160; &#160; &#160; &#160;注意，同一个进程多次打开同一个文件时，内核会创建多个file对象。<br>&#160; &#160; &#160; &#160;当进程使用fork系统调用创建一个子进程后，子进程将继承父进程的文件描述符表，因此在父进程中打开的文件可以在子进程中用同一个描述符访问。<br><img src="/2017/08/20/笔记01-x86-v6-book-Chapter-0/3.jpg" title="文件描述符表"></p>
<h1 id="Why-there-are-actually-one-page-table-per-process-为什么通常一个进程一个页表，而不是整个系统一张页表？"><a href="#Why-there-are-actually-one-page-table-per-process-为什么通常一个进程一个页表，而不是整个系统一张页表？" class="headerlink" title="Why there are actually one page table per process?为什么通常一个进程一个页表，而不是整个系统一张页表？"></a>Why there are actually one page table per process?为什么通常一个进程一个页表，而不是整个系统一张页表？</h1><p>Page tables are used to translate the virtual addresses seen by the application into physical addresses used by the hardware to process instructions; 页表被用来将应用程序看到的线性地址转换为硬件处理指令所用的物理地址。such hardware that handles this specific translation is often known as the memory management unit. 负责这种特定转换的硬件是内存管理单元。Each entry in the page table holds a flag indicating whether the corresponding page is in real memory or not. If it is in real memory, the page table entry will contain the real memory address at which the page is stored.页表中的每个条目使用标志指示是否对应于实际内存中的页面。如果是，页表条目将包含页面存储的真正的内存地址。If the page table entry for the page indicates that it is not currently in real memory, the hardware raises a page fault exception, invoking the paging supervisor component of the operating system. 如果页表条目表明页面目前不在实际内存中，硬件产生一个页错误异常，请求操作系统的分页管理组件。<br>Systems can have one page table for the whole system, separate page tables for each application and segment, a tree of page tables for large segments or some combination of these. 系统可以为整个系统设计一个页表，或每个应用程序和段拥有单独的页表，或为大段或它们的一些组合设计页表树。If there is only one page table, different applications running at the same time use different parts of a single range of virtual addresses. 如果只有一个页表，同时运行的不同应用程序使用一个范围内的线性地址的不同部分。If there are multiple page or segment tables, there are multiple virtual address spaces and concurrent applications with separate page tables redirect to different real addresses. 如果有多个页面或分段表，将存在多个线性地址空间，拥有单独页表的并发的应用程序将被重定向到不同的真实地址。<br>A page table usually has a fixed number of entries and therefore describes only a portion of the entire virtual address space. This is why you need multiple of them to cover the entire address space. 页表通常有固定数量的条目，因此只描述了整个线性地址空间的一部分。这就是为什么需要多个页表来覆盖整个地址空间。Now, in many OSes processes have individual (in other words, not shared with others) virtual address spaces, which helps to protect processes from one another. This is another reason for having multiple page tables.在许多操作系统过程中存在个人线性地址空间(换句话说，不与他人分享)，这有助于保护进程，这是拥有多个页表的另一个原因。</p>
<h1 id="Why-fork-and-exec-are-not-combined-in-a-single-call-separate-calls-for-creating-a-process-and-loading-a-program-为什么fork和exec不整合为一个简单的系统调用（为什么对创建进程和加载程序分别操作）？"><a href="#Why-fork-and-exec-are-not-combined-in-a-single-call-separate-calls-for-creating-a-process-and-loading-a-program-为什么fork和exec不整合为一个简单的系统调用（为什么对创建进程和加载程序分别操作）？" class="headerlink" title="Why fork and exec are not combined in a single call (separate calls for creating a process and loading a program) ? 为什么fork和exec不整合为一个简单的系统调用（为什么对创建进程和加载程序分别操作）？"></a>Why fork and exec are not combined in a single call (separate calls for creating a process and loading a program) ? 为什么fork和exec不整合为一个简单的系统调用（为什么对创建进程和加载程序分别操作）？</h1><p>File descriptors and fork interact to make I/O redirection easy to implement. 文件描述符和fork相互作用，容易实现I/O重定向。Fork copies the parent’s ﬁle descriptor table along with its memory, so that the child starts with exactly the same open ﬁles as the parent.fork复制了父进程的文件描述符表和内存，子进程开始执行时拥有相同的被打开的文件。 The system call exec replaces the calling process’s memory but preserves its ﬁle table. exec替代了当前调用进程的内存，但保留了文件描述符表。 This behavior allows the shell to implement I/O redirection by forking, reopening chosen ﬁle descriptors, and then execing the new program.     这个行为允许了Shell实现I/O重定向：fork创建子进程，重打开被关闭的文件描述符，最后exec执行新程序。<br>e.g.  cat &lt; input.txt 实现cat重定向<br>子进程关闭了文件描述符0后，由于0是当前最小的可用文件描述符，确保了open可以使用它。cat开始执行，并以文件描述符0（标准输入）为索引指向了input.txt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *argv[2];</span><br><span class="line">argv[0] = &quot;cat&quot;; </span><br><span class="line">argv[1] = 0; </span><br><span class="line">if(fork() == 0) &#123; //创建子进程</span><br><span class="line">    close(0); //子进程释放文件描述符0（标准输入）</span><br><span class="line">    open(&quot;input.txt&quot;, O_RDONLY); //文件描述符0（标准输入）指向了input.txt</span><br><span class="line">    exec(&quot;cat&quot;, argv);//执行cat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The code for I/O redirection in the xv6 shell works in exactly this way. xv6 shell也是以这种方式进行I/O重定向的。Recall that at this point in the code the shell has already forked the child shell and that runcmd will call exec to load the new program. 回想一下，此时在代码中shell已经通过fork创建子进程shell，runcmd将调用exec加载新程序。Now it should be clear why it is a good idea that fork and exec are separate calls. 现在应该清楚为什么fork和exec单独调用是一个好主意。This separation allows the shell to ﬁx up the child process before the child runs the intended program.这种分离允许shell在子进程运行目标程序前对子线程进程修正。 </p>
<h1 id="How-two-ﬁle-descriptors-share-the-same-file-offset-两个文件描述符如何共享相同的文件偏移"><a href="#How-two-ﬁle-descriptors-share-the-same-file-offset-两个文件描述符如何共享相同的文件偏移" class="headerlink" title="How two ﬁle descriptors share the same file offset? 两个文件描述符如何共享相同的文件偏移?"></a>How two ﬁle descriptors share the same file offset? 两个文件描述符如何共享相同的文件偏移?</h1><p>文件描述符会伴随着文件偏移地址，read和write系统调用会更新文件读写指针的偏移地址，共享了文件描述符则表示可以分别操作不同的文件描述符，使其作用于同一个文件。<br>Two ﬁle descriptors share an oﬀset if they were derived from the same original ﬁle descriptor by a sequence of fork and dup calls. 如果两个文件描述符来自于同一个原始的文件描述符（通过fork和dup系统调用），则它们使用相同的文件偏移。Otherwise ﬁle descriptors do not share oﬀsets, even if they resulted from open calls for the same ﬁle. 否则文件描述符不会共享文件偏移，即使是由open系统调用打开相同文件所产生的文件描述符。<br>e.g. write hello world into a ﬁle by fork<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(fork() == 0) &#123; </span><br><span class="line">    write(1, &quot;hello &quot;, 6); </span><br><span class="line">    exit(); </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    wait(); </span><br><span class="line">    write(1, &quot;world\n&quot;, 6); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>e.g. write hello world into a ﬁle by dup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(1); </span><br><span class="line">write(1, &quot;hello &quot;, 6); </span><br><span class="line">write(fd, &quot;world\n&quot;, 6);</span><br></pre></td></tr></table></figure></p>
<p>The dup system call duplicates an existing ﬁle descriptor, returning a new one that refers to the same underlying I/O object.  dup复制现有的文件描述符，返回一个指向相同底层I/O对象的新的文件描述符。Dup allows shells to implement commands like this: ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the command a ﬁle descriptor 2 that is a duplicate of descriptor 1. dup告诉shell文件描述符2复制于文件描述符1。 Both the name of the existing ﬁle and the error message for the non-existing ﬁle will show up in the ﬁle tmp1. 结果是现有的文件名称和不存在的文件错误消息将出现在tmp1文件。 The xv6 shell doesn’t support I/O redirection for the error ﬁle descriptor, but now you know how to implement it. xv6 shell不支持错误文件描述符的I/O重定向，我们可以通过上述方式进行实现。</p>
<h1 id="What-is-pipe-什么是管道"><a href="#What-is-pipe-什么是管道" class="headerlink" title="What is pipe? 什么是管道?"></a>What is pipe? 什么是管道?</h1><p>A pipe is a small kernel buﬀer exposed to processes as a pair of ﬁle descriptors, one for reading and one for writing. 管道是一个小的内核缓冲区，以一对文件描述符的形式暴露给进程，一个用于读，一个用于写。Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. 向管道的一端写入数据，使数据可用于管道另一端读取。Pipes provide a way for processes to communicate.管道提供了一种进程交互的方式。<br>e.g. wc 标准输入连向管道的读端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int p[2]; </span><br><span class="line">char *argv[2];</span><br><span class="line">argv[0] = &quot;wc&quot;; </span><br><span class="line">argv[1] = 0;</span><br><span class="line">pipe(p); //创建管道，记录读、写文件描述符到数组p中</span><br><span class="line">//fork之后，父进程和子进程都有指向管道的文件描述符</span><br><span class="line">if(fork() == 0) &#123; </span><br><span class="line">    close(0); //释放标准输入文件描述符0</span><br><span class="line">    dup(p[0]); //复制管道读端到标准输入文件描述符0</span><br><span class="line">    close(p[0]); //关闭管道读端</span><br><span class="line">    close(p[1]); //关闭管道写端</span><br><span class="line">    exec(&quot;/bin/wc&quot;, argv); //执行wc，wc会从标准输入中读取，即从管道读端读取</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    write(p[1], &quot;hello world\n&quot;, 12); //向管道写端写入</span><br><span class="line">    close(p[0]); //关闭管道读端</span><br><span class="line">    close(p[1]); //关闭管道写端</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>If no data is available, a read on a pipe waits for either data to be written or all ﬁle descriptors referring to the write end to be closed; 如果没有可用的数据，管道读端会阻塞等待，直到数据写入或者所有指向写端的文件描述符被关闭。in the latter case, read will return 0, just as if the end of a data ﬁle had been reached. 在后一种情况下，read会返回0，如同达到了文件末尾。The fact that read blocks until it is impossible for new data to arrive is one reason that it’s important for the child to close the write end of the pipe before executing wc above: if one of wc’s ﬁle descriptors referred to the write end of the pipe, wc would never see end-of-ﬁle. 子进程执行wc之前将写端关闭的一个重要原因是：读端会一直阻塞直到不可能出现新数据（关闭了所有写端）。如果存在指向写端的文件描述符没被关闭（如子线程未关闭），wc将不会看到文件的末尾，因为读端一直阻塞。<br>The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similar to the above code (8450).xv6 shell以类似的方式实现管道，例如grep fork sh.c | wc -l。 The child process creates a pipe to connect the left end of the pipeline with the right end. 子进程创建管道来连接管道的左端和右端。Then it calls runcmd for the left end of the pipeline and runcmd for the right end, and waits for the left and the right ends to ﬁnish, by calling wait twice. 然后子进程在左端和右端调用runcmd，并且两次调用wait等待左端和右端结束。The right end of the pipeline may be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new child processes (one for b and one for c). Thus, the shell may create a tree of processes.管道的右端可能是包含管道的命令（可以察觉到，管道右端的命令将在子线程中实现）。因此，shell可能创建一棵进程树。 The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete. 进程树的叶子节点是命令，内部节点是进程，进程将wait直至左右孩子节点完成工作。</p>
<h1 id="What’s-the-diﬀerences-between-pipes-and-temporary-ﬁles-管道和临时文件之间的差别是什么"><a href="#What’s-the-diﬀerences-between-pipes-and-temporary-ﬁles-管道和临时文件之间的差别是什么" class="headerlink" title="What’s the diﬀerences between pipes and temporary ﬁles? 管道和临时文件之间的差别是什么?"></a>What’s the diﬀerences between pipes and temporary ﬁles? 管道和临时文件之间的差别是什么?</h1><p>Pipes may seem no more powerful than temporary ﬁles: the pipeline<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure></p>
<p>could be implemented without pipes as<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz;   </span><br><span class="line">wc &lt; /tmp/xyz</span><br></pre></td></tr></table></figure></p>
<p>There are at least three key diﬀerences between pipes and temporary ﬁles. First, pipes automatically clean themselves up; with the ﬁle redirection, a shell would have to be careful to remove /tmp/xyz when done. 差别1，管道自动清理（缓冲区），文件重定向时shell必须在工作结束后小心移除临时文件。Second, pipes can pass arbitrarily long streams of data, while ﬁle redirection requires enough free space on disk to store all the data. 差别2，管道能传递任意长度的数据流，文件重定向要求足够大的硬盘空间来存储所有数据。Third, pipes allow for synchronization: two processes can use a pair of pipes to send messages back and forth to each other, with each read blocking its calling process until the other process has sent data with write.差别3：管道允许同步：两个进程可以使用一对管道来回发送消息，每个read阻塞调用进程直到其他线程使用write发送数据。</p>
<h1 id="xv6-ﬁle-system-文件系统"><a href="#xv6-ﬁle-system-文件系统" class="headerlink" title="xv6 ﬁle system 文件系统"></a>xv6 ﬁle system 文件系统</h1><p>The xv6 ﬁle system provides data ﬁles, which are uninterpreted byte arrays, and directories, which contain named references to data ﬁles and other directories.xv6文件系统提供数据文件，包括未解释字节数组和目录，目录包含了被命名的数据文件的引用和其他目录。 Xv6 implements directories as a special kind of ﬁle. xv6将目录实现为一种特殊的文件。The directories form a tree, starting at a special directory called the root.目录形成了一棵树，从一个特殊的目录root开始。<br><strong>create a new device ﬁle: mknod(“/console”, 1, 1);</strong><br>Mknod creates a ﬁle in the ﬁle system, but the ﬁle has no contents. Mknod创建文件系统中的一个文件，但这个文件没有内容。Instead, the ﬁle’s metadata marks it as a device ﬁle and records the major and minor device numbers (the two arguments to mknod), which uniquely identify a kernel device. 相反，文件的元数据将其标记为一个设备文件，并且记录了主次设备号，设备号唯一标识了一个内核设备。（主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。）When a process later opens the ﬁle, the kernel diverts read and write system calls to the kernel device implementation instead of passing them to the ﬁle system. 当进程后面打开文件时，内核将read和write系统调用转移到内核设备实现，而不是将他们传递到文件系统。<br>The ﬁle’s inode and the disk space holding its content are only freed when the ﬁle’s link count is zero and no ﬁle descriptors refer to it. 只有当文件链接数为0而且没有文件描述符指向它时，文件的inode和磁盘空间时才释放其内容文件。<br>Furthermore, an idiomatic way to create a temporary inode that will be cleaned up when the process closes fd or exits is: 此外，可按照以下惯用方式创建一个临时inode，当进程关闭fd或者离开的时候，该inode将被清理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR); </span><br><span class="line">unlink(&quot;/tmp/xyz&quot;);</span><br></pre></td></tr></table></figure></p>
<p>Xv6 commands for ﬁle system operations are implemented as user-level programs such as mkdir, ln, rm, etc. This design allows anyone to extend the shell with new user commands. xv6文件系统操作命令实现为用户级程序。这种设计运行任何人以新用户命令扩展shell（其他系统一般内置到shell里）。 One exception is cd, which is built into the shell (8516).cd命令除外，它是内置到shell的。 cd must change the current working directory of the shell itself. If cd were run as a regular command, then the shell would fork a child process, the child process would run cd, and cd would change the child’s working directory. The parent’s (i.e., the shell’s) working directory would not change. cd必须改变shell本身的当前工作目录。如果cd作为常规命令执行，shell会创建子进程，由子进程执行cd，cd将改变子进程的工作目录，父目录（shell的目录）不会被改变。<br><strong>注：用户在命令行输入命令后，一般情况下shell会fork并exec该命令，但是shell的内建命令例外，执行内建命令相当于调用shell进程中的一个函数，并不创建新的进程.</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
