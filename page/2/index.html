<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="tWqzAeLYHxufjgoQXpm3qh6YTje2bah03cY7dTfBvWw">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝色步行者">
<meta property="og:url" content="http://www.jianzzz.com/page/2/index.html">
<meta property="og:site_name" content="蓝色步行者">
<meta property="og:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蓝色步行者">
<meta name="twitter:description" content="如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.jianzzz.com/page/2/">





  <title>蓝色步行者</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝色步行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每个人都有自己的梦想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/docker使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/docker使用/" itemprop="url">docker使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:04:40+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CentOS-7中docker的安装和启动"><a href="#CentOS-7中docker的安装和启动" class="headerlink" title="CentOS 7中docker的安装和启动"></a>CentOS 7中docker的安装和启动</h1><h2 id="若需要更新源"><a href="#若需要更新源" class="headerlink" title="若需要更新源"></a>若需要更新源</h2><p>备份/etc/yum.repos.d/CentOS-Base.repo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></p>
<p>下载源文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure></p>
<p>运行以下命令生成缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>
<h2 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h2><p>安装完成后，使用下面的命令来启动docker服务，并将其设置为开机启动：<br>采用CentOS 7中支持的新式 systemd 语法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker.service</span><br><span class="line">systemctl enable docker.service</span><br></pre></td></tr></table></figure></p>
<h1 id="ubuntu14-04安装"><a href="#ubuntu14-04安装" class="headerlink" title="ubuntu14.04安装"></a>ubuntu14.04安装</h1><h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Precise 12.04 (LTS)	deb https://apt.dockerproject.org/repo ubuntu-precise main</span><br><span class="line">Trusty 14.04 (LTS)	deb https://apt.dockerproject.org/repo ubuntu-trusty main</span><br><span class="line">Wily 15.10	deb https://apt.dockerproject.org/repo ubuntu-wily main</span><br><span class="line">Xenial 16.04 (LTS)	deb https://apt.dockerproject.org/repo ubuntu-xenial main</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb https://apt.dockerproject.org/repo ubuntu-trusty main&quot; &gt; /etc/apt/sources.list.d/docker.list</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="安装docker-1"><a href="#安装docker-1" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker-engine</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure>
<h1 id="使用registry容器"><a href="#使用registry容器" class="headerlink" title="使用registry容器"></a>使用registry容器</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/library/registry</span><br></pre></td></tr></table></figure>
<h2 id="启动registry"><a href="#启动registry" class="headerlink" title="启动registry"></a>启动registry</h2><p>HOST_DIR为宿主机目录，存储镜像文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart always -p 5000:5000 -v &lt;HOST_DIR&gt;:/tmp/registry daocloud.io/registry</span><br></pre></td></tr></table></figure></p>
<h2 id="push-docker镜像"><a href="#push-docker镜像" class="headerlink" title="push docker镜像"></a>push docker镜像</h2><p>在需要pull/push的机子上，centos下编辑/etc/sysconfig/docker，ubuntu下修改/etc/default/docker，在OPTIONS项后面加入<code>–insecure-registry ip:5000</code>，然后重启docker。</p>
<p>按照docker镜像命名规则为镜像打tag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag b477a2162de3 116.56.140.66:5000/jianzzz/red5:v1</span><br></pre></td></tr></table></figure></p>
<p>push到私有docker-registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 116.56.140.66:5000/jianzzz/red5:v1</span><br></pre></td></tr></table></figure></p>
<p>docker中镜像的命名规则，如：<code>registry.domain.com/mycom/base:latest</code>，这是一个完整的image名称，各部分的作用：<br>registry.domain.com： image所在服务器地，如果是官方的hub部分忽略<br>mycom：namespace，被称为命名空间，或者说成是你镜像的一个分类<br>base：这个是镜像的具体名字<br>latest：这是此image的版本号，当然也可能是其它的，如1.1之类的</p>
<h1 id="使用remote-api"><a href="#使用remote-api" class="headerlink" title="使用remote api"></a>使用remote api</h1><p>Centos docker配置文件位置：<code>/etc/sysconfig/docker</code><br>Ubuntu docker配置文件位置：<code>/etc/default/docker</code></p>
<p>修改配置文件中的内容如下：<br><code>OPTIONS=&#39;-H tcp://0.0.0.0:[docker_port] -H unix:///var/run/docker.sock --selinux-enabled&#39;</code><br>将docker_port换成想要配置且未被占用的端口号，比如2375   </p>
<p>ubuntu 14.04为：<code>DOCKER_OPTS=&#39;-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --selinux-enabled&#39;</code></p>
<p>重启docker服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>查看服务启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure></p>
<p>开放防火墙端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">firewall-cmd --zone=public --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 2375 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<h1 id="非root用户直接使用docker"><a href="#非root用户直接使用docker" class="headerlink" title="非root用户直接使用docker"></a>非root用户直接使用docker</h1><p>参考<a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/centos/</a><br>创建docker组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></p>
<p>将当前用户加入到docker组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></p>
<p>重启docker-daemon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>log out并重新log in </p>
<h1 id="docker-run权限"><a href="#docker-run权限" class="headerlink" title="docker run权限"></a>docker run权限</h1><p>有时候启动一个容器的时候可能会导致权限问题，导致容器一直restarting，比如启动mysql容器的时候，使用了volume，却发现启动不成功。<br>使用<code>docker logs 容器id</code>可以查看容器运行日志。</p>
<p>Centos7 可能出现<code>Permission denied</code>的问题。<br>原因：CentOS7中的安全模块selinux把权限禁掉了，至少有以下三种方式解决挂载的目录没有权限的问题：<br>1、在运行容器的时候，给容器加特权，及加上 –privileged 参数。使用该参数，container内的root拥有真正的root权限。该方法在centos7下有效，但在ubuntu14.04会出现docker run不成功的情况（ubuntu14.04倒不会出现<code>Permission denied</code>的问题）。<br>2、关闭selinux：<br>查看SELinux状态命令：/usr/sbin/sestatus -v  或 getenforce<br>临时关闭：<br>setenforce 0 #设置SELinux 成为permissive模式<br>setenforce 1 #设置SELinux 成为enforcing模式<br>永久关闭，需要重启机器：修改<code>/etc/selinux/config</code>文件，将<code>SELINUX=enforcing</code>改为<code>SELINUX=disabled</code>，重启机器。<br>3、添加selinux规则，改变要挂载的目录的安全性文本。<br>更改安全性文本的格式如下<br>chcon [-R] [-t type] [-u user] [-r role] 文件或者目录</p>
<p>Docker Volume权限管理可参考： <a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">https://yq.aliyun.com/articles/53990</a></p>
<h1 id="dockerfile中entrypoint和cmd"><a href="#dockerfile中entrypoint和cmd" class="headerlink" title="dockerfile中entrypoint和cmd"></a>dockerfile中entrypoint和cmd</h1><p>1、ENTRYPOINT，表示镜像在初始化时需要执行的命令，不可被重写覆盖，需谨记。<br>2、CMD，表示镜像运行默认参数，可被重写覆盖。<br>3、ENTRYPOINT/CMD都只能在文件中存在一次，并且最后一个生效 多个存在，只有最后一个生效，其它无效！<br>4、需要初始化运行多个命令，彼此之间可以使用 &amp;&amp; 隔开，但最后一个须要为无限运行的命令，需切记！</p>
<p>参考 <a href="http://crosbymichael.com/dockerfile-best-practices.html" target="_blank" rel="noopener">Dockerfile Best Practices</a>和<a href="http://cloud.51cto.com/art/201411/457338.htm" target="_blank" rel="noopener">论docker中 CMD 与 ENTRYPOINT 的区别</a>  </p>
<h2 id="cmd的两种格式"><a href="#cmd的两种格式" class="headerlink" title="cmd的两种格式"></a>cmd的两种格式</h2><p><strong>entrypoint类似</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD /bin/echo</span><br><span class="line"># or</span><br><span class="line">CMD [&quot;/bin/echo&quot;]</span><br></pre></td></tr></table></figure></p>
<p>格式1不是数组，命令在执行前会被加上<code>/bin/sh -c</code>；格式2是数组，执行效果如愿。</p>
<h2 id="给entrypoint传递参数"><a href="#给entrypoint传递参数" class="headerlink" title="给entrypoint传递参数"></a>给entrypoint传递参数</h2><p><code>docker run</code>期间可以给entrypoint传递参数。CMD 和 ENTRYPOINT 放在一起效果更佳：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/mysql&quot;]</span><br><span class="line"></span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure></p>
<p>一旦设置了entrypoint，<code>docker run</code>期间传递的所有参数将作为ENTRYPOINT（”/usr/bin/mysql”）的参数。而CMD默认被设为<code>[&quot;--help&quot;]</code>，一旦<code>docker run</code>期间没有传递任何参数，则<code>docker run</code>会输出help的信息。</p>
<h1 id="基于mysql镜像构建新镜像"><a href="#基于mysql镜像构建新镜像" class="headerlink" title="基于mysql镜像构建新镜像"></a>基于mysql镜像构建新镜像</h1><p><a href="https://github.com/docker-library/mysql/blob/c207cc19a272a6bfe1916c964ed8df47f18479e7/5.7/Dockerfile" target="_blank" rel="noopener">https://github.com/docker-library/mysql/blob/c207cc19a272a6bfe1916c964ed8df47f18479e7/5.7/Dockerfile</a><br>查看docker hub上mysql的Dockerfile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 3306</span><br><span class="line">CMD [&quot;mysqld&quot;]</span><br></pre></td></tr></table></figure></p>
<p>可以看出该Dockerfile已经占据了ENTRYPOINT和CMD，且”mysqld”作为”docker-entrypoint.sh”的默认参数。假设我们扩展该镜像，加上vnc等服务，则可以将mysql启动放置到supervisor中，并且在新的dockerfile中直接运行supervisor。请注意在supervisor中启动mysql并不是<code>command=docker-entrypoint.sh</code>或<code>command=mysqld</code>，而是<code>command=docker-entrypoint.sh mysqld</code>。</p>
<p>Dockerfile<br><img src="/2017/08/26/docker使用/1.PNG" title="Dockerfile"><br>vnc.sh<br><img src="/2017/08/26/docker使用/2.PNG" title="vnc.sh"><br>supervisord.conf<br><img src="/2017/08/26/docker使用/3.PNG" title="supervisord.conf">  </p>
<p><strong>上述方案的缺点是：</strong>假如我们使用该镜像启动了一个容器，并且启动另一个容器连接该镜像，然后执行数据库导入语句，如<code>docker run -v /home/ubuntu/Desktop/web/db/mysql_5_7_16_vnc_latest_1482889787/data:/tmp/data:rw --link mysql_5_7_16_vnc_latest_1482889787:mysql --rm mysql-5.7.16-vnc:latest /bin/sh -c &#39;mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot; -e &quot;DROP DATABASE IF EXISTS expand;CREATE DATABASE expand DEFAULT CHARSET utf8 COLLATE utf8_general_ci;use expand;source tmp/data/system-expand.sql;&quot;&#39;</code>。关于第二个容器，因为它要执行mysql语句，因此需要mysql服务，一般选择跟第一个容器相同的mysql镜像来启动第二个连接容器。但由于我们将supervisor作为ENTRYPOINT，因此可能会出现以下错误：<br><img src="/2017/08/26/docker使用/4.PNG" title="supervisor错误"><br>出错原因是docker run的参数被当作supervisor的参数了，因此我们继续修改上述文件，将supervisor放到脚本中执行：<br>Dockerfile<br><img src="/2017/08/26/docker使用/5.PNG" title="Dockerfile"><br>vnc.sh<br><img src="/2017/08/26/docker使用/6.PNG" title="vnc.sh"><br>supervisord.conf<br><img src="/2017/08/26/docker使用/7.PNG" title="supervisord.conf"> </p>
<p><strong>继续完善：</strong>上述方案仍有缺陷，连接容器是基于vnc-mysql镜像启动的，但是并不需要vnc等相关服务，因此应该添加一个环境变量控制是否启动vnc。另外，vnc.sh会wait等待supervisor进程，因此为了使得docker run过程指定的<code>/bin/sh -c &quot;...&quot;</code>能够生效，应该在wait之前添加<code>exec &quot;$@&quot;</code>。<br>Dockerfile<br><img src="/2017/08/26/docker使用/8.PNG" title="Dockerfile"><br>vnc.sh<br><img src="/2017/08/26/docker使用/9.PNG" title="vnc.sh"><br>supervisord.conf<br><img src="/2017/08/26/docker使用/10.PNG" title="supervisord.conf"> </p>
<p>最终的docker run实例：  </p>
<pre><code>docker run -v /home/ubuntu/Desktop/web/db/mysql_5_7_16_vnc_latest_1482889787/data:/tmp/data:rw --link mysql_5_7_16_vnc_latest_1482889787:mysql -e MYSQL_ROOT_PASSWORD=any_noused -e RUN_VNC=no --rm mysql-5.7.16-vnc:latest /bin/sh -c &apos;mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot; -e &quot;DROP DATABASE IF EXISTS expand;CREATE DATABASE expand DEFAULT CHARSET utf8 COLLATE utf8_general_ci;use expand;source tmp/data/system-expand.sql;&quot;&apos;
</code></pre><p>奇怪的是，原本不使用supervisor管理mysqld的时候，连接容器是不需要指定<code>MYSQL_ROOT_PASSWORD</code>的（奇怪于为什么不需要，因为mysql容器的启动是需要指定<code>MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD,MYSQL_RANDOM_ROOT_PASSWORD</code>其中之一的），而使用supervisor之后就需要指定了，虽然这个密码在这里是没有实际作用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/孤儿进程和僵尸进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/孤儿进程和僵尸进程/" itemprop="url">孤儿进程和僵尸进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T12:01:52+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。因此孤儿进程并不会有什么危害。  </p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，直到父进程通过wait / waitpid来取时才释放。如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。  </p>
<h1 id="僵尸进程解决办法"><a href="#僵尸进程解决办法" class="headerlink" title="僵尸进程解决办法"></a>僵尸进程解决办法</h1><h2 id="通过信号机制"><a href="#通过信号机制" class="headerlink" title="通过信号机制"></a>通过信号机制</h2><p>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    //创建捕捉子进程退出信号</span><br><span class="line">    signal(SIGCHLD,sig_child);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;I am child process,pid id %d.I am exiting.\n&quot;,getpid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;I am father process.I will sleep two seconds\n&quot;);</span><br><span class="line">    //等待子进程先退出</span><br><span class="line">    sleep(2);</span><br><span class="line">    //输出进程信息</span><br><span class="line">    system(&quot;ps -o pid,ppid,state,tty,command&quot;);</span><br><span class="line">    printf(&quot;father process is exiting.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sig_child(int signo)</span><br><span class="line">&#123;</span><br><span class="line">     pid_t      pid;</span><br><span class="line">     int        stat;</span><br><span class="line">     //处理僵尸进程</span><br><span class="line">     while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt;0)</span><br><span class="line">         printf(&quot;child %d terminated.\n&quot;, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fork两次"><a href="#fork两次" class="headerlink" title="fork两次"></a>fork两次</h2><p>可参考《Unix 环境高级编程》8.6节。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。  </p>
<p><strong>以下是fork两次的原因</strong>：<br>当我们只fork()一次后，存在父进程和子进程。这时有两种方法来避免产生僵尸进程：<br>&#160; &#160; &#160; &#160;确保父进程先结束，子进程则自动托管到init进程（pid = 1）。<br>&#160; &#160; &#160; &#160;父进程调用waitpid()等函数来接收子进程退出状态。<br>考虑子进程先于父进程结束的情况：<br>&#160; &#160; &#160; &#160;若父进程未处理子进程退出状态，在父进程退出前，子进程一直处于僵尸进程状态。<br>&#160; &#160; &#160; &#160;若父进程调用waitpid()（应使用阻塞调用确保子进程先于父进程结束）来等待子进程结束，将会使父进程在调用waitpid()后进入睡眠状态，只有子进程结束父进程的waitpid()才会返回。 如果存在子进程结束，但父进程还未执行到waitpid()的情况，那么这段时期子进程也将处于僵尸进程状态。  </p>
<p><strong>由此可以看出，在子进程先于父进程结束的情况下，即使父进程调用waitpid()，但子进程结束前父进程还未执行waitpid()的话，子进程仍有机会成为僵尸进程。</strong>那么如何使父进程更方便地创建不会成为僵尸进程的子进程呢？这就要用两次fork()了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t  pid;</span><br><span class="line">    //创建第一个子进程</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fork error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个子进程</span><br><span class="line">    else if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //子进程再创建子进程</span><br><span class="line">        printf(&quot;I am the first child process.pid:%d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        pid = fork();</span><br><span class="line">        if (pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fork error:&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //第一个子进程退出</span><br><span class="line">        else if (pid &gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;first procee is exited.\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        //第二个子进程</span><br><span class="line">        //睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span><br><span class="line">        sleep(3);</span><br><span class="line">        printf(&quot;I am the second child process.pid: %d\tppid:%d\n&quot;,getpid(),getppid());</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    //父进程处理第一个子进程退出</span><br><span class="line">    if (waitpid(pid, NULL, 0) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;waitepid error:&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父进程一次fork()后产生一个子进程随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束，然后子进程fork()后产生孙子进程随后<strong>立即</strong>exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为init，init进程在其子进程结束时会自动收尸，这样也就不会产生僵尸进程了。</p>
<p><strong>注</strong>：以上总结引用自<a href="http://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程</a>和<a href="http://www.cnblogs.com/codingmylife/archive/2010/11/10/1874235.html" target="_blank" rel="noopener">为何要fork()两次来避免产生僵尸进程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/计算机启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/计算机启动/" itemprop="url">计算机启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T11:39:18+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机启动过程有哪些阶段"><a href="#计算机启动过程有哪些阶段" class="headerlink" title="计算机启动过程有哪些阶段"></a>计算机启动过程有哪些阶段</h1><p>第一阶段：BIOS<br>第二阶段：MBR<br>第三阶段：硬盘启动<br>第四阶段：操作系统</p>
<h1 id="第一阶段：BIOS：控制权为BIOS"><a href="#第一阶段：BIOS：控制权为BIOS" class="headerlink" title="第一阶段：BIOS：控制权为BIOS"></a>第一阶段：BIOS：控制权为BIOS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>BIOS：</strong>BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。<br><strong>CMOS：</strong>CMOS 是电脑主机板上一块特殊的RAM芯片，是系统参数存放的地方，而BIOS中系统设置程序是完成参数设置的手段。CMOS芯片由主板上的钮扣电池供电，即使系统断电，参数也不会丢失。<br><strong>实模式：</strong>最早期的8086 CPU（16位）只有一种工作方式，那就是实模式，而且数据总线为16位（一次最多能取2^16＝64KB数据，实模式下每个段最大只有64KB），地址总线为20位（寻址的能力是2^20=1MB，实模式下CPU的最大寻址能力），实模式下所有寄存器都是16位。8086处理器在实模式下的存储器寻址方式由段寄存器的内容乘以16作为基地址，加上段内的偏移地址形成最终内存中实际的物理地址。<br><strong>这里回答一个问题：在8086/8088中，只有20根地址总线，所以可以访问的地址是2^20=1M，但由于8086/8088是16位地址模式，能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存(16位寄存器怎么表示20位的寻址空间？)，Intel用了分段的方法 —— segment:offset. 实际的地址是segment &lt;&lt; 4 + offset。</strong><br><strong>保护模式：</strong>从80286开始就有了保护模式，从80386开始CPU数据总线和地址总线均为32位，而且寄存器都是32位。但80386以及现在的奔腾、酷睿等等CPU为了向前兼容都保留了实模式，现代操作系统在刚加电时首先运行在实模式下，然后再切换到保护模式下运行。</p>
<h2 id="BIOS映射到内存"><a href="#BIOS映射到内存" class="headerlink" title="BIOS映射到内存"></a>BIOS映射到内存</h2><p><strong>boot block:</strong> 当启动中计算机的时候，一开始BIOS并不会马上把Flash ROM中的内容copy到shadow memory，CPU会执行一部分代码，我们习惯把这一段代码叫做Boot Block。之所以要把Flash ROM中的内容loaded到memory，是因为当对CPU，memory进行完initialized，由于ROM的执行速度远比RAM要低，才会把BIOS shadow到memory中去，这样可以reduce POST的时间。所以我们在OS下会发现BIOS的content会shadow到memory的最顶端，举个例子，如果你是用的32bit的XP(support 4G)，你就可以在FFF00000-FFFFFFFF（对1M的BIOS而言，如果是512K地址则是FFF7FFFF-FFFFFFFF）这段memory空间找到你的BIOS的content。  </p>
<p>注：以下内容参考并摘抄自<a href="http://www.feishare.com/attachments/056_CPU%20reset.pdf" target="_blank" rel="noopener">《CPU rest》</a><br><strong>i386 CPU取的第一条指令地址与所处模式：</strong> 当CPU 抓到第一条指令，并执行的时候，如果说处于real mode，那么FFFFFFF0h的地址，早已超出了real mode CPU的寻址范围。也许很多人都讨论过这个问题。首先，可以确定的是：<br>此时CPU并不处于protect mode。CPU进入protect mode的标志是CR0的PE bit置1，而当CPU执行第一条指令时，此Flag bit并未置1。如果说此时CPU处于real mode， 那么此时CS=F000h, IP=FFF0h,（CS和IP的初始值应当是8086/8088-1M物理地址空间-时代编址BIOS第一条指令地址遗留下来的） 按照real mode的寻址方式， 此时形成的第一条指令的地址应该是 CS:IP=F000h <em> 10h+FFF0h =FFFF0h， 而不是FFFFFFF0h。(有文档说， CPU第一条指令会从 FFFFFFF0h抓，而有文档说是从FFFF0抓， 那到底从那里抓呢？一切以 Intel的说法为准，Intel 说从FFFFFFF0h抓，那就是从FFFFFFF0h抓。)<br><strong>CPU寻址和所在的模式无关，它只会使用内部的base address寄存器加上offset，实模式下base address是段寄存器×16，保护模式下就是加载段选择子的内容。</strong>自从386以来，CS不再是单个的段寄存器，而是包括Segment selector，segment base，和segment limit 3个register的一组寄存器。Segment Base决定着基地址的值。当 CPU 处于实模式段寻址方式时，如果段寄存器装入F000h, 那么 CPU 会自动将F000h </em> 10h = F0000h装入Segment Base，那么最终形成的地址就是F0000h+IP， 即Segment Base+IP形成地址。然而实际情况是，CPU reset过后，虽然此时CPU的确处于段寻址模式，Segment Selector的值为F000h，但是Segment Base register的值却并没有按照段寻址模式的方式装入，而是被设置为Segment Base=FFFF0000h，按照Segment Base+IP的方式，最终形成的地址为FFFF0000h + FFF0h = FFFFFFF0h。这就是为何第一条指令会从 FFFFFFF0h抓，而不是FFFF0h抓的原因。<br>那么，其实我们可以说，CPU执行第一条指令时，它处于一种不普通的real mode中。<br>（段寻址模式：在寻址一个内存具体单元时，由一个基址再加上某些寄存器提供的16位偏移量来形成实际的20位物理地址。这个基址就是CPU中的段寄存器。在形成20位物理地址时，段寄存器的16位的数会自动左移4位，然后与16位偏移量相加，即可形成所需的内存地址。这种寻址方式的实质还是基址寻址。）</p>
<p><strong>地址映射：</strong>在CPU读到BIOSCode之前，一切工作都是由HW完成，其中南桥做了一些很重要的幕后工作。在CPUreset和BIST之后，CPU将会去读取第一条指令。对于传统的 CPU + 北桥 + 南桥类型的platform来说，CPU的request通过FSB到达北桥，北桥将这个request透过ESI送到南桥。而对于最新的chipset来说，北桥和CPU封装在一颗Chip里面，所以会看到这个request通过DMI/QPI被送到南桥。Request到达南桥后，南桥根据配置决定将request route 到SPI或者LPC。南桥自己有一张特殊的address mapping table，存在两个这样的区域，第一个是从地址空间4G向下，大小从4MB到16MB不等的一个区域，以4MB为例，地址空间从FFFC00000h~FFFFFFFFh，称之为Range4G。CPU reset后会从FFFFFFF0h抓第一条指令，这第一条指令正好处于南桥的4G范围内，能享受南桥的special service。第二个受到南桥关照的地址空间，一般是从1MB向下128KB的范围，即ESegment和FSegment，从E0000~FFFFF，称之为Legacy Range，也就是说，不仅FFFC00000h~FFFFFFFFh之间的request能够被route到SPI/LPC，E0000~FFFFF之间的request也同样会被route到SPI/LPC。<br>CPU reset的时候，内存还没初始化，所以不可能从内存XXXX的位置读取第一条指令。CPU从来不会直接从内存中读数据，CPU的读写，都是针对自己的地址空间而言。假设一个 CPU，其地址空间大小是4GB，这个系统拥有一根1GB的内存。内存初始化过后，其地址被映射到0~3FFFFFFFh的地址空间，假设CPU要访问一个地址10000h，CPU的request首先针对自己的地址空间，然后 CPU的硬件会将这个请求转化为一个bus的请求，比如 FSB or PCI，然后内存控制器从bus上收到这样一个请求后，会确认这个请求是否在内存的地址空间，如果是在内存映射的空间内，则将其重定向到内存中，然后就由内存回复这个请求。 如果CPU访问一个地址8FFFFFFFh，当这个请求到达bus被内存控制器收到后，经过比较，这个地址不在内存映射的范围内，所以内存控制器将不处理这个请求， 然后这个请求可能最终通过北桥，到达南桥。当CPU reset时，其第一条指令请求的地址为FFFFFFF0h，此时内存并未初始化，这个请求会从bus上被转发到南桥，南桥最终将其重定向到LPC/SPI的ROM上，所以boot block阶段，所有的代码都是从ROM上读取的。这也是从概念上区分boot block/PEI和POST/DXE阶段的方法。那么，如果内存初始化过后，CPU读取FFFFFFF0h的request是否有可能被内存接收到呢？<strong>No，在内存控制器初始化的时候，会设置一些参数，保留几段地址空间的区域给flash rom、PCI设备分配使用，它确保不会将内存映射到这些地址空间上。所以内存初始化过后，地址请求FFFFFFF0h还是会被北桥转发出去，不会decode到内存。</strong>但是，如果一个PCI设备，在南桥之前收到了这个请求，并且解码了这个地址，回复了CPU的请求，那么将不会从南桥的LPC/SPI boot。  </p>
<p>注：以下内容参考自<a href="http://www.oldlinux.org/oldlinux/archiver/?tid-1823.html" target="_blank" rel="noopener">OldLinux’s Archiver</a>上关于内存的讨论。<br><strong>8086时代 - 1M物理地址空间：</strong>机器加电成功后，CPU自设定为初试状态，开始准备运行（以实模式），此时RAM是空的。不同BIOS厂商生产的BIOS代码量不一样，因此习惯<strong>将BIOS的第一条指令编码到特定地址上（CS:IP = 0xF000:0xFFF0处）</strong>，CPU则被预编程查找这个固定的位置。该位置放置一个jmp指令以跳转到真正执行的代码位置，通过jmp指定位置来适配不同数量的BIOS代码。事实上CS:IP = 0xF000:0xFFF0离实模式的极限地址0xF000:0xFFFF只有16个字节了，也就安排得开一个跳转指令和其他几条简短指令。而我们实际究竟需要使用多长的冷启动代码由jmp 0xF000:0xXXXX中的偏移0xXXXX来把握，如果使用得多，0xXXXX就小，使用得少，0xXXXX就大。BIOS冷启动代码编址到1M顶部保证启动代码尽量靠后，而不浪费多余的地址空间，由于地址空间安排在最后，也不会把整个地址空间隔离成两段。<br><strong>i386时代：</strong>我们说的bios rom，当然这包括很多bios的rom，如视频bios rom和SCSI卡bios rom等，当然还包括我们传统意义上的包含冷启动程序代码以及一系列原始中断服务程序的bios的rom，由于技术的发展，这一部分rom现在变得非常大，如现在一般的传统bios rom就达2M以上，而视频bios rom等都更大。以前习惯上把这些rom的地址空间安排在640k以上1M以下的空间里(也就是说640k~1M这一段地址指向rom而不是指向ram)，但这一点空间是明显安排不下现在的rom的，又为了不让这一段rom的地址将ram的地址隔离成两段，一般都将这段rom的地址空间安排在cpu所能访问到的地址的最高端。因此，为了保持对8086/8088的兼容性，所以intel采用了一个变通的方法，具体就是：<br>1）CPU复位后得到机器执行的第一条指令地址0xFFFFFFF0（cpu取指令时,由于是从物理上使A20~A31地址线为1,所以当cs为f000,指令偏移为FFF0时,形成物理地址FFFF0,再加上A20~A31都为1,实际得到的物理地址是:FFFFFFF0）。执行一条跳转指令jmp f000:xxxx跳转到启动代码的开始处。（段内跳转，跳转的位置仍然是rom的位置）<br>2）在实模式下，intel把BIOS中的冷启动代码映射到32位cpu所能寻址的4G地址空间的最后64k，把A20~A31地址线全置为1，把CS = 0xf000，这样，cpu所得到的物理地址就是0xffff0000 - 0xffffffff，即4G地址空间的最后64K。（猜测映射过程并没有复制数据到4G顶部，也就是说，可能被映射的物理地址空间没有数据但仍然无法被使用！）<br>3）通过执行启动代码（或者别的方法）把BIOS中的ROM内容关于实模式的代码和数据拷贝到物理地址640K~1Mb处，这样使得在实模式下，cpu也能通过动态映射访问BIOS中的部分内容。<br>4）执行一个段间跳转，屏蔽掉地址的A20~A31线（intel规定任何一个段间转移指令可以置触发器的输出为0），从而来到低地址空间，接着执行从rom bios拷贝过来的代码。<br>（内存控制器控制CPU对BIOS中ROM内容的访问到底转发到RAM还是ROM，而4G处则一直映射着全部的BIOS数据。按照《CPU rest》的分析，内存控制器初始化的时候，会设置一些参数，保留几段地址空间的区域给flash rom、 PCI设备分配使用，它确保不会将内存映射到这些地址空间上，那么复制BIOS的数据到4G处将没有多大的意义，因为也读不了，而且实模式复制数据到4G又得采取特殊的方式。）</p>
<h2 id="BIOS硬件自检"><a href="#BIOS硬件自检" class="headerlink" title="BIOS硬件自检"></a>BIOS硬件自检</h2><p>注：以下内容参考自<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a><br>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。<br>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><p>注：以下内容参考自<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">维基百科-主引导记录</a>和<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a><br>当BIOS检查到硬件正常并与CMOS中的设置相符后，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处，然后检查0000:7CFEH-0000:7CFFH（MBR的结束标志位）是否等于55AAH，若不等于则转去尝试其他启动设备（往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查），如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。根据MBR中的引导代码启动某个分区的引导程序。</p>
<h1 id="第二阶段：MBR：控制权为满足要求的启动设备"><a href="#第二阶段：MBR：控制权为满足要求的启动设备" class="headerlink" title="第二阶段：MBR：控制权为满足要求的启动设备"></a>第二阶段：MBR：控制权为满足要求的启动设备</h1><p>注：以下内容参考自<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">维基百科-主引导记录</a>和<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a></p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>主引导记录：</strong>主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。在深入讨论主引导扇区内部结构的时候，有时也将其开头的446字节内容特指为“主引导记录”（MBR），其后是4个16字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。因此，在使用“主引导记录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指整个主引导扇区，还是主引导扇区的前446字节。（这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。）<br>BIOS POST之后call INT 19h，主引导记录本身就是中断信号INT 19h的处理程序。</p>
<h2 id="MBR结构"><a href="#MBR结构" class="headerlink" title="MBR结构"></a>MBR结构</h2><img src="/2017/08/26/计算机启动/1.PNG" title="标准MBR结构"> 
<h2 id="启动代码"><a href="#启动代码" class="headerlink" title="启动代码"></a>启动代码</h2><p>主引导记录最开头是引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。<br>随着计算机操作系统越来越复杂，位于主引导记录的空间已经放不下引导操作系统的代码，于是就有了第二阶段的引导程序，而MBR中代码的功能也从直接引导操作系统变为了引导第二阶段的引导程序。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序（Boot Loader）位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序（Boot Loader），如NTLDR、BOOTMGR和GNU GRUB等。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><img src="/2017/08/26/计算机启动/2.PNG" title="硬盘分区结构信息">  
<p>考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。每个主分区的16个字节，由6个部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</span><br><span class="line">（2） 第2-4个字节：主分区第一个扇区的物理位置。</span><br><span class="line">（3） 第5个字节：主分区类型。</span><br><span class="line">（4） 第6-8个字节：主分区最后一个扇区的物理位置。</span><br><span class="line">（5） 第9-12字节：该主分区第一个扇区的逻辑地址。</span><br><span class="line">（6） 第13-16字节：主分区的扇区总数。</span><br></pre></td></tr></table></figure></p>
<p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是<a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" target="_blank" rel="noopener">增加扇区总数</a>。  </p>
<p><strong>下面是一个例子：</strong><br>如果某一分区在硬盘分区表的信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</span><br></pre></td></tr></table></figure></p>
<p>则我们可以看到，最前面的”80”是一个分区的激活标志，表示系统可引导[1]；”01 01 00”表示分区开始的磁头号为1，开始的扇区号为1，开始的柱面号为0；”0B”表示分区的系统类型是FAT32，其他比较常用的有04（FAT16）、07（NTFS）；”FE BF FC”表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764；”3F 00 00 00”表示首扇区的相对扇区号为63（小端序）；”7E 86 BB 00”表示总扇区数为12289662（小端序）。</p>
<h2 id="主引导记录的内存地址为0x7C00的原因"><a href="#主引导记录的内存地址为0x7C00的原因" class="headerlink" title="主引导记录的内存地址为0x7C00的原因"></a>主引导记录的内存地址为0x7C00的原因</h2><p>注：以下内容参考自<a href="http://www.glamenv-septzen.net/en/view/6" target="_blank" rel="noopener">Why BIOS loads MBR into 0x7C00 in x86</a><br>0x7C00这个地址来自IBM PC 5150 BIOS Developer Team，IBM PC 5150使用Intel 8088处理器，是现代x86(32bit) IBM PC/AT兼容机的祖先。DOS 1.0要求至少32KiB的内存空间，所以BIOS团队不再考虑16KB的启动情况。BIOS开发团队基于以下原因设计了0x7C00地址：<br>1、他们想在32KiB空间内留出尽可能多的空间来加载操作系统本身。<br>2、8086/8088使用0x0 - 0x3FF存储中断向量，BIOS数据存在它后面。<br>3、启动扇区大小是512字节，启动程序的stack/data区域需要512字节。<br>4、操作系统加载后，主引导记录就没有用处了，此后它所在的内存地址可以被操作系统重新利用。<br>5、所以，32KiB的最后1024B被选来加载MBR。计算过程为 <strong>0x7FFF - 512 - 512 + 1 = 0x7C00</strong>。<br>操作系统加载后，内存布局如下：<br><img src="/2017/08/26/计算机启动/3.PNG" title="内存布局">   </p>
<h1 id="第三阶段：硬盘启动：控制权为硬盘上的启动程序"><a href="#第三阶段：硬盘启动：控制权为硬盘上的启动程序" class="headerlink" title="第三阶段：硬盘启动：控制权为硬盘上的启动程序"></a>第三阶段：硬盘启动：控制权为硬盘上的启动程序</h1><p>注：以下内容参考自<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a>  </p>
<h2 id="情况A：卷引导记录"><a href="#情况A：卷引导记录" class="headerlink" title="情况A：卷引导记录"></a>情况A：卷引导记录</h2><p>四个主分区里面，只有一个是激活的。MBR的引导代码读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR），并将控制权交给它。<br>“卷引导记录”包含了操作系统引导代码，它的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。<br><a href="https://zh.wikipedia.org/wiki/NTFS" target="_blank" rel="noopener">NTFS</a>文件系统的卷引导记录，该文件始终位于卷的第一个簇，其中包含引导代码（用于定位并启动NTLDR/BOOTMGR，NTLDR–NT loader的缩写，是微软的Windows NT系列操作系统的引导程序，包括Windows XP和Windows Server 2003）、BIOS参数块（其中包含卷序列号），以及$MFT和$MFTMirr所在的簇编号。</p>
<h2 id="情况B：扩展分区和逻辑分区"><a href="#情况B：扩展分区和逻辑分区" class="headerlink" title="情况B：扩展分区和逻辑分区"></a>情况B：扩展分区和逻辑分区</h2><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。<br>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。在MBR分区表中最多4个主分区或者3个主分区＋1个扩展分区，也就是说扩展分区只能有一个，然后可以再细分为多个逻辑分区。<br>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。和MBR结构类似，它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区），其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR，分区表第三、第四项没有用到。<br>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。<br>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<h2 id="情况C：启动管理器"><a href="#情况C：启动管理器" class="headerlink" title="情况C：启动管理器"></a>情况C：启动管理器</h2><p>注：以下内容参考自<a href="https://zh.wikipedia.org/wiki/GNU_GRUB" target="_blank" rel="noopener">GNU GRUB</a><br>计算机启动后，BIOS将寻找第一个可启动的设备（通常为硬盘），而后从MBR中载入启动程序，然后把控制交给这段代码，情况C控制权给了GNU GRUB。MBR位于硬盘的前512字节内。  </p>
<p><strong>GNU GRUB在MBR分区表的硬盘上</strong><br><img src="/2017/08/26/计算机启动/4.PNG" title="GNU GRUB在MBR分区表的硬盘上"><br><strong>GRUB第一版</strong><br>GRUB的步骤1包含在MBR中。由于受MBR的大小限制，步骤一所做的几乎只是装载GRUB的下一步骤（存放在硬盘的其它位置）。步骤1既可以直接装载步骤2，也可以装载步骤1.5：GRUB的步骤1.5包含在MBR后面的30千字节中。步骤1.5载入步骤2。<br>当步骤2启动后，它将呈现一个界面来让用户选择启动的操作系统。这步通常采用的是图形菜单的形式，如果图形方式不可用或者用户需要更高级的控制，可以使用GRUB的命令行提示，通过它，用户可以手工指定启动参数。GRUB还可以设置超时后自动从某一个内核启动。 </p>
<img src="/2017/08/26/计算机启动/5.PNG" title="GNU GRUB 2">  
<p><strong>GRUB第二版本</strong><br>与GRUB第一版相似的是，boot.img像步骤1一样在MBR或在启动分区中，但是，它可以从任何LBA48地址的一个扇区中读取，它（boot.img）将读取core.img（产生于diskboot.img）的第一个扇区以用来后面读取core.img的剩余部分。core.img正常情况下跟步骤1.5储存在同一地方并且有着同样的问题，可是，当它被移动到一个文件系统或一个纯粹的分区时会比在步骤1.5移动或删除引起更少的麻烦。一旦完成读取，core.img会读取默认的配置文件和其他需要的模块。<br>GRUB配置文件的文件名和位置随系统的不同而不同；如在Debian（GRUB Legacy）和OpenSUSE中，这个文件为/boot/grub/menu.lst，而在Fedora和Gentoo中为/boot/grub/grub.conf。Fedora、Gentoo Linux和Debian（GRUB 2）使用/boot/grub/grub.conf。 Fedora为了兼容文件系统层次结构标准提供了一个从/etc/grub.conf到/boot/grub/grub.conf的符号链接。<br><strong>当GRUB启动后</strong><br>一旦选择了启动选项，GRUB把选择的内核载入内存并把控制交给内核。在此步骤中，对于Windows之类不支持多启动标准的操作系统，GRUB也可以通过<strong>链式启动</strong>把控制传给其它启动器。在这种情况下，其它操作系统的启动程序被GRUB保存了下来；与内核不同，其它操作系统如同直接自MBR启动。类似Windows的启动菜单，也许是另一个启动管理器，它允许在多个不支持多启动的操作系统中做进一步的选择。（在已有Windows的系统上面，或者包含多个Windows版本的系统上安装现代的Linux而不修改原操作系统，即属于这类情况。）  </p>
<p><strong>GNU GRUB在GPT分区表的硬盘上</strong><br><img src="/2017/08/26/计算机启动/6.PNG" title="GNU GRUB在GPT分区表的硬盘上"> </p>
<h1 id="第四阶段：操作系统：控制权为操作系统内核"><a href="#第四阶段：操作系统：控制权为操作系统内核" class="headerlink" title="第四阶段：操作系统：控制权为操作系统内核"></a>第四阶段：操作系统：控制权为操作系统内核</h1><p>注：以下内容参考自<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a><br>操作系统的内核首先被载入内存。<br>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。<br>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。<br>至此，全部启动过程完成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/内存管理之地址转换和保护机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/内存管理之地址转换和保护机制/" itemprop="url">内存管理之地址转换和保护机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T11:15:31+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：以下分析引用自 <a href="http://grid.hust.edu.cn/zyshao/Teaching_Material/OSEngineering/Chapter1.pdf" target="_blank" rel="noopener">80386 保护模式简介</a>   </p>
<h1 id="保护模式简介"><a href="#保护模式简介" class="headerlink" title="保护模式简介"></a>保护模式简介</h1><p>Intel 推出 x86 架构已近 30 年，刚开始推出的 8086 处理器是一款 16 位的处理器，它标志着 x86 架构的诞生，这种 16 位处理器数据总线是 16 位的，而地址总线是 20 位的，最多可以寻址 1MB 的地址空间。之后的 80286 处理器也是 16 位，但是地址总线有 24 位，而且从 80286开始 CPU 演变出两种工作模式：实模式和保护模式；而 80386 则是 Intel 推出的 80x86 系列中的第一款 32 位处理器，它的数据总线与地址总线都是 32 位，可以寻址 4G 的地址空间； AMD 公司随后在 2000 年又在 x86 架构的基础上推出了 x86-64 处理器架构， AMD 的处理器可以兼容 32 位的指令集，所以它既是 64 位的又是 32 位的。 </p>
<p>在 x86 架构中， 16 位的处理器与 32 位处理器所对应的寄存器是有所不同的。<strong>像 8086 寄存器组就分为通用寄存器、专用寄存器和段寄存器三类总共 15 个</strong>，其中通用寄存器有 AX、BX、 CX、 DX、 SP、 BP、 DI 及 SI，专用寄存器包括 IP、 SP 和 FLAGS 三个 16 位寄存器，而段寄存器则有 CS、 DS、 SS、 ES，这些寄存器都是 16 位的。 <strong>32 位 x86 架构对应的寄存器则共有 34 个</strong>，其中包括 EAX、 EBX、 ECX、 EDX、 ESI、 EDI、 EBP、 ESP 8 个 32 位的通用寄存器； 6 个 16 位的段寄存器 CS、 DS、 SS、 ES、 FS、 GS，相比 8086 增加了 FS 和 GS；GDTR、 LDTR、 IDTR 和 TR 四个系统地址寄存器； EFLAGS、 EIP、 CR0—CR3 6 个状态和控制寄存器，在这里标志寄存器 EFLAGS 与指令指针寄存器 EIP 都从 16 位进化到了 32 位；还有就是增加了一些调试寄存器、段描述符寄存器以及测试寄存器。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/1.PNG" width="8086" title="和 86386 的寄存器的对比"><br>保护模式(Protected Mode) 是一种和 80286 系列及之后的 x86 兼容 CPU 操作模式。保护模式有一些新的特色，设计用来增强多功能和系统稳定度，比如内存保护、分页、系统以及硬件支持的虚拟内存。大部分的现今 x86 操作系统都在保护模式下运行，包含 Linux、 FreeBSD、以及 微软 Windows 2.0 和之后版本。需要指出的是，保护模式在增加这些新特性的同时，也带来了系统软件设计的复杂性。</p>
<p>在 8086 时代， CPU 中设置了四个段寄存器： CS、 DS、 SS 和 ES，分别用于可执行代码段、数据段以及堆栈段。每个段寄存器都是 16 位的，对应于地址总线中的高 16 位。每条“访存”指令中的内部地址也都是 16 位的，但是在送到地址总线之前，CPU 内部会自动地把它与某个段寄存器中的内容相加。因为段寄存器中的内容对应于 20 位地址总线中的高 16 位，所以相加时实际上是地址总线中的高 16 位与段寄存器中的 16 位相加，而低 4 位保留不变，这样就形成一个 20 位的实际地址，也就实现了从 16 位内存地址到 20 位实际地址的转换，或者叫 “映射”。</p>
<p>到了 80286 时代，它的地址总线位数增加到了 24 位，因此可以访问到 16MB 的内存空间。更重要的是从此开始引进了一个全新理念——保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和 8086 兼容， 80286 内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的 8086 方式，被称为实模式。 Intel 选择了在段寄存器的基础上构筑保护模式，并且保留 16 位的段寄存器。不同的是，在保护模式下，段范围不再受限于 64K，可以达到 16MB（或者 80386 的 4GB）。</p>
<h1 id="寻址方式的变化"><a href="#寻址方式的变化" class="headerlink" title="寻址方式的变化"></a>寻址方式的变化</h1><h2 id="实模式下段的管理"><a href="#实模式下段的管理" class="headerlink" title="实模式下段的管理"></a>实模式下段的管理</h2><p>实模式采用 16 位寻址模式，在该模式中，最大寻址空间为 1MB，最大分段为 64KB。由于处理器的设计需要考虑到向下兼容的问题，实模式也是我们今天接触到的大多数计算机在启动后处于的寻址模式。 </p>
<p>8086 处理器地址总线扩展到 20 位，但算术逻辑运算单元（ ALU）宽度即数据总线却只有 16 位，也就是说直接参与运算的数值都是 16 位的。为支持 1MB 寻址空间， 8086 在实模式下引入了分段的方法。在处理器中设置了四个 16 位的段寄存器： CS、 DS、 SS、 ES，对应于地址总线中的高 16 位。寻址时，采用以下公式计算实际访问的物理内存地址：<strong>实际物理地址 = （段寄存器 &lt;&lt; 4） + 偏移地址。</strong>这样，便实现了 16 位内存地址到 20 位物理地址的转换。  </p>
<p>我们回顾一下实模式下程序的运行。程序运行的实质就是指令的执行，显然 CPU 是指令得以执行的硬件保障，而 CPU 是如何知道指令在什么地方呢？ 80x86 系列是使用 CS 寄存器配合 IP 寄存器的组合来通知 CPU 指令在内存中的位置。 程序指令在执行过程中一般还需要有各种数据， 80x86 系列有 DS、 ES、 FS、 GS、 SS 等用于指示不同用途的数据段在内存中的位置。程序可能需要调用系统的服务子程序， 80x86 系列使用中断机制来实现系统服务。总的来说，这些就是实模式下一个程序运行所需的主要内容。  </p>
<p>我们再来回顾一下实模式下的寻址方式。寻址方式一共有以下 8 种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 立即数寻址 例如： MOV AX, 1234H  </span><br><span class="line">2. 寄存器寻址 例如： MOV AX, BX  </span><br><span class="line">3. 直接寻址 例如： MOV AX, [1234H]  </span><br><span class="line">4. 寄存器间接寻址 例如： MOV AX, [BX]  </span><br><span class="line">5. 基址寻址 例如： MOV AX, [BX+100H]  </span><br><span class="line">6. 变址寻址 例如： MOV AX, [SI+100H]  </span><br><span class="line">7. 基址加变址寻址 例如： MOV AX, [BX+SI]  </span><br><span class="line">8. 带位移的基址加变址寻址 例如： MOV AX, [BX+SI+100H]</span><br></pre></td></tr></table></figure></p>
<p>纵然有这么多种的寻址方式，但实际上实模式的寻址本质上都是段基址左移 4 位加上偏移得到物理地址，如下图所示：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/2.PNG" title="实模式的寻址"></p>
<h2 id="保护模式下段的管理"><a href="#保护模式下段的管理" class="headerlink" title="保护模式下段的管理"></a>保护模式下段的管理</h2><p>在保护模式下，分段机制是利用一个称作段选择子的偏移量到全局描述符表中找到需要的段描述符，而这个段描述符中就存放着段的在线性地址空间的位置，然后再加上偏移地址量便得到了最后的线性地址。<br>需要指出的是，在 32 位平台上，段基址和偏移址都是 32 位的，地址计算不再需要将段首地址左移 4 位了，直接相加即可，如果发生溢出的情况，则将溢出位舍弃。  </p>
<p>80386 转换逻辑地址（程序员观点的地址）到物理地址分以下两步：<br>1、 分段地址转换，这一步中把逻辑地址（由段选择子和段偏移组成） 转换为线性地址。<br>2、 分页地址转换，这一步中把线性地址转换为物理地址。这一步是可选的，由系统软件设计者决定是否需要。  </p>
<h1 id="分段地址转换"><a href="#分段地址转换" class="headerlink" title="分段地址转换"></a>分段地址转换</h1><img src="/2017/08/26/内存管理之地址转换和保护机制/3.JPG" title="分段地址转换">
<p>我们可以这样理解这个寻址过程，首先有一个结构体类型（称为段描述符， Descriptor），它有三个成员变量：段基址、段界限、段属性，在内存中存在一个数组（称为全局描述符表， Global Descriptor Table）维护一组这样的结构体。段选择子（ Selector）中存储的是对应的结构体在该数组中的下标，也就是索引，通过该索引从数组中找到对应的结构体，从而得到段基址，然后加上偏移量，得到最后的线性地址。为了这样的转换， 处理器用到了以下的数据结构：描述符（ Descriptors）、描述符表（Descriptor tables）、选择子（Selectors）、段寄存器（Segment Registers）。  </p>
<p>一般保护模式段式寻址可用 xxxx： yyyyyyyy 表示。其中 xxxx 表示索引，也就是段选择子，是 16 位的； yyyyyyyy 是偏移量，是 32 位的。到哪里去寻找全局描述符表呢？ 80386 以及以后的处理器专门设计了一个寄存器 GDTR（ Global Descriptor Table Register），专门用于存储全局描述符表在内存中存放的位置，当发生内存寻址与定位的时候，处理器通过该寄存器找到全局描述符表，并通过 xxxx 找到对应的描述符，进而得到该段的起始地址，并加上 yyyyyyyy 得到最终的物理地址。这个过程可以用下图来描述：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/4.PNG" title="保护模式段式寻址"></p>
<h2 id="GDTR-寄存器"><a href="#GDTR-寄存器" class="headerlink" title="GDTR 寄存器"></a>GDTR 寄存器</h2><p><strong>GDTR 寄存器</strong>有 48 位，其中有 32 位记录描述符表的物理地址， 16 位记录全局描述符表的长度（该表占据的物理内存字节数），如下图所示。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/5.PNG" title="GDTR位分布图"></p>
<h2 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h2><p><strong>段选择符</strong>为16位，它不直接指向段，而是通过指向的段描述符。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。段选择符的结构如下图所示。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/6.jpg" title="段选择符的结构"><br><strong>索引（Index）</strong>，在描述符表中从8192个描述符中选择一个描述符。 处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。索引值为 13 位（<strong>段选择符可寻找 2^13 个段描述符，每个段描述符占 2^3 字节，所有段选择符共可占 2^16 字节，而 GDTR 使用 1 6位记录段描述符的长度，刚好对应</strong>），所以在保护模式下最多可以表示 2^13=8192 个段描述符，而 TI 又分 GDT 和 LDT ，所以一共可以表示 8192<em>2=16384 个段描述符，每个段描述符可以指定一个具体的段信息，所以一共可以表示 16384 个段。而段内偏移地址为 32 位值，所以一个段最大可达 4GB ，这样 16384\</em>4GB＝64TB ，这就是所谓的 64TB 最大寻址能力。<br><strong>TI</strong> 是表指示位，0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表。<br><strong>RPL</strong> 表示请求特权级。保护机制使用该位。<br><strong>注意：如此看来，段选择子的13位索引部分表示的是第几个段描述符，如果是第1个，则%cs应该为0x1（从0算起）。但这是不对的，因为低三位是RPL和TI，所以如果是GDT表的第0项且RPL为0，则索引第1个段描述符的段选择子的值应该是0x8。</strong>    </p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>再来看看<strong>段描述符</strong>，段描述符实际上是一个占据 64 位内存（ 8 个字节）的结构体，是处理器用来把逻辑地址映射为线性地址的必要数据结构。描述符是由编译器、连接器、加载器、或者是操作系统生成的，不能由应用程序员生成。下图显示了两种常用的描述符的格式。所有的段描述符都是这两种格式当中的一种：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/7.JPG" title="段描述符的结构"><br>另一种表示则如下所示：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/8.JPG" title="段描述符的结构"><br>下面我们将结合上图详细介绍一下段描述符中的段属性，请对应上述两种图进行思考。<br>一个 64 位的段描述符包含了段基址、段界限以及段属性。在描述符中，段基址占 32 位，段限长占 20 位，属性占 12 位。<br>由上图可知，段基址为 2， 3， 4， 7 字节，共 32 位。段限长为 0， 1 以及 6 字节的低四位，共 20 位，段限长即段最大长度，与粒度位 G 共同确定。粒度位 G（Granularity bit）决定了界限值被处理器解析的方式。<br><strong>G</strong>：粒度位， G = 0 时，粒度为 1B，界限值被解析为以 1 字节为一个单元，描述符中的 20 位段限长为实际段限长，最大限长为 1MB（ 0－FFFFFh）。 G = 1 时，粒度为 1 页（4KB），界限值以 4K 为一个单元，界限值在使用之前处理器将会把它先左移 12 位，低 12 位则自动插入 0，段大小可以高达 4G（<strong>这又恰好对应于寻址时偏移地址为 32 位的情况</strong>）。<br><strong>D/B</strong>：对于不同类型段含义不同。在可执行代码段中，这一位叫做 D 位， D = 1 使用 32 位地址和 32/8 位操作数， D = 0 使用 16 位地址和 16/8 位操作数。在数据段中，这一位叫做 B 位， B = 1 段的上界为 4GB， B = 0 段的上界为 64KB。在堆栈段中，这一位叫做 B 位， B = 1 使用 32 位操作数，堆栈指针用 ESP， B = 0 使用 16 位操作数，堆栈指针用 SP。<br><strong>AVL</strong>： Available and Reserved Bit，通常设为 0。<br><strong>P</strong>：段存在位， P = 1 表示段在内存中。如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。一个实现基于段的虚拟内存的操作系统可以在以下情况下来清除存在位：1、当这个段的线性地址空间并没有完全被分页系统映射到物理地址空间时。2、当段根本没有在内存里时。<br><strong>DPL</strong>：描述符特权级，取值 0 ~ 3 共 4 级。 0 特权级为最高，而 3 特权级为最低，表示访问该段时 CPU 所需处于的最低特权级，我们在后面会详细讨论特权级的问题。<br><strong>S</strong>：描述符类型标志， S = 1 表示代码段或者数据段； S = 0 表示系统段（TSS、LDT）和门描述符。<br><strong>TYPE</strong>：描述符类型，和 S 结合使用，可以表示的描述符类型有：代码段、数据段、 TSS、LDT、中断门（ Interrupt Gate）、陷阱门（ Trap Gate）、调用门（ Call Gate）、任务门（ Task Gate）。  </p>
<ul>
<li>其中，根据描述符类型标志 S 和 TYPE 可以确定描述符的类型。  </li>
<li>当 S = 1 时，Type 的最后一位代表已访问位（Accessed bit）。当处理器访问该段时，将自动设置访问位。也就是说，当一个指向该段描述符的选择子被加载进一个段寄存器时或者当被一条选择子测试指令使用时。在段级基础上实现虚拟内存的操作系统可能会周期性的测试和清除该位，从而监视一个段的使用情况。   </li>
<li>当 S = 1 时， TYPE &lt; 8 时，为数据段描述符。数据段都是可读的，不一定可写。如下图所示： <img src="/2017/08/26/内存管理之地址转换和保护机制/9.PNG" title="描述符类型——数据段描述符"></li>
<li><p>当 S = 1 时， TYPE ≥ 8 时，为代码段描述符。代码段都是可执行的，一定不可写。如下图所示：</p>
<img src="/2017/08/26/内存管理之地址转换和保护机制/10.PNG" title="描述符类型——代码段描述符"> 
<img src="/2017/08/26/内存管理之地址转换和保护机制/11.PNG" title="描述符类型——代码段描述符">
<p>当 S=1 时，TYPE中的4个二进制位情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     3        2       1       0</span><br><span class="line">   执行位   一致位   读写位   访问位 </span><br><span class="line">执行位：置1时表示可执行，置0时表示不可执行；</span><br><span class="line">一致位：置1时表示一致码段，置0时表示非一致码段；</span><br><span class="line">读写位：置1时表示可读可写，置0时表示只读；</span><br><span class="line">访问位：置1时表示已访问，置0时表示未访问。</span><br></pre></td></tr></table></figure>
</li>
<li><p>S = 0 时，描述符可能为 TSS、 LDT 和 4 种门描述符。如下图所示： </p>
<img src="/2017/08/26/内存管理之地址转换和保护机制/12.PNG" title="描述符类型——门描述符">
</li>
</ul>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>80386把描述符的信息存储在段寄存器里，以便不用每次内存访问都去访问内存中的描述符表。<br>如下图所示，每一个段寄存器都有一个可见部分和一个不可见部分。这些段寄存器的可见部分被程序员当作一个16位的寄存器来使用。不可见的部分则只能由处理器来操纵。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/13.JPG" title="段寄存器"><br>加载这些寄存器的操作和一般的加载指令是一样的，这些指令分为两类：<br>1、直接的加载指令，例如， MOV， POP， LDS， LSS， LGS， LFS。 这些指令显示的访问这些段寄存器。<br>2、隐式的加载指令，例如， far CALL和JMP。这些指令隐式的访问CS 段寄存器，给它加载一个新的值。<br><strong>使用这些指令，程序将用一个16位的选择子加载段寄存器的可见部分。 处理器自动将基址、界限、类型和其它信息从描述符表中加载到段选择子的不可见部分。</strong>因为很多数据访问指令访问的数据段选择子已经加载到段寄存器中，所以处理器可以直接把段相关的基址加上指令提供的偏移部分，而且不会有额外的加法开销。</p>
<h1 id="GDT简介"><a href="#GDT简介" class="headerlink" title="GDT简介"></a>GDT简介</h1><p>注：以下分析引用自 <a href="http://www.kancloud.cn/digest/protectedmode/121465" target="_blank" rel="noopener">全局描述符表（GDT）-《x86汇编语言：从实模式到保护模式》</a>  </p>
<p>同实模式一样，在保护模式下，对内存的访问仍然使用段地址加偏移地址。但是，在保护模式下，在每个段能够访问之前，必须先登记。这就好比像C语言中，“对变量的使用必须先定义”一样。</p>
<p>每个段在能够使用之前，都要为这个段建立一个描述符。每个描述符占8个字节，这些描述符集中存放在内存的某个区域，一个挨着一个，就构成了一张“表”。</p>
<p>80x86中有两种描述符表：<br>全局描述符表（Global Descriptor Table, 简称GDT）<br>局部描述符表（Local Descriptor Table,简称LDT）<br>一个描述符表仅仅是一个包含了很多描述符的8字节内存数组而以。描述符表是长度是可变的，最多可包含高达8192（2^13）个描述符。处理器用GDTR和LDTR来定位内存中的全局描述符表和当前的局部描述符表。这些寄存器存储了这些表的线性地址的基址和段长界限。指令LGDT和SGDT是用业访问全局描述符表寄存器的，而指令LLDT和SLDT则是用来访问局部描述符表寄存器的。</p>
<p>在进入保护模式之前，必须要定义GDT，也就是说，我们要在内存中构建出一张表。</p>
<p>需要说明的是：在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)；GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口。</p>
<p>CPU如何知道GDT的入口呢？在处理器内部，有一个48位的寄存器，名叫GDTR，也就是全局描述符表寄存器。其结构如下图：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/14.jpg" title="GDTR"></p>
<p>该寄存器分为2部分：<br>32位的线性基地址：GDT在内存中的起始线性地址（我们还没有涉及到分页，所以这里的线性地址等同于物理地址，下同，以后同）；<br>16位的表界限：在数值上等于表的大小（总字节数）减去1；<br>注意：在处理器刚上电的时候，基地址默认为0，表界限默认为0xFFFF; 在保护模式初始化过程中，必须给GDTR加载一个新值。</p>
<p>因为表界限是16位的，最大值是0xFFFF，也就是十进制的65535，那么表的大小就是65535+1=65536.又因为一个描述符占用8个字节，所以65536字节相当于8192个描述符（65536/8=8192）.故理论上最多可以定义8192个描述符。实际上，不一定这么多，具体多少根据需要而定。</p>
<p>理论上，GDT可以放在内存中的任何地方。但是，我们必须在进入保护模式之前就定义GDT，所以GDT一般都定义在1MB以下的内存范围中。当然，允许在进入保护模式后换个位置重新定义GDT。</p>
<p>接下来我们来分析一下MIT 6.828 jos中boot.S 中关于GDT的信息：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/15.PNG" title="boot.S 中关于GDT的信息"><br><img src="/2017/08/26/内存管理之地址转换和保护机制/16.PNG" title="boot.S 中关于GDT的信息"><br>这是一个最简单版本的段描述符，仅仅把内存分为数据段（data seg）和代码段（code seg）。<br>其中 SEG_NULL 的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SEG_NULL \</span><br><span class="line">    .word 0, 0; \</span><br><span class="line">    .byte 0, 0, 0, 0</span><br></pre></td></tr></table></figure></p>
<p>它的作用就是定义连续 8 个值为 0 的字节，这就表示一个空的 GDT 表项。处理器规定，GDT 中的第一个描述符必须是空描述符。由于全局描述符表的第一项是不被处理器使用的，所以当一个选择子的索引（Index）部分和表指示位（Table Indicator）都为0的时候（也就是说，选择子指向全局描述符表的第一项时），可以当做一个空的选择子。很多时候寄存器和内存单元的初始值都会为 0，或者程序设计无意中用全 0 的索引来选择描述符，如果第一个描述符不为0，很有可能经常错误选中描述符。当一个段寄存器被加载一个空选择子时，处理器并不会产生一个异常。但是，当用一个空选择子去访问内存时，则会产生异常。这个特点可以用来初始化不用的段寄存器，以防偶然性的非法访问。<br>而 SEG(type,base,lim)的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define SEG(type,base,lim) \</span><br><span class="line">    .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); \</span><br><span class="line">    .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), \</span><br><span class="line">        (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br></pre></td></tr></table></figure></p>
<p>在这里， type 表示段属性， base 表示段基址，而 lim 则表示段长的界限，给出这三个参数就可以用这个宏来定义一个 GDT 表项。在这里段属性的参数也是一般式通过宏的形式给出的，下表给出了常用的一些宏，这些宏每个都代表表项中的一个 bit 位，同时也代表一种段的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">宏         值       属性</span><br><span class="line">STA_X      0x8      可执行的段</span><br><span class="line">STA_E      0x4      向下扩展(该属性仅限于非可执行段)</span><br><span class="line">STA_C      0x4      一致性的代码段(仅限于可执行段)</span><br><span class="line">STA_W      0x2      可写(仅限于非可执行段)</span><br><span class="line">STA_R      0x2      可读(仅限于可执行段)</span><br><span class="line">STA_A      0x1      可访问的</span><br></pre></td></tr></table></figure></p>
<h1 id="分页地址转换"><a href="#分页地址转换" class="headerlink" title="分页地址转换"></a>分页地址转换</h1><p>在地址转换的第二个阶段，80386 将线性地址转换为实物理地址。这个阶段实现了基于页的虚拟内存和页级保护机制。<br>分页地址转换过程是可选的。只有当CR0中的PG位置位时才会产生效果。 这个位的设置一般来说是由操作系统在系统初始化的过程中设置的。如果操作系统想要实现能运行多个虚拟8086任务、基于页级的保护、基于页级的虚拟内存的话，PG位是必需置位的。</p>
<p><strong>处理器的控制寄存器的三个标识控制着分页：</strong><br>1.<strong>PG (paging) flag</strong>。CR0寄存器的第31位。从Intel386处理器开始的所有IA-32处理器均可用。该位允许页转换机制。<br>2.<strong>PSE (page size extensions) flag</strong>。CR4的第4位。当PSE位复位时，页长度为4KB，此时存在二级页表机制；当PSE置位时，页长度为4MB或2MB(PAE置位时)。<br>3.<strong>PAE (physical address extension) flag</strong>。CR4的第5位。当该位置位时，提供了一种机制将物理地址扩展到36位。只有允许分页时才能使用物理地址扩展。</p>
<p><strong>处理器用于转换线性地址为物理地址的信息包括四个数据结构：</strong><br>1.<strong>页目录</strong>：32位页目录项的数组，占据一页(4K)空间，最多有1024个页目录项。页目录项的<strong>PS</strong>位表明页目录项指向的是页表（其页表项指向一个4K的页，此时PS为0），还是直接指向4M大小的页（此时PSE和PS为1），还是直接指向2M大小的页（此时PAE和PS为1）。<br>2.<strong>页表</strong>：32位页表项的数组，占据一页(4K)空间，最多有1024个页表项。当页长为4MB或2MB时，页表将不被使用。<br>3.<strong>页</strong>：4KB、2MB、4MB的平滑地址空间。<br>4.<strong>页目录指针表</strong>：包含4个64位条目项的数组，每一个指向一个页目录。该数据结构只有当允许物理地址扩展时才被使用。</p>
<h2 id="线性地址和页表"><a href="#线性地址和页表" class="headerlink" title="线性地址和页表"></a>线性地址和页表</h2><p>线性地址通过使用一个页表，表内的一个页，和一个页内的偏移来映射到实物理地址外。格式如下：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/17.JPG" title="线性地址格式"><br>下图显示处理器如何将线性地址中的DIR，PAGE和OFFSET字段转换为实物理地址上的，这个过程使用了两级页表。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/18.JPG" title="线性地址转换为物理地址"><br>高一级的页表称为页目录，本身占据一个页，每个低一级的页表也是占据一个页，其中每个页表项占4个字节，一个页目录/页表共有1K项。首先根据cr3寄存器获取到页目录的地址（jos系统中的页目录将存储在0x113000地址上，即在内核代码存储空间内），然后使用10-bit的DIR索引得到一个页目录项，该项存储了某个二级页表的信息；接着，使用10-bit的PAGE字段索引该二级页表，得到一个页表项，该项存储了某个物理页的信息；再使用OFFSET部分来索引该物理页桢，最终访问所需要的数据。</p>
<p>在寻址一个内存页时，使用了两级的页表。高一级的页表也被叫作页目录。页目录可最多寻址1K个二级页表。一个二级页表最多可寻址1K个页面。所以，一个页目录最多可寻址1M个页面。因为每个页面有4K（2^12）字节大小。所以一个页目录可寻址整个80386的实物理地址空间（2^20 * 2^12 = 2^32）。</p>
<h2 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h2><p>两级页表项都有相同的格式，页表项的格式如下：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/19.JPG" title="页表项的格式"><br><strong>页桢地址（Page Frame Address）：</strong>页桢地址指出了一个实物理页的开始地址。因为实物理页的地址是以4K为边界的，所以地址的低12位总是为0，所以二级页表使用20位页帧地址即可表示要访问的物理页的起始地址，该物理页包含了要访问的指令操作数。二级页表本身也是占据一个页，所以页目录使用20位页帧地址即可表示二级页表的起始地址。<br><strong>存在位（Present Bit）：</strong>存在位决定了一个页表项是否可以用作地址转换过程，如果P=1则可以用该页表项。当任何一级页表项的P=0时，该项都不可以用作地址转换过程，这时，该项的其它位可以被软件使用，它们中的任何一位都不会被硬件使用。当任何一级页表项的P=0时，而软件又试图用它来访问内存时，处理器将会引发一个异常。在支持页级虚拟内存的软件系里，缺页异常处理子程序可以将所需的页面调入物理内存。引起缺页异常的指令是可以重起的。注意，没有页目录自身的存在位。当任务挂起时，该任务的页目录是可以不存在的，但是操作系必须在一个任务被重运行前确保该任务的CR3映象（保存在TSS里）指示的页面（即页目录表）在内存中。下图显示了当P=0时的页表项格式：<br><img src="/2017/08/26/内存管理之地址转换和保护机制/20.JPG" title="当P=0时的页表项格式"><br><strong>已访问位和脏位（Accessed and Dirty Bits）：</strong>这些位提供了两级页表的数据使用情况信息。除了页目录表的脏位（Dirty bit），所有的这些位都由硬件自动置位，但是处理器绝对不会复位它们。在一个页面被读或写之前，处理器将自动将两级页表的这些相关的位置1。当向一个地址写入时，处理器将会把相关的二级页表的脏位（Dirty bit）置为1。页目录表项的脏位没有作定义。当系统内存紧张时，一个支持页级虚拟内存的操作系统可以使用这些位来决定将要换出哪些物理页面。操作系统应该自已负责测试和清除这些相关位。<br><strong>读/写位，用户/特权用户位（Read / Write and User / Supervisor Bits）：</strong>这些位并不是用于地址转换过程的，它们是用来实现页级保护机制的，这些保护机制是在地址转换过程的同时实施的。</p>
<h2 id="页地址转换缓存（Page-Translation-Cache）"><a href="#页地址转换缓存（Page-Translation-Cache）" class="headerlink" title="页地址转换缓存（Page Translation Cache）"></a>页地址转换缓存（Page Translation Cache）</h2><p>为了获得最大的地址转换效率，处理器把最近使用的页表数据存储在一个芯片内的缓存中。只有当所要的地址转换信息没有在缓存中时，才有访问两级页表的必要。应用程序员是感觉不到页地址转换缓存的存在的，但系统程序员知来说不是。当页表内容改变时，操作系统程序员必须清除缓存。页地址转换缓存可以用以下两种方法清除：<br>1、 通过MOV指令重新加载CR3寄存器，例如，MOV CR3，EAX。<br>2、 通过任务切换到一个TSS，该TSS保存了一个不同的CR3映象。</p>
<h1 id="保护模式完整的权限检查"><a href="#保护模式完整的权限检查" class="headerlink" title="保护模式完整的权限检查"></a>保护模式完整的权限检查</h1><p>特权级是保护模式下一个重要的概念，CPL，RPL和DPL是其中的核心概念。<br>CPL(CS.RPL)是<strong>当前进程的权限级别</strong>(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。<br>RPL是<strong>段选择子</strong>里面的bit 0和bit 1位组合所得的值，说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的。每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限。RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样它对该段仍然只有特权为3的访问权限。<br>DPL存储在<strong>段描述符</strong>中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定的、静态不变的。当进程访问一个段时，需要进程特权级检查，一般要求<strong>DPL &gt;= max {CPL, RPL}</strong>。<br><strong>采用RPL的原因是：假设当前进程的CPL是0，将访问DPL为3的段，如果进程对目标段的RPL &gt; DPL，则当前进程仍然无法访问该段。因此控制RPL即可实现安全访问，即使线程的权限级别CPL很高。</strong></p>
<h2 id="对数据段和堆栈段访问时的特权级控制"><a href="#对数据段和堆栈段访问时的特权级控制" class="headerlink" title="对数据段和堆栈段访问时的特权级控制"></a>对数据段和堆栈段访问时的特权级控制</h2><p>程序访问数据段或堆栈段要遵循一个准则：<strong>只有相同或更高特权级的代码才能访问相应的数据段。</strong>即：访问数据段或堆栈段的程序的CPL≤待访问的数据段或堆栈段的DPL，同时选择子的RPL≤待访问的数据段或堆栈段的DPL。RPL可能会削弱CPL的作用，访问数据段或堆栈段时，默认用CPL和RPL中的最小特权（值最大）去访问数据段，所以max {CPL, RPL} ≤ DPL，否则访问失败。</p>
<h2 id="对代码段访问的特权级控制（代码执行权的特权转移）"><a href="#对代码段访问的特权级控制（代码执行权的特权转移）" class="headerlink" title="对代码段访问的特权级控制（代码执行权的特权转移）"></a>对代码段访问的特权级控制（代码执行权的特权转移）</h2><p>程序通过JMP或Call跳转时，根据目标代码段的不同对现有代码段的特权级要求有所不同，但最终结果是：<strong>一旦允许跳转，跳转后特权级别CPL不会发生变化</strong>。<br>首先我们来看看目标代码段有什么不同。</p>
<h3 id="一致代码段和非一致代码段"><a href="#一致代码段和非一致代码段" class="headerlink" title="一致代码段和非一致代码段"></a>一致代码段和非一致代码段</h3><p>一致代码段和非一致代码段的物理区分主要是根据代码段描述符里的TYPE来决定的。<br><strong>一致代码段：</strong>简单理解，就是操作系统拿出来被共享的代码段，可以被低特权级的用户直接调用访问的代码。通常这些共享代码，是“不访问”受保护的资源和某些类型异常处理。比如一些数学计算函数库，为纯粹的数学运算计算，被作为一致代码段。<br><strong>一致代码段的限制作用：</strong><br>1、特权级高的程序不允许访问特权级低的程序：核心态不允许调用用户态的程序。<br>2、特权级低的程序可以访问到特权级高的程序。但是特权级不会改变：用户态还是用户态。<br><strong>非一致代码段：</strong>为了避免低特权级的访问而被操作系统保护起来的系统代码。<br><strong>非一致代码段的限制作用：</strong><br>1、只允许同级间访问。<br>2、绝对禁止不同级访问：核心态不允许调用用户态的程序，用户态程序也不能访问核心态程序。<br>由此可知，跳转到一致代码段或非一致代码段，特权级限制是不同的。跳转又分直接跳转和通过调用门的跳转。具体是取决于目标段描述符的AR byte，有以下情况：CONFORMING-CODE-SEGMENT、NONCONFORMING-CODE-SEGMENT、CALL-GATE、TASK-GATE、TASK-STATE-SEGMENT。</p>
<p>以下跳转的内容可参考 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/CALL.htm" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2014/readings/i386/CALL.htm</a> 和<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/JMP.htm" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2014/readings/i386/JMP.htm</a> 。  </p>
<h3 id="代码间跳转的特权级限制：直接跳转"><a href="#代码间跳转的特权级限制：直接跳转" class="headerlink" title="代码间跳转的特权级限制：直接跳转"></a>代码间跳转的特权级限制：直接跳转</h3><p>普通转跳不经过Gate，JMP或Call后跟着48位全指针（16位段选择子+32位地址偏移），且其中的段选择子指向代码段描述符，这样的跳转称为直接（普通）跳转。普通跳转不能使特权级发生跃迁，即不会引起CPL的变化。  </p>
<p><strong>如果目标代码段是一致代码段：</strong><br><strong>要求：</strong>当前代码段CPL &gt;= 目标代码段描述符DPL ，RPL不检查。适用于JMP和CALL。<br><strong>结果：</strong>Load CS with new code segment selector。转跳后程序的CPL = 转跳前程序的CPL。<br><strong>说明：</strong>CPL没有发生变化，纵使它执行了特权级DPL较高的代码。若访问时不满足要求，则发生异常。  </p>
<p><strong>如果目标代码段是非一致代码段：</strong><br><strong>要求：</strong>当前代码段CPL = 目标代码段描述符DPL AND 当前代码段CPL &gt;= 目标代码段选择子RPL。此时目标代码段选择子RPL &lt;= 目标代码段描述符DPL。适用于JMP和CALL。<br><strong>结果：</strong>Load CS with new code segment selector; Set RPL field of CS register to CPL。转跳后程序的CPL = 目标代码段描述符DPL = 转跳前程序的CPL。<br><strong>说明：</strong>因为前提是CPL=DPL，所以转跳后程序的CPL = 目标代码段描述符DPL不会改变CPL的值，特权级(CPL)也没有发生变化。如果访问时不满足前提CPL=DPL，则引发异常。</p>
<h3 id="代码间跳转的特权级限制：通过调用门CALL-GATE的跳转"><a href="#代码间跳转的特权级限制：通过调用门CALL-GATE的跳转" class="headerlink" title="代码间跳转的特权级限制：通过调用门CALL-GATE的跳转"></a>代码间跳转的特权级限制：通过调用门CALL-GATE的跳转</h3><p>当段间转移指令JMP和段间转移指令CALL后跟着的目标段选择子指向一个调用门描述符时，该跳转就是利用调用门的跳转。这时如果选择子后跟着32位的地址偏移，也不会被cpu使用，因为调用门描述符已经记录了目标代码的偏移。使用调门进行的跳转比普通跳转多一个步骤，即在访问调用门描述符时要将描述符当作一个数据段来检查访问权限，具体是：<strong>当前代码段CPL &lt;= 门描述符DPL；调用门选择子RPL &lt;= 门描述符DPL</strong>。只有满足了以上条件，CPU才会进一步从调用门描述符中读取目标代码段的选择子和地址偏移。<br>从调用门中读取到目标代码的段选择子和地址偏移后（不同于普通跳转一开始就得到了目标代码的段选择子和地址偏移），CPU会将读到的目标代码段选择子中的RPL清0，即忽略了调用门中代码段选择子的RPL的作用。完成这一步后，CPU开始对当前程序的CPL，目标代码段选择子的RPL（事实上它被清0后总能满足要求）以及由目标代码选择子指示的目标代码段描述符中的DPL进行特权级检查，并根据情况进行跳转。  </p>
<p><strong>如果目标代码段是一致代码段：</strong><br><strong>要求：</strong>当前代码段CPL &gt;= 目标代码段描述符DPL，RPL被清0，不检查，永远满足RPL &lt;= DPL。适用于JMP和CALL。<br><strong>结果：</strong>Load CS register with new code-segment descriptor；Set RPL of CS to CPL。转跳后程序的CPL = 转跳前程序的CPL。（CALL指令是SAME-PRIVILEGE）。</p>
<p><strong>如果目标代码段是非一致代码段：</strong><br>JMP指令：<br><strong>要求：</strong>当前代码段CPL = 目标代码段描述符DPL，（RPL被清0，不检查）。<br><strong>结果：</strong>Load CS register with new code-segment descriptor；Set RPL of CS to CPL。转跳后程序的CPL = 目标代码段描述符DPL = 转跳前程序的CPL。<br>CALL指令：<br><strong>要求：</strong>当前代码段CPL &gt;= 目标代码段描述符DPL，（RPL被清0，不检查）。<br><strong>结果：</strong>如果当前代码段CPL &gt; 目标代码段描述符DPL：（MORE-PRIVILEGE）Load CS descriptor；Set CPL to stack segment DPL；Set RPL of CS to CPL。<br>如果当前代码段CPL = 目标代码段描述符DPL：（SAME-PRIVILEGE）Load code segment descriptor into CS register，Set RPL of CS to CPL。转跳后程序的CPL = 目标代码段描述符DPL。  </p>
<p>当条件CPL=DPL时，程序跳转后CPL=DPL,特权级不发生跃迁；当CPL＞DPL时，程序跳转后CPL=DPL,特权级发生跃迁，这是我们当目前位置唯一见到的使程序当前执行忧先级(CPL)发生变化的跳转方法，即用CALL指令+调用门方式跳转，且目标代码段是非一致代码段。</p>
<h3 id="代码间跳转的特权级限制：通过任务门TASK-GATE的跳转"><a href="#代码间跳转的特权级限制：通过任务门TASK-GATE的跳转" class="headerlink" title="代码间跳转的特权级限制：通过任务门TASK-GATE的跳转"></a>代码间跳转的特权级限制：通过任务门TASK-GATE的跳转</h3><p><strong>当前代码段CPL &lt;= 门描述符DPL；调用门选择子RPL &lt;= 门描述符DPL</strong>，然后测试任务门给出的指向TSS的选择子，TSS描述符AR byte必须指向可用的TSS。切换到TSS的任务。</p>
<h3 id="代码间跳转的特权级限制：通过TASK-STATE-SEGMENT的跳转"><a href="#代码间跳转的特权级限制：通过TASK-STATE-SEGMENT的跳转" class="headerlink" title="代码间跳转的特权级限制：通过TASK-STATE-SEGMENT的跳转"></a>代码间跳转的特权级限制：通过TASK-STATE-SEGMENT的跳转</h3><p><strong>当前代码段CPL &lt;= TSS描述符DPL；TSS选择子RPL &lt;= TSS描述符DPL</strong>，TSS描述符AR byte必须指向可用的TSS。切换到TSS的任务。</p>
<h1 id="jos系统保护机制"><a href="#jos系统保护机制" class="headerlink" title="jos系统保护机制"></a>jos系统保护机制</h1><p>接下来我们来看一下MIT 6.828 jos中关于CPL、RPL、DPL的相关设置。<br><strong>创建用户进程结构</strong>的时候，会设置env的trapframe相关寄存器值，其中，ds、es、ss、cs的低2位代表RPL，RPL说明了进程对该段选择子对应的段描述符描述的段的访问权限。trapframe相关寄存器值会被加载到相应寄存器的可视部分（选择子）。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/21.PNG" title="创建用户进程结构时设置env的trapframe相关寄存器值"><br><img src="/2017/08/26/内存管理之地址转换和保护机制/22.JPG" title="段寄存器">  </p>
<p><strong>执行程序过程中可能产生中断</strong>，中断会经由中断门或陷阱门，<strong>中断门或陷阱门的门描述符描述了中断处理程序的代码段选择子和偏移位置等信息。在这里，代码段选择子sel就是内核代码段选择子，权限是TI为0，RPL为0，所以给sel传递参数<code>GD_KT</code>即可（或者是<code>GD_KT | 0</code>更明显）。</strong>中断门本身也有DPL，约束了中断或异常的特权级别。如果触发中断的程序CPL&gt;中断门的DPL，则不能调用相应处理函数。所以系统调用、断点需要设置dpl为3才能被用户程序调用。<br>如果可以调用中断处理函数，则调用之前处理器会将中断门sel部分加载到cs段选择器中（以及对应的cs隐藏部分），在这里是<code>GD_KT</code>，在GDT中查找到对应的段描述符，并加上偏移地址得出处理程序地址（中断处理程序定义在内核中，所以偏移地址也就是中断处理程序的入口地址）。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/23.PNG" title="中断门或陷阱门"><br><img src="/2017/08/26/内存管理之地址转换和保护机制/24.PNG" title="初始化IDT">    </p>
<p><strong>执行中断程序时</strong>，由代码段选择子的CPL/RPL和段描述符DPL决定是否能够访问内核代码段，段描述符DPL在GDT表的初始化过程中已经设置好了。<br><img src="/2017/08/26/内存管理之地址转换和保护机制/25.PNG" title="初始化GDT">    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/Intel-32-位处理器的工作模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/Intel-32-位处理器的工作模式/" itemprop="url">Intel 32 位处理器的工作模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T11:13:42+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：以下内容引用自 <a href="http://www.kancloud.cn/digest/protectedmode/121472" target="_blank" rel="noopener">16位模式/32位模式下PUSH指令探究-《x86汇编语言：从实模式到保护模式》读书笔记16</a><br><img src="/2017/08/26/Intel-32-位处理器的工作模式/1.jpg" title="工作模式"><br>如上图所示，Intel 32 位处理器有3种工作模式。<br>（1）实模式：工作方式相当于一个8086<br>（2）保护模式：提供支持多任务环境的工作方式，建立保护机制<br>（3）虚拟8086模式：这种方式可以使用户在保护模式下运行8086程序（比如cmd打开的console窗口，就是工作在虚拟8086模式）</p>
<p>最早期的8086 CPU（16位）只有一种工作方式，那就是实模式，而且数据总线为16位（一次最多能取2^16＝64KB数据，实模式下每个段最大只有64KB），地址总线为20位（寻址的能力是2^20=1MB，实模式下CPU的最大寻址能力），实模式下所有寄存器都是16位。<br>从 80286 开始就有了保护模式，从 80386 开始 CPU 数据总线和地址总线均为 32 位，而且寄存器都是 32 位。但 80386 以及现在的奔腾、酷睿等等 CPU 为了向前兼容都保留了实模式。  </p>
<p>有几点需要特别说明：<br>（1）保护模式可分为16位和32位的，由段描述符中的D标志指明。对于32位代码段和数据段，这个标志总是设为1；对于16位代码和数据段，这个标志被设置为0.<br>D=1：默认使用32位地址和32位或8位的操作数。<br>D=0：默认使用16位地址和16位或8位的操作数。（主要是为了能够在32位处理器上运行16位保护模式的程序）<br>指令前缀0x66用来选择非默认值的操作数大小，0x67用来选择非默认值的地址大小。<br>（2）在实模式下，也可以使用32位的寄存器，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,ecx</span><br><span class="line">mov ebx,0x12345678</span><br></pre></td></tr></table></figure></p>
<p>（3）在书中，把实模式和16位的保护模式统称为“16位模式”；把32位保护模式称为“32位模式”。<br>（4）32位处理器可以执行16位的程序，包括实模式和16位保护模式。<br>（5）当处理器在16位模式下运行时，可以使用32位的寄存器，执行32位运算。<br>（6）在16位模式下，数据的大小是8位或者16位的；控制转移和内存访问时，偏移量也是16位的。<br>（7）32位保护模式兼容80286的16位保护模式。<br>（8）在16位模式下，处理器把所有指令都看成是16位的。  </p>
<p>结合（5）和（8），我们发现一个问题：当处理器运行16位模式下，既然把所有指令都看成16位的，那么怎么使用32位的寄存器，执行32位的运算呢？答案是利用指令前缀0x66和0x67。前面已经说过，指令前缀0x66用来选择非默认值的操作数大小，0x67用来选择非默认值的地址大小。</p>
<p>比如说，指令码0x40在16位模式下对应的指令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc ax</span><br></pre></td></tr></table></figure></p>
<p>如果加上前缀0x66，也就是指令码66 40，当处理器在16位模式下运行，66 40对应的指令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc eax</span><br></pre></td></tr></table></figure></p>
<p>同理，如果处理器运行在32位模式下，处理器认为指令是32位的，如果加了0x66，那么就表示指令的操作数是16位的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/大端和小端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/大端和小端/" itemprop="url">大端和小端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T11:11:16+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a>  </p>
<h1 id="大端和小端的问题"><a href="#大端和小端的问题" class="headerlink" title="大端和小端的问题"></a>大端和小端的问题</h1><p>对于整型、长整型等数据类型，Big endian 认为第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）；而 Little endian 则相反，它认为第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）。</p>
<h1 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h1><p>如果我们将0x1234abcd 写入到以 0x0000 开始的内存中，则Little endian 和 Big endian 模式的存放结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">地址           0x0000         0x0001        0x0002          0x0003   </span><br><span class="line">big-endian     0x12           0x34          0xab            0xcd    </span><br><span class="line">little-endian  0xcd           0xab          0x34            0x12</span><br></pre></td></tr></table></figure></p>
<h1 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h1><p>假设从内存地址 0x0000 开始有以下数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000         0x0001       0x0002       0x0003  </span><br><span class="line">0x12           0x34         0xab         0xcd</span><br></pre></td></tr></table></figure></p>
<p>如果我们去读取一个地址为 0x0000 的四个字节变量，若字节序为 big-endian，则读出结果为 0x1234abcd；若字节序为 little-endian，则读出结果为 0xcdab3412。  </p>
<h1 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h1><p>一般来说，x86 系列 CPU 都是 little-endian 的字节序，PowerPC 通常是 big-endian，网络字节顺序也是 big-endian，还有的 CPU 能通过跳线来设置 CPU 工作于 Little endian 还是 Big endian 模式。</p>
<h1 id="x86-gcc"><a href="#x86-gcc" class="headerlink" title="x86 gcc"></a>x86 gcc</h1><p>对于 x86 gcc 而言，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure></p>
<p>小端模式下：十进制的 57616 是 0xe110，由低地址到高地址的存储是 0x10 0xe1， 0x00646c72 由低地址到高地址的存储是 0x72 0x6c 0x64 0x00；读取的时候，57616 按照小端法正常读取，&amp;i 被分成四部分读取输出，分别是 0x72 0x6c 0x64 0x00，0x00 代表就是空字符，即标识字符串的结束。<br>大端模式下：十进制的 57616 是 0xe110，由低地址到高地址的存储是  0xe1 0x10， 0x00646c72 由低地址到高地址的存储是 0x00 0x64 0x6c 0x72；读取的时候，57616 按照大端法正常读取，&amp;i 被分成四部分读取输出，分别是 0x00 0x64 0x6c 0x72。因此，大端模式下，想要正常输出的话，需要将 i 修改为 0x726c6400，而 57616 无需做修改。</p>
<h1 id="32-位数大小端互转程序"><a href="#32-位数大小端互转程序" class="headerlink" title="32 位数大小端互转程序"></a>32 位数大小端互转程序</h1><pre><code>uint32_t reversebytes_uint32t(uint32_t value){  
    return (value &amp; 0x000000FFU) &lt;&lt; 24 | (value &amp; 0x0000FF00U) &lt;&lt; 8 |   
        (value &amp; 0x00FF0000U) &gt;&gt; 8 | (value &amp; 0xFF000000U) &gt;&gt; 24;   
}  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/异常和中断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/异常和中断/" itemprop="url">异常和中断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T10:45:33+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机原理/" itemprop="url" rel="index">
                    <span itemprop="name">计算机原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下内容摘抄自《80386 Programmer’s Manual》</p>
<h1 id="《Chapter-9-Exceptions-and-Interrupts》"><a href="#《Chapter-9-Exceptions-and-Interrupts》" class="headerlink" title="《Chapter 9, Exceptions and Interrupts》"></a>《Chapter 9, Exceptions and Interrupts》</h1><p>中断和异常是特殊类型的控制转移，它们的表现有时候像不受计算机程序支配的<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/CALL.htm" target="_blank" rel="noopener">CALL</a>。中断和异常改变了正常程序流，以处理外部事件或报告错误、异常情况。中断和异常的区别是，中断interrupts用于处理处理器外部的异步事件，异常exceptions用于处理处理器在执行指令时检测到的情况。<br><strong>外部中断的两个来源：</strong><br>1、可屏蔽中断Maskable interrupts，通过INTR pin来发送信号。<br>2、不可屏蔽中断Nonmaskable interrupts，通过NMI (Non-Maskable Interrupt) pin来发送信号。<br><strong>异常的两个来源：</strong><br>1、处理器检测。进一步分为故障faults、陷阱traps和中止aborts。<br>2、编程。指令INTO、INT 3、INT n、BOUND可以引发异常。这些指令通常被称为“软件中断”，但处理器把它们当作异常处理。</p>
<h2 id="《9-1-Identifying-Interrupts》"><a href="#《9-1-Identifying-Interrupts》" class="headerlink" title="《9.1 Identifying Interrupts》"></a>《9.1 Identifying Interrupts》</h2><p>每一个不同类型的中断或异常都有一个处理器可识别的数。处理器给不可屏蔽中断和异常分配了0-31的标识符。80386目前没有使用所有的数字，在这个范围内未赋值的标识符保留了未来扩张的可能性。可屏蔽中断的标识符是由外部中断控制器决定的，如英特尔的8259A可编程中断控制器，并在处理器的中断应答序列interrupt-acknowledge sequence过程中与处理器通信。具体的分配如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Identifier   Description</span><br><span class="line"></span><br><span class="line">0            Divide error</span><br><span class="line">1            Debug exceptions</span><br><span class="line">2            Nonmaskable interrupt</span><br><span class="line">3            Breakpoint (one-byte INT 3 instruction)</span><br><span class="line">4            Overflow (INTO instruction)</span><br><span class="line">5            Bounds check (BOUND instruction)</span><br><span class="line">6            Invalid opcode</span><br><span class="line">7            Coprocessor not available</span><br><span class="line">8            Double fault</span><br><span class="line">9            (reserved)</span><br><span class="line">10           Invalid TSS</span><br><span class="line">11           Segment not present</span><br><span class="line">12           Stack exception</span><br><span class="line">13           General protection</span><br><span class="line">14           Page fault</span><br><span class="line">15           (reserved)</span><br><span class="line">16           Coprecessor error</span><br><span class="line">17-31        (reserved)</span><br><span class="line">32-255       Available for external interrupts via INTR pin</span><br></pre></td></tr></table></figure></p>
<p>根据报告的方式以及是否支持重新启动导致异常的指令，异常被分为故障、陷阱、终止。<br><strong>故障：</strong><br>故障是这样一种异常：要么在指令开始执行之前被检测到，要么在指令执行期间被检测到。如果在指令执行期间被检测到，机器恢复到能允许重启导致故障的指令的状态，然后报告故障。<br><strong>陷阱：</strong><br>陷阱是这样一种异常：在检测到异常的指令之后的指令边界立即被报告。<br><strong>终止：</strong><br>终止是这样一种异常：它既不允许获取引起异常的指令的精确位置，也不允许重启导致异常的程序。终止用于报告严重的错误，比如硬件错误和不一致、系统表的非法值。</p>
<h2 id="《9-2-Enabling-and-Disabling-Interrupts》"><a href="#《9-2-Enabling-and-Disabling-Interrupts》" class="headerlink" title="《9.2 Enabling and Disabling Interrupts》"></a>《9.2 Enabling and Disabling Interrupts》</h2><p>处理器只在一条指令结束及下一条指令开始之际处理异常和中断。在指令边界，处理器通过某些条件和标识设置禁止某些异常和中断。</p>
<h3 id="《9-2-1-NMI-Masks-Further-NMIs》"><a href="#《9-2-1-NMI-Masks-Further-NMIs》" class="headerlink" title="《9.2.1 NMI Masks Further NMIs》"></a>《9.2.1 NMI Masks Further NMIs》</h3><p>如果正在执行一个不可屏蔽中断的处理程序，处理器将忽略其他来自NMI pin的中断信号，直至执行<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/IRET.htm" target="_blank" rel="noopener">IRET</a>指令。</p>
<h3 id="《9-2-2-IF-Masks-INTR》"><a href="#《9-2-2-IF-Masks-INTR》" class="headerlink" title="《9.2.2 IF Masks INTR》"></a>《9.2.2 IF Masks INTR》</h3><p>允许中断标志位IF（interrupt-enable flag）控制着是否接受经由INTR pin的外部中断信号。当IF=0，禁止INTR中断；当IF=1，允许INTR中断。处理器接收到RESET信号后，将清除IF和其他标志位。<br><strong>显式改变IF：</strong><a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/CLI.htm" target="_blank" rel="noopener">CLI</a>(Clear Interrupt-Enable Flag)和<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/STI.htm" target="_blank" rel="noopener">STI</a>(Set Interrupt-Enable Flag)显式改变IF(bit 9 in the flag register)。只有CPL &lt; = IOPL时才允许执行CLI和STI，否则将会发生保护异常。<br><strong>隐式改变IF：</strong>1、指令<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/PUSHF.htm" target="_blank" rel="noopener">PUSHF</a>将会在栈上存储所有的标识，包括IF。2、任务切换和指令<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/POPF.htm" target="_blank" rel="noopener">POPF</a>、<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/IRET.htm" target="_blank" rel="noopener">IRET</a>将加载标志寄存器，会修改IF。3、中断门interrupt gates自动重置IF，禁止中断。  </p>
<h3 id="《9-2-3-RF-Masks-Debug-Faults》"><a href="#《9-2-3-RF-Masks-Debug-Faults》" class="headerlink" title="《9.2.3 RF Masks Debug Faults》"></a>《9.2.3 RF Masks Debug Faults》</h3><p>EFLAGS的RF位控制识别出调试错误，给定一条指令，无论它被重启多少次，RF使得最多只有一次调试错误出现。</p>
<h3 id="《9-2-4-MOV-or-POP-to-SS-Masks-Some-Interrupts-and-Exceptions》"><a href="#《9-2-4-MOV-or-POP-to-SS-Masks-Some-Interrupts-and-Exceptions》" class="headerlink" title="《9.2.4 MOV or POP to SS Masks Some Interrupts and Exceptions》"></a>《9.2.4 MOV or POP to SS Masks Some Interrupts and Exceptions》</h3><p>软件经常需要使用成对的指令来改变堆栈段，比如<strong>MOV SS, AX</strong>、<strong>MOV ESP, StackTop</strong>。如果SS已经改变而ESP还未收到相应的改变的时候处理异常或中断，中断或异常处理程序执行期间栈指针SS:ESP是不一致的。为了防止这种情况的发生，80386在执行<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/MOV.htm" target="_blank" rel="noopener">MOV</a> SS和<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/POP.htm" target="_blank" rel="noopener">POP</a> SS指令之后，在下一条指令的指令边界内禁止NMI、INTR、debug exceptions、single-step traps。但是页错误和保护错误仍可能发生，若使用80386 <a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LGS.htm" target="_blank" rel="noopener">LSS</a>指令，则不会出现这些问题。</p>
<h2 id="《9-3-Priority-Among-Simultaneous-Interrupts-and-Exceptions》"><a href="#《9-3-Priority-Among-Simultaneous-Interrupts-and-Exceptions》" class="headerlink" title="《9.3 Priority Among Simultaneous Interrupts and Exceptions》"></a>《9.3 Priority Among Simultaneous Interrupts and Exceptions》</h2><p>如果在指令边界有多个中断或异常在等待，处理器一次只会处理其中一个。该中断或异常的分类需具有最高优先级。处理器将控制转移到中断处理程序的第一个指令。低优先级的异常被丢弃，低优先级的中断保持等待。在中断处理程序返回控制权的时候，被丢弃的异常将被重新发现。<br>同时发生的异常和中断的优先级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Priority   Class of Interrupt or Exception</span><br><span class="line"></span><br><span class="line">HIGHEST    Faults except debug faults</span><br><span class="line">           Trap instructions INTO, INT n, INT 3</span><br><span class="line">           Debug traps for this instruction</span><br><span class="line">           Debug faults for next instruction</span><br><span class="line">           NMI interrupt</span><br><span class="line">LOWEST     INTR interrupt</span><br></pre></td></tr></table></figure></p>
<h2 id="《9-4-Interrupt-Descriptor-Table》"><a href="#《9-4-Interrupt-Descriptor-Table》" class="headerlink" title="《9.4 Interrupt Descriptor Table》"></a>《9.4 Interrupt Descriptor Table》</h2><p>中断描述符表（Interrupt Descriptor Table，IDT）将每个异常或中断向量分别与它们的处理过程联系起来。与GDT和LDT表类似，IDT也是由8字节长描述符组成的一个数组。与GDT和LDT表不同的是，IDT的第一项可以包含一个描述符。为了构成IDT表中的一个索引值，处理器把异常或中断的向量号乘以8。因为最多只有256个中断或异常向量，所以IDT无需包含多于256个描述符。IDT中可以含有少于256个描述符，因为只有可能发生的异常或中断才需要描述符。不过IDT中所有空描述符项应该设置其存在位（标志）为0。<br>IDT表可以驻留在线性地址空间的任何地方，处理器使用IDTR寄存器来定位IDT表的位置。这个寄存器中含有IDT表32位的基地址和16位的长度（限长）值。IDT表基地址应该对齐在8字节边界上以提高处理器的访问效率。限长值是以字节为单位的IDT表的长度。<br><a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LGDT.htm" target="_blank" rel="noopener">LIDT</a>和<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/SGDT.htm" target="_blank" rel="noopener">SIDT</a>指令分别用于加载和保存IDTR寄存器的内容，两者都有一个显式的操作数：内存中一个6字节区域的地址。LIDT指令用于把内存中的限长值和基地址操作数加载到IDTR寄存器中。该指令仅能由当前特权级CPL是0的代码执行，通常被用于创建IDT时的操作系统初始化代码中。SIDT指令用于把IDTR中的基地址和限长内容复制到内存中。该指令可在任何特权级上执行。如果中断或异常向量引用的描述符超过了IDT的界限，处理器会产生一个一般保护性异常。<br>中断描述符寄存器和中断寄存器表：<br><img src="/2017/08/26/异常和中断/1.gif" title="中断描述符寄存器和中断寄存器表"><br>LIDT和SIDT的伪描述符格式：<br><img src="/2017/08/26/异常和中断/2.gif" title="LIDT和SIDT的伪描述符格式"></p>
<h2 id="《9-5-IDT-Descriptors》"><a href="#《9-5-IDT-Descriptors》" class="headerlink" title="《9.5 IDT Descriptors》"></a>《9.5 IDT Descriptors》</h2><p>IDT可能包括3种描述符：Task gates、Interrupt gates、Trap gates。<br><img src="/2017/08/26/异常和中断/3.gif" title="IDT 3种描述符"><br>参考于<a href="http://stackoverflow.com/questions/3425085/%20the-difference-between-call-gate-interrupt-gate-trap-gate，对各种门描述符进行分析。" target="_blank" rel="noopener">http://stackoverflow.com/questions/3425085/%20the-difference-between-call-gate-interrupt-gate-trap-gate，对各种门描述符进行分析。</a><br>通用寄存器EFLAGS保存的是CPU的执行状态和控制信息，其中只需要关注两个寄存器：IF和TF。<br><img src="/2017/08/26/异常和中断/4.PNG" title="EFLAGS"><br><strong>TF(Trap Flag)</strong>：跟踪标志。置1则开启单步执行调试模式，置0则关闭。在单步执行模式下，处理器在每条指令后产生一个调试异常，这样在每条指令执行后都可以查看执行程序的状态。<br><strong>IF(Interrupt enable)</strong>：中断许可标志。控制处理器对可屏蔽硬件中断请求的响应。置1则开启可屏蔽硬件中断响应，置0则关闭。IF标志不影响异常和不可屏蔽终端NMI的产生。  </p>
<p><strong>gate用于实现从一段代码跳转到另一段代码（可能存在不同的代码段、不同的特权级）时的保护机制问题。</strong>一般而言，存在四种gate：<br>1、Task gate。只能存在GDT或IDT中并被int指令调用。因特尔工程师设计TSS（Task State Segment）主要是通过保存任务的寄存器状态来应用于硬件任务切换。触发硬件任务切换有两种方式，一种是使用TSS本身，一种是使用Task gate。可以通过call和jmp指令导致任务切换。Task gate设计的目的可能是用于在中断到来时触发硬件任务切换，因为跳转到TSS的选择器并不能触发硬件任务切换。现实情况下，由于使用不方便和性能不佳的原因，Task gate和硬件上下文切换功能基本不被使用。例如考虑到TSS只能存在GDT中，而GDT的长度不能大于8192，这就意味着从硬件的角度来说任务数不能超过8k。<br>2、Trap gate。只能存到IDT中并被int指令调用。Trap gate只是将控制权传递给陷阱门描述符指定的拥有更多特权的段的地址。Trap gate的用处在于：system call的实现；异常处理的实现；中断处理的实现（on machines with APIC）。<br>3、Interrupt gate。只能存到IDT中并被int指令调用。类似于Trap gate但会清空IF标志。<br>4、Call gate。可被存到GDT和LDT中并被call和jmp指令调用。类似于Trap gate，Call gate可以从用户模式的任务栈传递参数到内核模式的任务栈。传递的参数数量在Call gate的描述符中指定。Call的使用场景不多，因为：可以使用Trap gate代替；不轻便，如果另一个处理器没有类似的功能，则操作系统移植到另一个处理器的时候为了支持Call gate必须编写更多的代码；不灵活，栈之间可以传递的参数是有限的；性能不优。</p>
<p>Interrupt gate和Trap gate用来专门处理处理器异常或者中断，Task gate和Call gate一般用来处理用户的软件切换。<br>Interrupt gate和Trap gate的区别：一般情况下，Interrupt gate用于处理意外发生的错误，Trap gate用于处理软件中断和异常，比如页错误、调试中断、除0错误等。Interrupt gate会修改IF，即不再响应接下来的中断了。比如操作系统捕获了一个硬件中断正在处理，又来了另一个。如果用Trap gate，那么第一个处理就被打断了，这样会造成数据崩溃，所以必须屏蔽掉第二个，使一次硬件操作成为原子操作（NMI另说）。还有一个就是断点异常的处理必须暴露给用户程序进行调用，使用Trap gate处理。<br>Call gate和Task gate的区别：task是一个具体可运行的单位，可以运行、挂起、重启等，task的状态保存在TSS中。可以通过call或jmp指令具体调用一个task程序。Call gate和Task gate都可以用来切换到一个task，但是Task gate的寻址需要经过一个TSS找到code selector（具体见task gate descriptor），这比Call gate麻烦，但是带来的好处是：1、切换的时候原来task的上下文环境被自动保存到TSS。2、如果使用Task gate来处理中断例程，可以使程序和其他例程分开，使其具有独立的地址空间等。</p>
<p>以上四种切换机制的细节如下：<br><img src="/2017/08/26/异常和中断/5.PNG" title="四种切换机制"></p>
<h2 id="《9-6-Interrupt-Tasks-and-Interrupt-Procedures》"><a href="#《9-6-Interrupt-Tasks-and-Interrupt-Procedures》" class="headerlink" title="《9.6 Interrupt Tasks and Interrupt Procedures》"></a>《9.6 Interrupt Tasks and Interrupt Procedures》</h2><p>类似于<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/CALL.htm" target="_blank" rel="noopener">CALL</a>指令可以调用程序procedure或任务task，中断或异常可以调用一个中断处理程序handler，该handler可能是程序procedure或任务task。当响应中断或异常的时候，处理器使用中断或异常标志在IDT中索引描述符。如果处理器索引到一个中断门或陷阱门，它调用处理程序的方式类似于CALL指令调用一个调用门call gate。如果处理器索引到一个任务门，类似于CALL指令调用一个任务门task gate，它将导致一个任务切换。</p>
<h3 id="《9-6-1-Interrupt-Procedures》"><a href="#《9-6-1-Interrupt-Procedures》" class="headerlink" title="《9.6.1 Interrupt Procedures》"></a>《9.6.1 Interrupt Procedures》</h3><p>中断门或陷阱门间接指向一个处理程序，该程序将在当前执行任务的上下文中被执行。中断门或陷阱门的选择器指向了GDT或当前LDT的一个可执行段描述符。中断门或陷阱门的偏移部分指向了中断或异常处理程序的起始位置。如下所示：<br><img src="/2017/08/26/异常和中断/6.gif" title="中断门或陷阱门间接指向一个处理程序"><br>80386调用一个中断或异常处理程序的方式大致类似于CALL一个程序，以下部分将解释两者差异之处。</p>
<h4 id="《9-6-1-1-Stack-of-Interrupt-Procedure》"><a href="#《9-6-1-1-Stack-of-Interrupt-Procedure》" class="headerlink" title="《9.6.1.1 Stack of Interrupt Procedure》"></a>《9.6.1.1 Stack of Interrupt Procedure》</h4><p>就像CALL指令导致控制转移一样，中断或异常处理程序的控制转移使用了栈存储了返回原先程序需要的信息。一个中断将在指针指向中断指令之前将EFLAGS进栈，如下图所示。某些异常会导致error code进栈，异常处理函数可以通过error code判断是什么异常。<br><img src="/2017/08/26/异常和中断/7.gif" title="一个中断将在指针指向中断指令之前将EFLAGS进栈"></p>
<h4 id="《9-6-1-2-Returning-from-an-Interrupt-Procedure》"><a href="#《9-6-1-2-Returning-from-an-Interrupt-Procedure》" class="headerlink" title="《9.6.1.2 Returning from an Interrupt Procedure》"></a>《9.6.1.2 Returning from an Interrupt Procedure》</h4><p>中断程序离开程序的方法也不用于普通程序，它将使用<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/IRET.htm" target="_blank" rel="noopener">IRET</a>指令离开。IRET类似于RET，除了IRET会将ESP额外增量四个字节(因为flags在栈上)，并将保存的flags赋值到EFLAGS寄存器中。仅当CPL=0时，EFLAGS的IOPL部分将会被改变；仅当CPL &lt;= IOPL时，EFLAGS的IF部分才会被改变。</p>
<h4 id="《9-6-1-3-Flags-Usage-by-Interrupt-Procedure》"><a href="#《9-6-1-3-Flags-Usage-by-Interrupt-Procedure》" class="headerlink" title="《9.6.1.3 Flags Usage by Interrupt Procedure》"></a>《9.6.1.3 Flags Usage by Interrupt Procedure》</h4><p>通过中断门或陷阱门的中断在当前TF(the trap flag)作为EFLAGS的一部分被保存到栈后，将清零TF。通过这个动作处理器可以防止使用单步调试活动影响中断响应。随后IRET指令恢复EFLAGS在栈上的值，也恢复了TF。<br><strong>中断门和陷阱门的不同在于对IF(the interrupt-enable flag)的影响。经由中断门的中断将重置IF，防止其他中断（当IF=1，允许INTR中断）干扰当前的中断处理程序，随后IRET指令恢复EFLAGS在栈上的值。经由陷阱门的中断将不改变IF。</strong></p>
<h4 id="《9-6-1-4-Protection-in-Interrupt-Procedures》"><a href="#《9-6-1-4-Protection-in-Interrupt-Procedures》" class="headerlink" title="《9.6.1.4 Protection in Interrupt Procedures》"></a>《9.6.1.4 Protection in Interrupt Procedures》</h4><p>管理中断程序的特权规则类似于程序调用：CPU不允许一个中断转移控制到一个比当前权限更少特权的程序。试图违反该规则将会导致一般保护异常。由于中断的发生一般不可预测，特权规则可以有效地在可执行的中断或异常处理程序的特权级别上强加限制。以下策略确保特权规则不被违反：1、将处理程序安置在一个conforming segment，这种策略用于处理某些异常（如divide error），该程序只能使用栈上可被使用的数据，如果它需要数据段的数据，数据段必须有特权级别3，从而使其不受保护。2、将处理程序安置在特权级别为0的栈上。</p>
<h3 id="《9-6-2-Interrupt-Tasks》"><a href="#《9-6-2-Interrupt-Tasks》" class="headerlink" title="《9.6.2 Interrupt Tasks》"></a>《9.6.2 Interrupt Tasks》</h3><p>IDT的任务门间接指向一个任务，任务门的选择器指向GDT的TSS描述符。如下图所示：<br><img src="/2017/08/26/异常和中断/8.gif" title="任务门指向一个任务"><br>经由任务门的中断或陷阱的结果是出现一个任务切换。使用一个单独任务来处理中断有两个优点：1、整个上下文将被自动保存。2、通过LDT或页目录给予处理程序单独的地址空间，使其独立于其他任务。<br>中断任务通过IRET返回被中断的任务。<br>如果导致任务切换的异常有一个错误代码，处理器会自动把错误代码放入栈中，对应于中断任务执行的第一条指令的特权级别。<br>当80386操作系统使用中断任务时，实际上有两个调度器：软件调度器(操作系统的一部分)和硬件调度器(处理器的中断机制的一部分)。软件调度器的设计应该考虑一种情况：在启用中断时，硬件调度器随时可能派遣一个中断任务。 </p>
<h2 id="《9-7-Error-Code》"><a href="#《9-7-Error-Code》" class="headerlink" title="《9.7 Error Code》"></a>《9.7 Error Code》</h2><p>当异常涉及到特定的段，处理器将异常处理程序的错误码放入栈中(无论是程序或任务)。错误码的格式如下：<br><img src="/2017/08/26/异常和中断/9.gif" title="错误码的格式"><br>类似于选择器的格式，但是它没有RPL，而是包含两个one-bit项：1、如果程序的外部事件导致异常，处理器设置EXT位；2、如果错误码的索引部分指向了IDT的门描述符，处理器设置I-bit (IDT-bit)。<br>如果没有设置I-bit，TI值为0表示错误码指向GDT，TI值为1表示指向LDT。剩下的14 bits（包括TI）是段选择符的高14位。在某些情况下，栈上的错误码为空，即低位的word为空。</p>
<h2 id="《9-8-Exception-Conditions》"><a href="#《9-8-Exception-Conditions》" class="headerlink" title="《9.8 Exception Conditions》"></a>《9.8 Exception Conditions》</h2><p>下面详细描述每一个可能的异常情况。每个描述将异常按故障、陷阱、中止分类。这种分类为系统重启发生异常的程序提供了必要信息。<br><strong>故障faults</strong>：当故障被报告时，导致故障的指令的CS和EIP值将被保存。<br><strong>陷阱traps</strong>：当陷阱被报告时，导致陷阱的指令的下一条动态指令的CS和EIP值将被保存。如果是在指令改变程序流期间发现陷阱，CS和EIP的值会反映程序流的变更。例如，执行<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/JMP.htm" target="_blank" rel="noopener">JMP</a>指令时发现陷阱，CS和EIP的值指向JMP的目标。<br><strong>终止aborts</strong>：终止是这样一种异常：它既不允许获取引起异常的指令的精确位置，也不允许重启导致异常的程序。终止用于报告严重的错误，比如硬件错误和不一致、系统表的非法值。  </p>
<h3 id="《9-8-1-Interrupt-0-–-Divide-Error》"><a href="#《9-8-1-Interrupt-0-–-Divide-Error》" class="headerlink" title="《9.8.1 Interrupt 0 – Divide Error》"></a>《9.8.1 Interrupt 0 – Divide Error》</h3><p>divide-error属于<strong>故障fault</strong>，在执行<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/DIV.htm" target="_blank" rel="noopener">DIV</a>或<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/IDIV.htm" target="_blank" rel="noopener">IDIV</a>指令时，如果除数为0则出现该故障。</p>
<h3 id="《9-8-2-Interrupt-1-–-Debug-Exceptions》"><a href="#《9-8-2-Interrupt-1-–-Debug-Exceptions》" class="headerlink" title="《9.8.2 Interrupt 1 – Debug Exceptions》"></a>《9.8.2 Interrupt 1 – Debug Exceptions》</h3><p>处理器触发调试异常的情况有很多种，该异常是故障还是陷阱取决于具体的情况：<br>指令地址断点 <strong>故障fault</strong><br>数据地址断点 <strong>陷阱trap</strong><br>一般检测 <strong>故障fault</strong><br>单步调试single-step <strong>陷阱trap</strong><br>任务切换断点 <strong>陷阱trap</strong><br>处理器不会将该异常的错误码进栈，异常处理程序可以通过检查调试寄存器来确定是哪些条件引起异常。 </p>
<h3 id="《9-8-3-Interrupt-3-–-Breakpoint》"><a href="#《9-8-3-Interrupt-3-–-Breakpoint》" class="headerlink" title="《9.8.3 Interrupt 3 – Breakpoint》"></a>《9.8.3 Interrupt 3 – Breakpoint》</h3><p><a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/INT.htm" target="_blank" rel="noopener">INT</a> 3指令导致该<strong>陷阱trap</strong>。INT 3指令只有一个字节长，这使得在一个可执行段将一个操作码替换为断点操作码变得很容易。操作系统或调试子系统可以为可执行段使用一个数据段别名，在任何方便捕获正常执行的地方放置INT 3，这样可以执行一些特殊处理，如显示寄存器变量。<br>CS:EIP保存的值指向了断点的后续字节。如果调试器用另外的有效操作符替代了断点，则应该在返回前将保存的EIP值减一。</p>
<h3 id="《9-8-4-Interrupt-4-–-Overflow》"><a href="#《9-8-4-Interrupt-4-–-Overflow》" class="headerlink" title="《9.8.4 Interrupt 4 – Overflow》"></a>《9.8.4 Interrupt 4 – Overflow》</h3><p>当处理器遇到<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/INT.htm" target="_blank" rel="noopener">INTO</a>指令并且设置了溢出标志OF时，引发该<strong>陷阱trap</strong>。由于有符号算术和无符号算术都使用相同的运算指令，处理器无法区分，因此不会自动引起溢出异常。因此，当在结果被解释为有符号数并且会越界的时候，处理器将设置OF位。当计算有符号操作数时，程序员和编译器要么直接测试OF位，要么使用INTO指令。</p>
<h3 id="《9-8-5-Interrupt-5-–-Bounds-Check》"><a href="#《9-8-5-Interrupt-5-–-Bounds-Check》" class="headerlink" title="《9.8.5 Interrupt 5 – Bounds Check》"></a>《9.8.5 Interrupt 5 – Bounds Check》</h3><p>当处理器在执行<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/BOUND.htm" target="_blank" rel="noopener">BOUND</a>指令并发现操作数超过指定的限制的时候，引发该<strong>故障fault</strong>。程序可以使用BOUND指令来检查定义在内存块中的有符号数组索引和有符号限长。</p>
<h3 id="《9-8-6-Interrupt-6-–-Invalid-Opcode》"><a href="#《9-8-6-Interrupt-6-–-Invalid-Opcode》" class="headerlink" title="《9.8.6 Interrupt 6 – Invalid Opcode》"></a>《9.8.6 Interrupt 6 – Invalid Opcode》</h3><p>如果在可执行单元中发现了无效的操作码，引发该<strong>故障fault</strong>。只有当试图执行该非法操作码的时候才会引发故障。该故障的错误码没有入栈。可以在相同的任务里处理该异常。<br>对于给定的操作码，如果操作数的类型是无效的也会引发该异常。比如段内<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/JMP.htm" target="_blank" rel="noopener">JMP</a>引用一个寄存器操作数，或者<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LGS.htm" target="_blank" rel="noopener">LES</a>指令涉及寄存器源操作数</p>
<h3 id="《9-8-7-Interrupt-7-–-Coprocessor-Not-Available》"><a href="#《9-8-7-Interrupt-7-–-Coprocessor-Not-Available》" class="headerlink" title="《9.8.7 Interrupt 7 – Coprocessor Not Available》"></a>《9.8.7 Interrupt 7 – Coprocessor Not Available》</h3><p>以下两种情况会引发该异常：<br>处理器遇到ESC(逃避escape)指令，且设置了CR0(control register zero)的EM(模拟emulate)位。<br>处理器遇到<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/WAIT.htm" target="_blank" rel="noopener">WAIT</a>指令或ESC指令，且设置了CR0的MP(监控协处理器monitor coprocessor)和TS(任务切换task switched)位。  </p>
<h3 id="《9-8-8-Interrupt-8-–-Double-Fault》"><a href="#《9-8-8-Interrupt-8-–-Double-Fault》" class="headerlink" title="《9.8.8 Interrupt 8 – Double Fault》"></a>《9.8.8 Interrupt 8 – Double Fault》</h3><p>通常情况下，当处理器试图调用异常处理程序处理之前的例外时又检测到异常，可以连续处理这两个异常。如果处理器不能串行处理它们，将会发出一个<strong>double-fault</strong>异常。为了确定何时将两个故障标识为double-fault，80386将异常分为三类：benign exceptions、contributory exceptions、page faults。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Table 9-3. Double-Fault Detection Classes</span><br><span class="line"></span><br><span class="line">Class           ID          Description</span><br><span class="line"></span><br><span class="line">                 1          Debug exceptions</span><br><span class="line">                 2          NMI</span><br><span class="line">                 3          Breakpoint</span><br><span class="line">Benign           4          Overflow</span><br><span class="line">Exceptions       5          Bounds check</span><br><span class="line">                 6          Invalid opcode</span><br><span class="line">                 7          Coprocessor not available</span><br><span class="line">                16          Coprocessor error</span><br><span class="line"></span><br><span class="line">                 0          Divide error</span><br><span class="line">                 9          Coprocessor Segment Overrun</span><br><span class="line">Contributory    10          Invalid TSS</span><br><span class="line">Exceptions      11          Segment not present</span><br><span class="line">                12          Stack exception</span><br><span class="line">                13          General protection</span><br><span class="line"></span><br><span class="line">Page Faults     14          Page fault</span><br></pre></td></tr></table></figure></p>
<p>以下说明哪些异常组合导致double-fault而哪些不会：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Table 9-4. Double-Fault Definition</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">                        |             SECOND EXCEPTION</span><br><span class="line">                        |</span><br><span class="line">                        |   Benign    |  Contributory  |  Page</span><br><span class="line">                        |   Exception |  Exception     |  Fault</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">           Benign       |   OK        |  OK            |  OK</span><br><span class="line">           Exception    |             |                |</span><br><span class="line">           ------------------------------------------------------</span><br><span class="line">FIRST      Contributory |   OK        |  DOUBLE        |  OK</span><br><span class="line">EXCEPTION  Exception    |             |                |</span><br><span class="line">           ------------------------------------------------------</span><br><span class="line">           Page         |             |                |</span><br><span class="line">           Fault        |   OK        |  DOUBLE        |  DOUBLE</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>处理器总会将double-fault的错误码入栈，但是错误码总为0。可能不会重新启动引发故障的指令。如果试图调用double-fault处理程序的过程中发生任何异常，将关闭处理器。</p>
<h3 id="《9-8-9-Interrupt-9-–-Coprocessor-Segment-Overrun》"><a href="#《9-8-9-Interrupt-9-–-Coprocessor-Segment-Overrun》" class="headerlink" title="《9.8.9 Interrupt 9 – Coprocessor Segment Overrun》"></a>《9.8.9 Interrupt 9 – Coprocessor Segment Overrun》</h3><p>在保护模式下，如果在传递协处理器操作数的中间部分到NPX的过程中80386检测到页面或段非法，将引发该异常。该异常是可以避免的。</p>
<h3 id="《9-8-10-Interrupt-10-–-Invalid-TSS》"><a href="#《9-8-10-Interrupt-10-–-Invalid-TSS》" class="headerlink" title="《9.8.10 Interrupt 10 – Invalid TSS》"></a>《9.8.10 Interrupt 10 – Invalid TSS》</h3><p>当任务切换期间新TSS是非法的将引发该异常。以下情况下TSS被认为是非法的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Table 9-5. Conditions That Invalidate the TSS</span><br><span class="line"></span><br><span class="line">Error Code              Condition</span><br><span class="line"></span><br><span class="line">TSS id + EXT            The limit in the TSS descriptor is less than 103</span><br><span class="line">LTD id + EXT            Invalid LDT selector or LDT not present</span><br><span class="line">SS id + EXT             Stack segment selector is outside table limit</span><br><span class="line">SS id + EXT             Stack segment is not a writable segment</span><br><span class="line">SS id + EXT             Stack segment DPL does not match new CPL</span><br><span class="line">SS id + EXT             Stack segment selector RPL &lt; &gt;  CPL</span><br><span class="line">CS id + EXT             Code segment selector is outside table limit</span><br><span class="line">CS id + EXT             Code segment selector does not refer to code</span><br><span class="line">                        segment</span><br><span class="line">CS id + EXT             DPL of non-conforming code segment &lt; &gt; new CPL</span><br><span class="line">CS id + EXT             DPL of conforming code segment &gt; new CPL</span><br><span class="line">DS/ES/FS/GS id + EXT    DS, ES, FS, or GS segment selector is outside</span><br><span class="line">                        table limits</span><br><span class="line">DS/ES/FS/GS id + EXT    DS, ES, FS, or GS is not readable segment</span><br></pre></td></tr></table></figure></p>
<p>该<strong>故障fault</strong>的错误码将入栈，用于帮助识别故障的原因。EXT位表示该异常是否由不受程序控制的外部情况所引发，比如经由任务门的外部中断引起非法TSS切换。<br>该故障可能出现在原始任务的上下文或新任务的上下文。异常停留在原始任务的上下文中直到处理器完全验证新TSS的存在。一旦新TSS被验证存在，任务切换则是完整的：也就是说，TR位已经被更新，并且如果是由CALL或中断导致该切换，新TSS反向链接旧TSS。此后处理器发现的任何错误都将在新任务的上下文中进行处理。<br>为了确保有合适的TSS，Interrupt 10的处理程序必须是经由任务门调用的一个任务。</p>
<h3 id="《9-8-11-Interrupt-11-–-Segment-Not-Present》"><a href="#《9-8-11-Interrupt-11-–-Segment-Not-Present》" class="headerlink" title="《9.8.11 Interrupt 11 – Segment Not Present》"></a>《9.8.11 Interrupt 11 – Segment Not Present》</h3><p>当处理器发现描述符的存在位为0时引发该异常。处理器在以下任何一种情况下可以引发该<strong>故障fault</strong>：<br>尝试加载CS、DS、ES、FS或GS寄存器；加载SS寄存器但导致了栈错误。<br>尝试通过<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LLDT.htm" target="_blank" rel="noopener">LLDT</a>指令加载LDT寄存器；在任务切换期间加载LDT寄存器，但导致”invalid TSS”异常。<br>尝试使用被标记为不存在的门描述符。<br>该故障可以重启。如果异常处理程序设置段存在并返回，被中断的程序将恢复执行。</p>
<p>如果在任务切换过程中发生了not-present异常，可能未完成任务切换的所有步骤。在任务切换时，处理器首先载入所有段寄存器，然后检查他们的有效性。一旦发现某个not-present异常，剩下的寄存器将不会被检查，因此不能用它们来引用内存。not-present异常处理程序在试图恢复新任务之前需要检查所有段寄存器，否则后续可能引发一般保护错误，使得诊断更加困难。有三种方法可以处理这种情况：<br>1、使用新任务来处理not-present故障。任务切换为被中断程序时，会导致处理器从TSS中加载所有寄存器并检查。<br>2、<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/PUSH.htm" target="_blank" rel="noopener">PUSH</a>和<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/POP.htm" target="_blank" rel="noopener">POP</a>所有段寄存器。POP指令会导致处理器检查所有段寄存器的新内容。<br>3、检查每个段寄存器在TSS中的镜像，模拟测试处理器加载它们的情况。  </p>
<p>该异常会将错误码入栈。如果外部事件引用了不存在段并引发中断，错误码的EXT位将被置位。如果错误码指向IDT项，I位将被置位，比如INT指令引用了一个不存在的门。<br>操作系统经常使用“segment not present”在段级别上实现虚拟内存。然而，门描述符not-present通常并不表示段不存在，因为门不一定对应于段。Not-present门可能只是操作系统为了某些特殊意义用于触发异常。</p>
<h3 id="《9-8-12-Interrupt-12-–-Stack-Exception》"><a href="#《9-8-12-Interrupt-12-–-Stack-Exception》" class="headerlink" title="《9.8.12 Interrupt 12 – Stack Exception》"></a>《9.8.12 Interrupt 12 – Stack Exception》</h3><p>以下两种情况一般会触发栈<strong>故障fault</strong>：<br>引用SS寄存器的任何操作由于违反限制的结果。包括<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/POP.htm" target="_blank" rel="noopener">POP</a>、<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/PUSH.htm" target="_blank" rel="noopener">PUSH</a>、<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/ENTER.htm" target="_blank" rel="noopener">ENTER</a>、<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LEAVE.htm" target="_blank" rel="noopener">LEAVE</a>，以及其他隐式使用SS的内存引用操作，如<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/MOV.htm" target="_blank" rel="noopener">MOV </a>AX, [BP+6]。当栈空间太小不满足局部变量空间时，ENTER引发该故障。<br>描述符有效但被标记为不存在的情况下尝试加载SS寄存器，引发该故障。这种情况可能发生在任务切换、interlevel CALL、interlevel return、LSS指令，或者针对SS的MOV或POP指令。  </p>
<p>当处理器检测到栈异常时，将错误码入栈。如果是由于not-present栈段，或由于interlevel CALL期间新栈溢出而引发异常，错误码将包含出问题的段选择器，处理器可以通过测试描述符的存在位来判断发生哪些异常；其他情况下错误码为0。<br>在所有情况下，导致该故障的指令都可被重启。保存到异常处理程序栈上的返回指针指向了需要被重启的指令。这个指令通常是导致该故障的指令，但如果是由于在任务切换时加载一个不存在的栈段描述符而引发了栈异常，该指令将是新任务的第一条指令。<br>如果在任务切换过程中发生了栈异常，段寄存器不能用于引用内存。在任务切换时，处理器在检查描述符之前首先载入所有段寄存器，然后检查段寄存器的有效性。一旦发现栈异常，剩下的寄存器将不会被检查，因此不能用CS, SS, DS, ES, FS, GS来引用内存。栈异常处理程序在试图恢复新任务之前需要检查所有段寄存器，否则后续可能引发一般保护错误，使得诊断更加困难。</p>
<h3 id="《9-8-13-Interrupt-13-–-General-Protection-Exception》"><a href="#《9-8-13-Interrupt-13-–-General-Protection-Exception》" class="headerlink" title="《9.8.13 Interrupt 13 – General Protection Exception》"></a>《9.8.13 Interrupt 13 – General Protection Exception》</h3><p>所有不会引发另一个异常的保护违反会引发一般保护异常。包括但不限于：<br>1、使用CS, DS, ES, FS, GS的时候超过限制。<br>2、引用一个描述符表的时候超过段长限制。<br>3、控制转移到一个不可执行的段。<br>4、写入只读数据段或代码段。<br>5、读取只执行段。<br>6、以一个只读描述符来加载SS。除非段寄存器是在任务切换期间来源于TSS，这种情况会引发TSS异常。<br>7、以系统段的描述符来加载SS, DS, ES, FS, GS。<br>8、以可执行但不可读的段的描述符来加载DS, ES, FS, GS。<br>9、以可执行段的描述符来加载SS。<br>10、当段寄存器包含一个空选择器时通过DS, ES, FS, GS访问内存。<br>11、切换到一个繁忙的任务。<br>12、违反特权规则。<br>13、加载CR0时 PG=1 且 PE=0。<br>14、经由中断门或陷阱门的中断或异常从V86模式到除0以外的特权级别。<br>15、超过15个字节的指令长度限制。仅当冗余前缀被放置在一条指令之前才会发生。</p>
<p>一般保护异常属于<strong>故障fault</strong>。在处理一般保护异常时，处理器将错误码保存到异常处理程序的栈上。如果因为加载描述符而导致异常，错误码将包含一个指向描述符的选择器；否则错误码为空。错误码的选择器可能来自于：1、选择器来源于指令的一个操作数。2、一个门的选择器是指令的操作数。3、选择器来源于任务切换时的TSS。</p>
<h3 id="《9-8-14-Interrupt-14-–-Page-Fault》"><a href="#《9-8-14-Interrupt-14-–-Page-Fault》" class="headerlink" title="《9.8.14 Interrupt 14 – Page Fault》"></a>《9.8.14 Interrupt 14 – Page Fault》</h3><p>允许分页的情况下，处理器在将线性地址转换为物理地址的过程中如果发现以下情况将会引发页错误：1、地址转换涉及到的页目录项或页表项的存在位为0；2、当前程序没有权限访问该物理页。<br>处理器为异常处理程序提供两种信息用于诊断和恢复：<br>1、保存到栈上的错误码，该错误码的格式不同于其他异常的错误码。如下所示：<br><img src="/2017/08/26/异常和中断/10.gif" title="页错误的错误码的格式"><br>错误码告知异常处理程序三件事：<br>1.1、异常是由于页面不存在还是违反访问权限所引起的。<br>1.2、发生异常的时间点上处理器是在用户级别还是supervisor级别。<br>1.3、引起异常的内存访问是写操作还是读操作。<br>2、CR2(control register two)。处理器将因访问内存而引起异常的线性地址保存到CR2中，异常处理程序可以根据该地址定位到页目录项和页表项。如果在页面错误处理程序执行期间出现了另一个页面错误，异常处理程序应该将CR2保存到栈上。如下所示：<br><img src="/2017/08/26/异常和中断/11.gif" title="CR2"></p>
<h4 id="《9-8-14-1-Page-Fault-During-Task-Switch》"><a href="#《9-8-14-1-Page-Fault-During-Task-Switch》" class="headerlink" title="《9.8.14.1 Page Fault During Task Switch》"></a>《9.8.14.1 Page Fault During Task Switch》</h4><p>任务切换期间，处理器可能访问四个部分：<br>1、在原先任务的TSS上保存原先任务的状态。<br>2、读取GDT，定位新任务的TSS描述符。<br>3、读取新任务的TSS，检查来源于TSS的段描述符的类型。<br>4、可能读取新任务的LDT，用于验证保存到新TSS上的段寄存器。<br>上述任何一种情况都可能导致页错误。后两种情况的页错误发生在新任务的上下文中。指令指针指的是新任务的下一个指令，而不是导致任务切换的指令。<br>如果操作系统允许在任务切换期间发生页错误，页错误处理程序应该经由任务门调用。</p>
<h4 id="《9-8-14-2-Page-Fault-with-Inconsistent-Stack-Pointer》"><a href="#《9-8-14-2-Page-Fault-with-Inconsistent-Stack-Pointer》" class="headerlink" title="《9.8.14.2 Page Fault with Inconsistent Stack Pointer》"></a>《9.8.14.2 Page Fault with Inconsistent Stack Pointer》</h4><p>应该特别注意的是，页错误不应该导致处理器使用了无效的栈指针(SS:ESP)。8086系列早期处理器经常使用一对指令来切换到新栈，如：<strong>MOV SS, AX;  MOV SP, StackTop</strong>。由于第二条指令会访问到内存，在SS改变而SP还没有改变的时候，可能会出现页错误。这种时候栈指针SS:SP（32位程序是SS:ESP）的两部分是不一致的。<br>如果页错误处理程序导致切换到定义良好的栈（即处理程序是一个任务或有更高特权的程序），处理器将不会使用不一致的栈指针。然而，如果页错误处理程序是经由中断门或陷阱门调用的，并且是在与页错误处理程序一样的特权级别下发生页错误，处理器仍然会尝试使用当前栈指针指向的栈（非法）。<br>系统实现分页后，在处理页错误时，应该使用<a href="https://pdos.csail.mit.edu/6.828/2014/readings/i386/LGS.htm" target="_blank" rel="noopener">LSS</a>指令来初始化新的栈。如果页错误处理程序在特权级别0上执行（通常情况下），页错误问题的范围就被限制在特权级别为0的代码上，通常这是操作系统的内核代码。</p>
<h3 id="《9-8-15-Interrupt-16-–-Coprocessor-Error》"><a href="#《9-8-15-Interrupt-16-–-Coprocessor-Error》" class="headerlink" title="《9.8.15 Interrupt 16 – Coprocessor Error》"></a>《9.8.15 Interrupt 16 – Coprocessor Error》</h3><p>如果在80386的ERROR# input pin上发现80287或80387信号时，80386引发该异常。80386只在开始执行ESC指令的时候，和遇到WAIT指令的时候（MSW的EM位为0），才会测试该pin。</p>
<h2 id="《9-9-Exception-Summary》"><a href="#《9-9-Exception-Summary》" class="headerlink" title="《9.9 Exception Summary》"></a>《9.9 Exception Summary》</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Table 9-6 summarizes the exceptions recognized by the 386</span><br><span class="line"></span><br><span class="line">Description  Interrupt  Return Address  Exception Type  Function That</span><br><span class="line">             Number     Points to                       Can Generate            </span><br><span class="line">                        Faulting                        the Exception</span><br><span class="line">                        Instruction</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Divide error    0        YES            FAULT           DIV, IDIV</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Debug           1                       Some debug      Any instruction</span><br><span class="line">exceptions               exceptions are traps and some                          </span><br><span class="line">                         are faults. The exception handler</span><br><span class="line">                         can determine which has occurred </span><br><span class="line">                         by examining DR6.  </span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Breakpoint     3         NO             TRAP            One-byte INT 3</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Overflow       4         NO             TRAP            INTO</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Bounds check   5         YES            FAULT           BOUND</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Invalid opcode 6         YES            FAULT           Any illegal </span><br><span class="line">                                                        instruction</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Coprocessor    7         YES            FAULT           ESC, WAIT</span><br><span class="line">not available    </span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Double fault  8          YES            ABORT         Any instruction         </span><br><span class="line">                                                    that can generate</span><br><span class="line">                                                      an exception</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Coprocessor   9          NO             ABORT        Any operand of an </span><br><span class="line">Segment Overrun                                      ESC instruction </span><br><span class="line">                                                     that wraps around</span><br><span class="line">                                                     the end of a</span><br><span class="line">                                                     segment</span><br><span class="line">----------------------------------------------------------------------- </span><br><span class="line">Invalid TSS  10         YES             FAULT      JMP, CALL, IRET, </span><br><span class="line">                                                   any interrupt</span><br><span class="line">An invalid-TSS fault is not restartable if it occurs during the</span><br><span class="line">processing of an external interrupt.    </span><br><span class="line">-----------------------------------------------------------------------    </span><br><span class="line">Segment not  11         YES             FAULT         Any segment-</span><br><span class="line">present                                               register modifier</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Stack        12         YES             FAULT         Any memory</span><br><span class="line">exception                                             reference thru SS</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">General      13         YES             FAULT/        Any memory </span><br><span class="line">Protection                              ABORT         reference or </span><br><span class="line">                                                      code fetch</span><br><span class="line">All GP faults are restartable. If the fault occurs while attempting to</span><br><span class="line">vector to the handler for an external interrupt, the interrupted program is restartable, but the interrupt may be lost.  </span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Page fault  14          YES             FAULT         Any memory </span><br><span class="line">                                                      reference or  </span><br><span class="line">                                                      code fetch</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">Coprocessor 16          YES             FAULT         ESC, WAIT</span><br><span class="line">error</span><br><span class="line">Coprocessor errors are reported as a fault on the first ESC or WAIT</span><br><span class="line">instruction executed after the ESC instruction that caused the error. </span><br><span class="line">-----------------------------------------------------------------------       </span><br><span class="line">Two-byte    0-255       NO              TRAP          INT n</span><br><span class="line">SW Interrupt</span><br></pre></td></tr></table></figure>
<h2 id="《9-10-Error-Code-Summary》"><a href="#《9-10-Error-Code-Summary》" class="headerlink" title="《9.10 Error Code Summary》"></a>《9.10 Error Code Summary》</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Table 9-7 summarizes the error information that is available with each </span><br><span class="line">exception.</span><br><span class="line"> </span><br><span class="line">Description                 Interrupt Number    Error Code     </span><br><span class="line">-----------------------------------------------------------------------                  </span><br><span class="line">Divide error                       0            No</span><br><span class="line">Debug exceptions                   1            No</span><br><span class="line">Breakpoint                         3            No</span><br><span class="line">Overflow                           4            No</span><br><span class="line">Bounds check                       5            No</span><br><span class="line">Invalid opcode                     6            No</span><br><span class="line">Coprocessor not available          7            No</span><br><span class="line">System error                       8            Yes (always 0)</span><br><span class="line">Coprocessor Segment Overrun        9            No</span><br><span class="line">Invalid TSS                       10            Yes</span><br><span class="line">Segment not present               11            Yes</span><br><span class="line">Stack exception                   12            Yes</span><br><span class="line">General protection fault          13            Yes</span><br><span class="line">Page fault                        14            Yes</span><br><span class="line">Coprocessor error                 16            No</span><br><span class="line">Two-byte SW interrupt             0-255         No</span><br></pre></td></tr></table></figure>
<p>系统预留中断类型：<br><img src="/2017/08/26/异常和中断/12.PNG" title="系统预留中断类型"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/远程登陆centos-ubuntu桌面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/远程登陆centos-ubuntu桌面/" itemprop="url">远程登陆centos/ubuntu桌面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T10:39:55+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux应用/" itemprop="url" rel="index">
                    <span itemprop="name">Linux应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu可参考"><a href="#ubuntu可参考" class="headerlink" title="ubuntu可参考"></a>ubuntu可参考</h1><p><a href="https://help.ubuntu.com/community/VNC/Servers#Start\_TigerVNC\_vncserver\_at\_boot" target="_blank" rel="noopener">https://help.ubuntu.com/community/VNC/Servers#Start\_TigerVNC\_vncserver\_at\_boot</a></p>
<h1 id="查看是否安装桌面"><a href="#查看是否安装桌面" class="headerlink" title="查看是否安装桌面"></a>查看是否安装桌面</h1><p><code>sudo yum grouplist</code><br><img src="/2017/08/26/远程登陆centos-ubuntu桌面/1.PNG" title="查看安装的软件"><br>若没有以上两项，安装<br><code>sudo  yum groupinstall -y &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot;</code></p>
<h1 id="安装vnc-server"><a href="#安装vnc-server" class="headerlink" title="安装vnc-server"></a>安装vnc-server</h1><p><code>yum install tigervnc-server -y</code></p>
<p>ubuntu14.04:<br><code>wget https://bintray.com/artifact/download/tigervnc/stable/ubuntu-14.04LTS/amd64/tigervncserver_1.6.0-3ubuntu1_amd64.deb</code><br><code>sudo dpkg -i tigervncserver_1.6.0-3ubuntu1_amd64.deb</code><br>如果发现依赖错误：<code>sudo apt-get install -f</code></p>
<h1 id="vnc运行机制"><a href="#vnc运行机制" class="headerlink" title="vnc运行机制"></a>vnc运行机制</h1><p>Linux下的VNC可以同时启动多个vncserver，各个vncserver之间用显示编号(display number)来区分，每个vncserver服务监听3个端口，它们分别是：<br>1、5800+显示编号: VNC的httpd监听端口，如果VNC客户端为IE,Firefox等非vncviewer时必须开放。<br>2、5900+显示编号: VNC服务端与客户端通信的真正端口，必须无条件开放。<br>3、6000+显示编号: X监听端口，可选。</p>
<p>显示编号、开放的端口分别由/etc/sysconfig/vncservers(<strong>ubuntu 14.04为 /etc/default/vncservers</strong>)文件中的VNCSERVERS和VNCSERVERARGS控制。<br>VNCSERVERS的设置方式为：<br><code>VNCSERVERS=&quot;显示编号1:用户名1 …&quot;</code><br>如：<code>VNCSERVERS=&quot;1:root 2:aiezu&quot;</code><br>VNCSERVERARGS的设置方式为：<br><code>VNCSERVERARGS[显示编号1]=&quot;参数一 参数值一 参数二 参数值二 ……&quot;</code><br>如：<code>VNCSERVERARGS[2]=&quot;-geometry 800x600 -nohttpd&quot;</code> </p>
<p>VNCSERVERARGS的详细参数有：<br>-geometry 桌面分辨率,默认1024x768；<br>-nohttpd 不监听HTTP端口(58xx端口)；<br>-nolisten tcp 不监听X端口(60xx端口)；<br>-localhost 只允许从本机访问；<br>-AlwaysShared 默认只同时允许一个vncviewer连接，此参数允许同时连多个vncviewer；<br>-SecurityTypes None 登录不需要密码认证VncAuth默认值,要密码认证。</p>
<h1 id="配置vnc-server-centos7方式1"><a href="#配置vnc-server-centos7方式1" class="headerlink" title="配置vnc-server:centos7方式1"></a>配置vnc-server:centos7方式1</h1><p>（可省略）<br>假设登录用户为vnc，复制一份通用的VNC服务文件来为用户vnc创建一个VNC服务配置<br><code>sudo cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service</code><br><code>sudo vi /etc/systemd/system/vncserver@:1.service</code>  </p>
<p>打开文件后找到以下内容，替换<user>为用户vnc。<br><code>ExecStart=/sbin/runuser -l &lt;USER&gt; -c &quot;/usr/bin/vncserver %i&quot;</code><br><code>PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pid</code>  </user></p>
<p>重新加载服务来使新的VNC配置生效<br><code>sudo systemctl daemon-reload</code></p>
<h1 id="配置vnc-server-方式2"><a href="#配置vnc-server-方式2" class="headerlink" title="配置vnc-server:方式2"></a>配置vnc-server:方式2</h1><p>（可省略）<br><code>sudo vi /etc/sysconfig/vncserver</code><br>ubuntu 14.04：<code>sudo vi /etc/default/vncservers</code><br>添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VNCSERVERS=&quot;1:vnc&quot;</span><br><span class="line">VNCSERVERARGS[1]=&quot;-geometry 1600:900 -nolisten tcp&quot;</span><br></pre></td></tr></table></figure></p>
<p>重新加载服务来使新的VNC配置生效<br><code>sudo systemctl daemon-reload</code><br>ubuntu 14.04：<code>sudo service vncserver restart</code></p>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>在启动时自动启动VNC服务<br><code>sudo systemctl enable vncserver@:1.service</code></p>
<p>ubuntu14.04: enable the service at boot with:<br><code>sudo update-rc.d vncserver defaults</code></p>
<h1 id="设置VNC用户密码"><a href="#设置VNC用户密码" class="headerlink" title="设置VNC用户密码"></a>设置VNC用户密码</h1><p>切换到vnc用户，并运行<code>vncpasswd</code>命令，输入远程连接密码</p>
<p>运行<code>vncserver</code>命令，显示的序号是在5900基础上加上虚拟机中的VNC序号。</p>
<p>运行上面命令后，会在用户根目录($HOME)下的”.vnc”文件夹下生成一系列文件。其中passwd为vnc用户密码文件，由vncpasswd生成。其他的都由vnc初次启动时生成，xstartup为VNC客户端连接时启动的脚本。</p>
<p>重新加载服务来使新的VNC配置生效<br><code>sudo systemctl daemon-reload</code><br> ubuntu 14.04：<code>sudo service vncserver restart</code></p>
<h1 id="开启VNC端口"><a href="#开启VNC端口" class="headerlink" title="开启VNC端口"></a>开启VNC端口</h1><p>开放的端口为5900+VNC序号<br><code>sudo iptables -I INPUT -p tcp --dport 5901 -j ACCEPT</code></p>
<h1 id="查看vnc在服务器上的端口号"><a href="#查看vnc在服务器上的端口号" class="headerlink" title="查看vnc在服务器上的端口号"></a>查看vnc在服务器上的端口号</h1><p><code>netstat -lp|grep -i vnc</code></p>
<h1 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h1><p>下载vnc viewer，server框中输入ip:1(1代表上面配置的远程用户代号，配置文件中可以配置多个远程用户)或者ip:port，输入VNC密码，连接到远程桌面。</p>
<h1 id="ubuntu没有显示菜单栏"><a href="#ubuntu没有显示菜单栏" class="headerlink" title="ubuntu没有显示菜单栏"></a>ubuntu没有显示菜单栏</h1><p>修改~/.vnc/xstartup，将其内容替换为以下内容，确保软件都安装过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup</span><br><span class="line">[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;</span><br><span class="line"></span><br><span class="line">gnome-session --session=gnome-flashback &amp;</span><br><span class="line">gnome-panel &amp;</span><br><span class="line">gnome-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus &amp;</span><br><span class="line">vncconfig -nowin &amp;i</span><br></pre></td></tr></table></figure></p>
<p>session参数可在<code>/usr/share/gnome-session/sessions/</code>中查看。</p>
<h1 id="vnc加密"><a href="#vnc加密" class="headerlink" title="vnc加密"></a>vnc加密</h1><p>从设计上说，VNC使用的远程帧缓存（RFB）并不是一种安全的协议，VNC客户端直接连接到VNC服务器上并不明智。任何敏感信息在VNC流量中被轻易地泄露。因此，建议使用SSH隧道来加密VNC流量。<br>在运行VNC客户端的本机上，使用下面的命令来创建一个连接到远程VPS的SSH通道。当被要输入SSH密码时，输入用户的密码。<br><code>ssh vnc@&lt;VPS-IP-address&gt; -L 5901:127.0.0.1:5901</code><br>一旦SSH通道建立，远程VNC流量就会通过ssh通道路由并发送到127.0.0.1:5901。现在启动VNC客户端（比如：vinagre），来连接到127.0.0.1:5901。</p>
<p> ubuntu 14.04重启服务：<code>sudo service vncserver restart</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/centos7安装mariadb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/centos7安装mariadb/" itemprop="url">centos7安装mariadb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T10:37:57+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux应用/" itemprop="url" rel="index">
                    <span itemprop="name">Linux应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>sudo yum install mariadb-server mariadb</code> </p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>mariadb数据库的相关命令是：</p>
<p><code>sudo systemctl start mariadb</code>  #启动MariaDB</p>
<p><code>sudo systemctl stop mariadb</code>  #停止MariaDB</p>
<p><code>sudo systemctl restart mariadb</code>  #重启MariaDB</p>
<p><code>sudo systemctl enable mariadb</code>  #设置开机启动</p>
<h1 id="出错及其解决方法"><a href="#出错及其解决方法" class="headerlink" title="出错及其解决方法"></a>出错及其解决方法</h1><p>出错：Job for mariadb.service failed. See ‘systemctl status mariadb.service’ and ‘journalctl -xn’ for details.</p>
<p>执行 <code>sudo systemctl status mariadb.service</code></p>
<p>根据提示查看 <code>/var/log/mariadb/mariadb.log</code></p>
<p>出错原因：<br>InnoDB: Error: log file ./ib_logfile0 is of different size 0 8388608 bytes<br>InnoDB: than specified in the .cnf file 0 5242880 bytes!<br>InnoDB: Possible causes for this error:<br> (a) Incorrect log file is used or log file size is changed<br> (b) In case default size is used this log file is from 10.0<br> (c) Log file is corrupted or there was not enough disk space<br> In case (b) you need to set innodb_log_file_size = 48M</p>
<p>解决：<br>关闭服务：<code>sudo systemctl stop mariadb</code>；<br>删除对应文件：<code>sudo rm -f /var/lib/mysql/ib_logfile*</code>；<br>修改/etc/my.cnf文件，添加以下内容：<br><code>innodb_log_file_size    = 8M</code><br>重启服务：<code>sudo systemctl start mariadb</code></p>
<p>在你修改my.cnf的innodb_log_file_size参数前，请先停止mysql服务程序的运行（mysql的停止没有出现任何错误），并把/var/lib/mysql目录下的ib_logfile0、ib_logfile1、ib_logfile2等之类的文件移除到一个安全的地方（旧日志文件的保留是为了防止意外的出现），以便Mysql重启后可以将新的ib_logfile0之类日志文件生成到/var/lib/mysql目录下。如果没有什么意外，旧的日志文件可以删除。</p>
<p>（一些其他说法：<a href="http://cqfish.blog.51cto.com/622299/393346）" target="_blank" rel="noopener">http://cqfish.blog.51cto.com/622299/393346）</a></p>
<p>仍然出错：<br>[ERROR] Can’t open the mysql.plugin table. Please run mysql_upgrade to create it</p>
<p>解决：<br><code>mysql_install_db --user=mysql --ldata=/var/lib/mysql/</code> </p>
<h1 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h1><p><code>sudo systemctl stop mariadb</code>  #停止MariaDB<br><code>mysqld_safe --skip-grant-tables&amp;</code> #对所有的表设置成无密码登陆<br><code>mysql -u root -p</code><br>mysql&gt; <code>use mysql;</code><br>mysql&gt; <code>UPDATE user SET password=PASSWORD(&quot;new password&quot;) WHERE user=&#39;root&#39;;</code><br>mysql&gt; <code>FLUSH PRIVILEGES;</code><br>mysql&gt; <code>quit;</code></p>
<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>1.导出结构不导出数据<br><code>mysqldump　--opt　-d　数据库名　-u　root　-p　&gt;　xxx.sql</code>　　 </p>
<p>2.导出数据不导出结构<br><code>mysqldump　-t　数据库名　-uroot　-p　&gt;　xxx.sql</code>　 </p>
<p>3.导出数据和表结构<br><code>mysqldump　数据库名　-uroot　-p　&gt;　xxx.sql</code> </p>
<p>4.导出特定表的结构<br><code>mysqldump　-uroot　-p　-B　数据库名　--table　表名　&gt;　xxx.sql</code>　　 </p>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p><code>CREATE DATABASE  数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</code><br><code>use 数据库名;</code><br><code>source 数据库文件;</code></p>
<h1 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h1><p><code>mysql -u root -p</code><br>mysql&gt; <code>use mysql;</code><br>允许用户root使用密码rootroot从任何主机连接到mysql服务器：<br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;rootroot&#39; WITH GRANT OPTION;</code><br>允许用户root使用密码rootroot从ip为192.168.1.3的主机连接到mysql服务器：<br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;192.168.1.3&#39; IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION;</code><br>mysql&gt; <code>FLUSH PRIVILEGES;</code><br>mysql&gt; <code>quit;</code></p>
<h1 id="ubuntu-14-04-远程连接"><a href="#ubuntu-14-04-远程连接" class="headerlink" title="ubuntu 14.04 远程连接"></a>ubuntu 14.04 远程连接</h1><p>ubuntu 14.04安装的是mysql，而不是mariadb。<br>另外，若要远程连接ubuntu 14.04的mysql，除了上述操作外还需要在目录/etc/mysql下找到my.cnf，将<code>bind-address = 127.0.0.1</code>注释。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.jianzzz.com/2017/08/26/本地借由公网机跳板到私网机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zoro">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zoro.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝色步行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/本地借由公网机跳板到私网机/" itemprop="url">本地借由公网机跳板到私网机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T10:35:22+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux应用/" itemprop="url" rel="index">
                    <span itemprop="name">Linux应用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iptables设置规则"><a href="#iptables设置规则" class="headerlink" title="iptables设置规则"></a>iptables设置规则</h1><p><a href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html" target="_blank" rel="noopener">Iptables 指南 1.1.19</a><br><a href="http://blog.csdn.net/reyleon/article/details/12976341" target="_blank" rel="noopener">Iptables详解</a><br><a href="http://www.ha97.com/4082.html" target="_blank" rel="noopener">iptables/netfilter全攻略详解</a></p>
<p>iptables默认三张表：<br>1、filter：防火墙，包含INPUT、OUTPUT、FORWARD<br>2、nat：网络地转转换，包含PREROUTING、POSTROUTING、OUTPUT<br>3、mangle：流量整形，包含所有的五条链</p>
<p>iptables的五条链 -&gt;写规则的地方<br>1、INPUT:数据包的目地的是LINUX主机本身<br>2、OUTPUT:数据包由LINUX主机本身发送<br>3、FORWARD:数据包从一个接口进入，另一个接口发出（如果做路由转发的话必须开启/etc/sysctl.conf 修改net.ipv4.ip_forward=1）<br>4、PREROUTING:做路由之前<br>5、POSTROUTING:做路由之后</p>
<img src="/2017/08/26/本地借由公网机跳板到私网机/1.gif" title="iptables">
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>A本地机<br>B公网机（跳板机）：公网116.56.140.66，私网172.16.1.100<br>C私网机：172.16.1.56<br>A发送116.56.140.66:5000，B将其转发到C私网机172.16.1.56:5000</p>
<h1 id="转发规则设置"><a href="#转发规则设置" class="headerlink" title="转发规则设置"></a>转发规则设置</h1><p>1、打开内核转发文件，允许转发<br><code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</code><br>2、将访问116.56.140.66:5000的数据包目的地址改为172.16.1.56:5000，但注意不要指定-d 116.56.140.66，因为公网机接收的数据包可能也是被某个路由转发过来的，原先发送到116.56.140.66:5000的数据包目的地址被该路由改变过了，即公网机接收的数据包的目的地址不是116.56.140.66<br><code>sudo iptables -t nat -I PREROUTING -p tcp --dport 5000 -j DNAT --to-destination 172.16.1.56:5000</code><br>3、允许转发目的地址为172.16.1.56:5000的数据包<br><code>sudo iptables -t filter -I FORWARD -p tcp -d 172.16.1.56 --dport 5000 -j ACCEPT</code><br>4、将访问172.16.1.56:5000的数据包源地址改为172.16.1.100（不要改为公网116.56.140.66）<br><code>sudo iptables -t nat -I POSTROUTING -p tcp -d 172.16.1.56 --dport 5000 -j SNAT --to 172.16.1.100</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/zoro.jpg" alt="zoro">
          <p class="site-author-name" itemprop="name">zoro</p>
           
              <p class="site-description motion-element" itemprop="description">如果我后退的话，我曾重视的誓言和约定就会全部消失，然后，再也不会回来这个地方了</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoro</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  
  
  
  
  
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="/js/gitment.browser.js"></script>
  
    <script type="text/javascript">
      function ShowGitment(){
        document.getElementById("gitment-display-button").style.display = "none";
        document.getElementById("gitment-container").style.display = "block";
        var gitment = new Gitment({
          id: document.location.href, 
          owner: 'jianzzz',
          repo: 'blog-comment',
          oauth: {
            client_id: '956e5ce77224160fc0d3',
            client_secret: 'fa469f545631edd86de345f8da7b85347aedeb15',
          }});
        gitment.render('gitment-container');
      }
    </script>
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
